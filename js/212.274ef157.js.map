{"version":3,"file":"js/212.274ef157.js","mappings":"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","sources":["webpack://dramka_project/node_modules/browser-pack-flat/_prelude","webpack://dramka_project/packages/@interactjs/utils/isWindow.ts","webpack://dramka_project/packages/@interactjs/utils/window.ts","webpack://dramka_project/packages/@interactjs/utils/is.ts","webpack://dramka_project/packages/@interactjs/actions/drag/plugin.ts","webpack://dramka_project/packages/@interactjs/utils/domObjects.ts","webpack://dramka_project/packages/@interactjs/utils/browser.ts","webpack://dramka_project/packages/@interactjs/utils/domUtils.ts","webpack://dramka_project/packages/@interactjs/utils/extend.ts","webpack://dramka_project/packages/@interactjs/utils/rect.ts","webpack://dramka_project/packages/@interactjs/utils/getOriginXY.ts","webpack://dramka_project/packages/@interactjs/utils/normalizeListeners.ts","webpack://dramka_project/packages/@interactjs/utils/hypot.ts","webpack://dramka_project/packages/@interactjs/utils/pointerExtend.ts","webpack://dramka_project/packages/@interactjs/utils/pointerUtils.ts","webpack://dramka_project/packages/@interactjs/core/BaseEvent.ts","webpack://dramka_project/packages/@interactjs/utils/arr.ts","webpack://dramka_project/packages/@interactjs/actions/drop/DropEvent.ts","webpack://dramka_project/packages/@interactjs/actions/drop/plugin.ts","webpack://dramka_project/packages/@interactjs/actions/gesture/plugin.ts","webpack://dramka_project/packages/@interactjs/actions/resize/plugin.ts","webpack://dramka_project/packages/@interactjs/actions/plugin.ts","webpack://dramka_project/packages/@interactjs/utils/raf.ts","webpack://dramka_project/packages/@interactjs/auto-scroll/plugin.ts","webpack://dramka_project/packages/@interactjs/utils/misc.ts","webpack://dramka_project/packages/@interactjs/auto-start/InteractableMethods.ts","webpack://dramka_project/packages/@interactjs/auto-start/base.ts","webpack://dramka_project/packages/@interactjs/auto-start/dragAxis.ts","webpack://dramka_project/packages/@interactjs/auto-start/hold.ts","webpack://dramka_project/packages/@interactjs/auto-start/plugin.ts","webpack://dramka_project/packages/@interactjs/core/interactablePreventDefault.ts","webpack://dramka_project/packages/@interactjs/dev-tools/visualizer/plugin.ts","webpack://dramka_project/packages/@interactjs/dev-tools/plugin.ts","webpack://dramka_project/packages/@interactjs/utils/clone.ts","webpack://dramka_project/packages/@interactjs/modifiers/Modification.ts","webpack://dramka_project/packages/@interactjs/modifiers/base.ts","webpack://dramka_project/packages/@interactjs/core/options.ts","webpack://dramka_project/packages/@interactjs/core/InteractEvent.ts","webpack://dramka_project/packages/@interactjs/core/PointerInfo.ts","webpack://dramka_project/packages/@interactjs/core/Interaction.ts","webpack://dramka_project/packages/@interactjs/offset/plugin.ts","webpack://dramka_project/packages/@interactjs/inertia/plugin.ts","webpack://dramka_project/packages/@interactjs/core/Eventable.ts","webpack://dramka_project/packages/@interactjs/core/isNonNativeEvent.ts","webpack://dramka_project/packages/@interactjs/core/InteractStatic.ts","webpack://dramka_project/packages/@interactjs/core/Interactable.ts","webpack://dramka_project/packages/@interactjs/core/InteractableSet.ts","webpack://dramka_project/packages/@interactjs/core/events.ts","webpack://dramka_project/packages/@interactjs/core/interactionFinder.ts","webpack://dramka_project/packages/@interactjs/core/interactions.ts","webpack://dramka_project/packages/@interactjs/core/scope.ts","webpack://dramka_project/packages/@interactjs/interact/index.ts","webpack://dramka_project/packages/@interactjs/snappers/edgeTarget.ts","webpack://dramka_project/packages/@interactjs/snappers/elements.ts","webpack://dramka_project/packages/@interactjs/snappers/grid.ts","webpack://dramka_project/packages/@interactjs/snappers/plugin.ts","webpack://dramka_project/packages/@interactjs/modifiers/aspectRatio.ts","webpack://dramka_project/packages/@interactjs/modifiers/noop.ts","webpack://dramka_project/packages/@interactjs/modifiers/restrict/pointer.ts","webpack://dramka_project/packages/@interactjs/modifiers/restrict/edges.ts","webpack://dramka_project/packages/@interactjs/modifiers/restrict/rect.ts","webpack://dramka_project/packages/@interactjs/modifiers/restrict/size.ts","webpack://dramka_project/packages/@interactjs/modifiers/snap/pointer.ts","webpack://dramka_project/packages/@interactjs/modifiers/snap/size.ts","webpack://dramka_project/packages/@interactjs/modifiers/snap/edges.ts","webpack://dramka_project/packages/@interactjs/modifiers/all.ts","webpack://dramka_project/packages/@interactjs/modifiers/plugin.ts","webpack://dramka_project/packages/@interactjs/pointer-events/PointerEvent.ts","webpack://dramka_project/packages/@interactjs/pointer-events/base.ts","webpack://dramka_project/packages/@interactjs/pointer-events/holdRepeat.ts","webpack://dramka_project/packages/@interactjs/pointer-events/interactableTargets.ts","webpack://dramka_project/packages/@interactjs/pointer-events/plugin.ts","webpack://dramka_project/packages/@interactjs/reflow/plugin.ts","webpack://dramka_project/packages/@interactjs/interactjs/index.ts","webpack://dramka_project/packages/interactjs/index.ts","webpack://dramka_project/node_modules/browser-pack-flat/_postlude","webpack://dramka_project/./src/views/DramkaGame.vue","webpack://dramka_project/./src/components/NavBar_game.vue","webpack://dramka_project/./src/components/NavBar_game.vue?2671","webpack://dramka_project/./node_modules/vue-swipy/src/Swipeable.vue","webpack://dramka_project/./node_modules/vue-swipy/src/Swipeable.vue?0938","webpack://dramka_project/./src/views/DramkaGame.vue?0db3"],"sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.interact = f()}})(function(){var define,module,exports;\n","export default (thing: any) => !!(thing && thing.Window) && thing instanceof thing.Window\n","import isWindow from './isWindow'\n\nexport let realWindow = undefined as Window\n\nlet win = undefined as Window\nexport { win as window }\n\nexport function init (window: Window & { wrap?: (...args: any[]) => any }) {\n  // get wrapped window if using Shadow DOM polyfill\n\n  realWindow = window\n\n  // create a TextNode\n  const el = window.document.createTextNode('')\n\n  // check if it's wrapped by a polyfill\n  if (el.ownerDocument !== window.document && typeof window.wrap === 'function' && window.wrap(el) === el) {\n    // use wrapped window\n    window = window.wrap(window)\n  }\n\n  win = window\n}\n\nif (typeof window !== 'undefined' && !!window) {\n  init(window)\n}\n\nexport function getWindow (node: any) {\n  if (isWindow(node)) {\n    return node\n  }\n\n  const rootNode = node.ownerDocument || node\n\n  return rootNode.defaultView || win.window\n}\n","import type { Element } from '@interactjs/types/index'\n\nimport isWindow from './isWindow'\nimport * as win from './window'\n\nconst window = (thing: any): thing is Window => thing === win.window || isWindow(thing)\n\nconst docFrag = (thing: any): thing is DocumentFragment => object(thing) && thing.nodeType === 11\n\nconst object = (thing: any): thing is { [index: string]: any } => !!thing && typeof thing === 'object'\n\nconst func = (thing: any): thing is (...args: any[]) => any => typeof thing === 'function'\n\nconst number = (thing: any): thing is number => typeof thing === 'number'\n\nconst bool = (thing: any): thing is boolean => typeof thing === 'boolean'\n\nconst string = (thing: any): thing is string => typeof thing === 'string'\n\nconst element = (thing: any): thing is Element => {\n  if (!thing || typeof thing !== 'object') {\n    return false\n  }\n\n  // eslint-disable-next-line import/no-named-as-default-member\n  const _window = win.getWindow(thing) || win.window\n\n  return /object|function/.test(typeof _window.Element)\n    ? thing instanceof _window.Element // DOM2\n    : thing.nodeType === 1 && typeof thing.nodeName === 'string'\n}\n\nconst plainObject: typeof object = (thing: any): thing is { [index: string]: any } =>\n  object(thing) && !!thing.constructor && /function Object\\b/.test(thing.constructor.toString())\n\nconst array = <T extends unknown>(thing: any): thing is T[] =>\n  object(thing) && typeof thing.length !== 'undefined' && func(thing.splice)\n\nexport default {\n  window,\n  docFrag,\n  object,\n  func,\n  number,\n  bool,\n  string,\n  element,\n  plainObject,\n  array,\n}\n","import type { InteractEvent } from '@interactjs/core/InteractEvent'\nimport type { Interactable } from '@interactjs/core/Interactable'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type { ActionMethod, DraggableOptions, DropzoneOptions } from '@interactjs/types/index'\nimport is from '@interactjs/utils/is'\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    draggable: DraggableMethod\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface ActionDefaults {\n    drag: DraggableOptions\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface ActionMap {\n    drag?: typeof drag\n  }\n}\n\nexport type DragEvent = InteractEvent<'drag'>\n\nexport type DraggableMethod = ActionMethod<DraggableOptions>\n\nfunction install (scope: Scope) {\n  const { actions, Interactable, defaults } = scope\n\n  Interactable.prototype.draggable = drag.draggable\n\n  actions.map.drag = drag\n  actions.methodDict.drag = 'draggable'\n\n  defaults.actions.drag = drag.defaults\n}\n\nfunction beforeMove ({ interaction }) {\n  if (interaction.prepared.name !== 'drag') return\n\n  const axis = interaction.prepared.axis\n\n  if (axis === 'x') {\n    interaction.coords.cur.page.y = interaction.coords.start.page.y\n    interaction.coords.cur.client.y = interaction.coords.start.client.y\n\n    interaction.coords.velocity.client.y = 0\n    interaction.coords.velocity.page.y = 0\n  } else if (axis === 'y') {\n    interaction.coords.cur.page.x = interaction.coords.start.page.x\n    interaction.coords.cur.client.x = interaction.coords.start.client.x\n\n    interaction.coords.velocity.client.x = 0\n    interaction.coords.velocity.page.x = 0\n  }\n}\n\nfunction move ({ iEvent, interaction }) {\n  if (interaction.prepared.name !== 'drag') return\n\n  const axis = interaction.prepared.axis\n\n  if (axis === 'x' || axis === 'y') {\n    const opposite = axis === 'x' ? 'y' : 'x'\n\n    iEvent.page[opposite] = interaction.coords.start.page[opposite]\n    iEvent.client[opposite] = interaction.coords.start.client[opposite]\n    iEvent.delta[opposite] = 0\n  }\n}\n\n/**\n * ```js\n * interact(element).draggable({\n *     onstart: function (event) {},\n *     onmove : function (event) {},\n *     onend  : function (event) {},\n *\n *     // the axis in which the first movement must be\n *     // for the drag sequence to start\n *     // 'xy' by default - any direction\n *     startAxis: 'x' || 'y' || 'xy',\n *\n *     // 'xy' by default - don't restrict to one axis (move in any direction)\n *     // 'x' or 'y' to restrict movement to either axis\n *     // 'start' to restrict movement to the axis the drag started in\n *     lockAxis: 'x' || 'y' || 'xy' || 'start',\n *\n *     // max number of drags that can happen concurrently\n *     // with elements of this Interactable. Infinity by default\n *     max: Infinity,\n *\n *     // max number of drags that can target the same element+Interactable\n *     // 1 by default\n *     maxPerElement: 2\n * })\n *\n * var isDraggable = interact('element').draggable(); // true\n * ```\n *\n * Get or set whether drag actions can be performed on the target\n *\n * @alias Interactable.prototype.draggable\n *\n * @param {boolean | object} [options] true/false or An object with event\n * listeners to be fired on drag events (object makes the Interactable\n * draggable)\n * @return {boolean | Interactable} boolean indicating if this can be the\n * target of drag events, or this Interctable\n */\nconst draggable: DraggableMethod = function draggable (\n  this: Interactable,\n  options?: DraggableOptions | boolean,\n): any {\n  if (is.object(options)) {\n    this.options.drag.enabled = options.enabled !== false\n    this.setPerAction('drag', options)\n    this.setOnEvents('drag', options)\n\n    if (/^(xy|x|y|start)$/.test(options.lockAxis)) {\n      this.options.drag.lockAxis = options.lockAxis\n    }\n    if (/^(xy|x|y)$/.test(options.startAxis)) {\n      this.options.drag.startAxis = options.startAxis\n    }\n\n    return this\n  }\n\n  if (is.bool(options)) {\n    this.options.drag.enabled = options\n\n    return this\n  }\n\n  return this.options.drag\n}\n\nconst drag: Plugin = {\n  id: 'actions/drag',\n  install,\n  listeners: {\n    'interactions:before-action-move': beforeMove,\n    'interactions:action-resume': beforeMove,\n\n    // dragmove\n    'interactions:action-move': move,\n    'auto-start:check': (arg) => {\n      const { interaction, interactable, buttons } = arg\n      const dragOptions = interactable.options.drag\n\n      if (\n        !(dragOptions && dragOptions.enabled) ||\n        // check mouseButton setting if the pointer is down\n        (interaction.pointerIsDown &&\n          /mouse|pointer/.test(interaction.pointerType) &&\n          (buttons & interactable.options.drag.mouseButtons) === 0)\n      ) {\n        return undefined\n      }\n\n      arg.action = {\n        name: 'drag',\n        axis: dragOptions.lockAxis === 'start' ? dragOptions.startAxis : dragOptions.lockAxis,\n      }\n\n      return false\n    },\n  },\n  draggable,\n  beforeMove,\n  move,\n  defaults: {\n    startAxis: 'xy',\n    lockAxis: 'xy',\n  } as DropzoneOptions,\n\n  getCursor () {\n    return 'move'\n  },\n}\n\nexport default drag\n","const domObjects: {\n  init: any\n  document: Document\n  DocumentFragment: typeof DocumentFragment\n  SVGElement: typeof SVGElement\n  SVGSVGElement: typeof SVGSVGElement\n  SVGElementInstance: any\n  Element: typeof Element\n  HTMLElement: typeof HTMLElement\n  Event: typeof Event\n  Touch: typeof Touch\n  PointerEvent: typeof PointerEvent\n} = {\n  init,\n  document: null,\n  DocumentFragment: null,\n  SVGElement: null,\n  SVGSVGElement: null,\n  SVGElementInstance: null,\n  Element: null,\n  HTMLElement: null,\n  Event: null,\n  Touch: null,\n  PointerEvent: null,\n}\n\nfunction blank () {}\n\nexport default domObjects\n\nfunction init (window: Window) {\n  const win = window as any\n\n  domObjects.document = win.document\n  domObjects.DocumentFragment = win.DocumentFragment || blank\n  domObjects.SVGElement = win.SVGElement || blank\n  domObjects.SVGSVGElement = win.SVGSVGElement || blank\n  domObjects.SVGElementInstance = win.SVGElementInstance || blank\n  domObjects.Element = win.Element || blank\n  domObjects.HTMLElement = win.HTMLElement || domObjects.Element\n\n  domObjects.Event = win.Event\n  domObjects.Touch = win.Touch || blank\n  domObjects.PointerEvent = win.PointerEvent || win.MSPointerEvent\n}\n","import domObjects from './domObjects'\nimport is from './is'\n\nconst browser = {\n  init,\n  supportsTouch: null as boolean,\n  supportsPointerEvent: null as boolean,\n  isIOS7: null as boolean,\n  isIOS: null as boolean,\n  isIe9: null as boolean,\n  isOperaMobile: null as boolean,\n  prefixedMatchesSelector: null as 'matches',\n  pEventTypes: null as {\n    up: string\n    down: string\n    over: string\n    out: string\n    move: string\n    cancel: string\n  },\n  wheelEvent: null as string,\n}\n\nfunction init (window: any) {\n  const Element = domObjects.Element\n  const navigator: Partial<Navigator> = window.navigator || {}\n\n  // Does the browser support touch input?\n  browser.supportsTouch =\n    'ontouchstart' in window ||\n    (is.func(window.DocumentTouch) && domObjects.document instanceof window.DocumentTouch)\n\n  // Does the browser support PointerEvents\n  browser.supportsPointerEvent = navigator.pointerEnabled !== false && !!domObjects.PointerEvent\n\n  browser.isIOS = /iP(hone|od|ad)/.test(navigator.platform)\n\n  // scrolling doesn't change the result of getClientRects on iOS 7\n  browser.isIOS7 = /iP(hone|od|ad)/.test(navigator.platform) && /OS 7[^\\d]/.test(navigator.appVersion)\n\n  browser.isIe9 = /MSIE 9/.test(navigator.userAgent)\n\n  // Opera Mobile must be handled differently\n  browser.isOperaMobile =\n    navigator.appName === 'Opera' && browser.supportsTouch && /Presto/.test(navigator.userAgent)\n\n  // prefix matchesSelector\n  browser.prefixedMatchesSelector = ('matches' in Element.prototype\n    ? 'matches'\n    : 'webkitMatchesSelector' in Element.prototype\n      ? 'webkitMatchesSelector'\n      : 'mozMatchesSelector' in Element.prototype\n        ? 'mozMatchesSelector'\n        : 'oMatchesSelector' in Element.prototype\n          ? 'oMatchesSelector'\n          : 'msMatchesSelector') as 'matches'\n\n  browser.pEventTypes = browser.supportsPointerEvent\n    ? domObjects.PointerEvent === window.MSPointerEvent\n      ? {\n        up: 'MSPointerUp',\n        down: 'MSPointerDown',\n        over: 'mouseover',\n        out: 'mouseout',\n        move: 'MSPointerMove',\n        cancel: 'MSPointerCancel',\n      }\n      : {\n        up: 'pointerup',\n        down: 'pointerdown',\n        over: 'pointerover',\n        out: 'pointerout',\n        move: 'pointermove',\n        cancel: 'pointercancel',\n      }\n    : null\n\n  // because Webkit and Opera still use 'mousewheel' event type\n  browser.wheelEvent = domObjects.document && 'onmousewheel' in domObjects.document ? 'mousewheel' : 'wheel'\n}\n\nexport default browser\n","import type { Rect, Target, Element } from '@interactjs/types/index'\n\nimport browser from './browser'\nimport domObjects from './domObjects'\nimport is from './is'\nimport * as win from './window'\n\nexport function nodeContains (parent: Node, child: Node) {\n  if (parent.contains) {\n    return parent.contains(child as Node)\n  }\n\n  while (child) {\n    if (child === parent) {\n      return true\n    }\n\n    child = (child as Node).parentNode\n  }\n\n  return false\n}\n\nexport function closest (element: Node, selector: string) {\n  while (is.element(element)) {\n    if (matchesSelector(element, selector)) {\n      return element\n    }\n\n    element = parentNode(element)\n  }\n\n  return null\n}\n\nexport function parentNode (node: Node | Document) {\n  let parent = node.parentNode\n\n  if (is.docFrag(parent)) {\n    // skip past #shado-root fragments\n    // tslint:disable-next-line\n    while ((parent = (parent as any).host) && is.docFrag(parent)) {\n      continue\n    }\n\n    return parent\n  }\n\n  return parent\n}\n\nexport function matchesSelector (element: Element, selector: string) {\n  // remove /deep/ from selectors if shadowDOM polyfill is used\n  if (win.window !== win.realWindow) {\n    selector = selector.replace(/\\/deep\\//g, ' ')\n  }\n\n  return element[browser.prefixedMatchesSelector](selector)\n}\n\nconst getParent = (el: Node | Document | ShadowRoot) => el.parentNode || (el as ShadowRoot).host\n\n// Test for the element that's \"above\" all other qualifiers\nexport function indexOfDeepestElement (elements: Element[] | NodeListOf<globalThis.Element>) {\n  let deepestNodeParents: Node[] = []\n  let deepestNodeIndex: number\n\n  for (let i = 0; i < elements.length; i++) {\n    const currentNode = elements[i]\n    const deepestNode: Node = elements[deepestNodeIndex]\n\n    // node may appear in elements array multiple times\n    if (!currentNode || i === deepestNodeIndex) {\n      continue\n    }\n\n    if (!deepestNode) {\n      deepestNodeIndex = i\n      continue\n    }\n\n    const currentNodeParent = getParent(currentNode)\n    const deepestNodeParent = getParent(deepestNode)\n\n    // check if the deepest or current are document.documentElement/rootElement\n    // - if the current node is, do nothing and continue\n    if (currentNodeParent === currentNode.ownerDocument) {\n      continue\n    }\n    // - if deepest is, update with the current node and continue to next\n    else if (deepestNodeParent === currentNode.ownerDocument) {\n      deepestNodeIndex = i\n      continue\n    }\n\n    // compare zIndex of siblings\n    if (currentNodeParent === deepestNodeParent) {\n      if (zIndexIsHigherThan(currentNode, deepestNode)) {\n        deepestNodeIndex = i\n      }\n\n      continue\n    }\n\n    // populate the ancestry array for the latest deepest node\n    deepestNodeParents = deepestNodeParents.length ? deepestNodeParents : getNodeParents(deepestNode)\n\n    let ancestryStart: Node\n\n    // if the deepest node is an HTMLElement and the current node is a non root svg element\n    if (\n      deepestNode instanceof domObjects.HTMLElement &&\n      currentNode instanceof domObjects.SVGElement &&\n      !(currentNode instanceof domObjects.SVGSVGElement)\n    ) {\n      // TODO: is this check necessary? Was this for HTML elements embedded in SVG?\n      if (currentNode === deepestNodeParent) {\n        continue\n      }\n\n      ancestryStart = currentNode.ownerSVGElement\n    } else {\n      ancestryStart = currentNode\n    }\n\n    const currentNodeParents = getNodeParents(ancestryStart, deepestNode.ownerDocument)\n    let commonIndex = 0\n\n    // get (position of closest common ancestor) + 1\n    while (\n      currentNodeParents[commonIndex] &&\n      currentNodeParents[commonIndex] === deepestNodeParents[commonIndex]\n    ) {\n      commonIndex++\n    }\n\n    const parents = [\n      currentNodeParents[commonIndex - 1],\n      currentNodeParents[commonIndex],\n      deepestNodeParents[commonIndex],\n    ]\n\n    if (parents[0]) {\n      let child = parents[0].lastChild\n\n      while (child) {\n        if (child === parents[1]) {\n          deepestNodeIndex = i\n          deepestNodeParents = currentNodeParents\n\n          break\n        } else if (child === parents[2]) {\n          break\n        }\n\n        child = child.previousSibling\n      }\n    }\n  }\n\n  return deepestNodeIndex\n}\n\nfunction getNodeParents (node: Node, limit?: Node) {\n  const parents: Node[] = []\n  let parent: Node = node\n  let parentParent: Node\n\n  while ((parentParent = getParent(parent)) && parent !== limit && parentParent !== parent.ownerDocument) {\n    parents.unshift(parent)\n    parent = parentParent\n  }\n\n  return parents\n}\n\nfunction zIndexIsHigherThan (higherNode: Node, lowerNode: Node) {\n  const higherIndex = parseInt(win.getWindow(higherNode).getComputedStyle(higherNode).zIndex, 10) || 0\n  const lowerIndex = parseInt(win.getWindow(lowerNode).getComputedStyle(lowerNode).zIndex, 10) || 0\n\n  return higherIndex >= lowerIndex\n}\n\nexport function matchesUpTo (element: Element, selector: string, limit: Node) {\n  while (is.element(element)) {\n    if (matchesSelector(element, selector)) {\n      return true\n    }\n\n    element = parentNode(element) as Element\n\n    if (element === limit) {\n      return matchesSelector(element, selector)\n    }\n  }\n\n  return false\n}\n\nexport function getActualElement (element: Element) {\n  return (element as SVGElement).correspondingUseElement || element\n}\n\nexport function getScrollXY (relevantWindow?: Window) {\n  relevantWindow = relevantWindow || win.window\n  return {\n    x: relevantWindow.scrollX || relevantWindow.document.documentElement.scrollLeft,\n    y: relevantWindow.scrollY || relevantWindow.document.documentElement.scrollTop,\n  }\n}\n\nexport function getElementClientRect (element: Element): Required<Rect> {\n  const clientRect =\n    element instanceof domObjects.SVGElement ? element.getBoundingClientRect() : element.getClientRects()[0]\n\n  return (\n    clientRect && {\n      left: clientRect.left,\n      right: clientRect.right,\n      top: clientRect.top,\n      bottom: clientRect.bottom,\n      width: clientRect.width || clientRect.right - clientRect.left,\n      height: clientRect.height || clientRect.bottom - clientRect.top,\n    }\n  )\n}\n\nexport function getElementRect (element: Element) {\n  const clientRect = getElementClientRect(element)\n\n  if (!browser.isIOS7 && clientRect) {\n    const scroll = getScrollXY(win.getWindow(element))\n\n    clientRect.left += scroll.x\n    clientRect.right += scroll.x\n    clientRect.top += scroll.y\n    clientRect.bottom += scroll.y\n  }\n\n  return clientRect\n}\n\nexport function getPath (node: Node | Document) {\n  const path = []\n\n  while (node) {\n    path.push(node)\n    node = parentNode(node)\n  }\n\n  return path\n}\n\nexport function trySelector (value: Target) {\n  if (!is.string(value)) {\n    return false\n  }\n\n  // an exception will be raised if it is invalid\n  domObjects.document.querySelector(value)\n  return true\n}\n","export default function extend<T, U extends object> (dest: U & Partial<T>, source: T): T & U {\n  for (const prop in source) {\n    ;((dest as unknown) as T)[prop] = source[prop]\n  }\n\n  const ret = dest as T & U\n\n  return ret\n}\n","import type {\n  HasGetRect,\n  RectResolvable,\n  Rect,\n  Element,\n  Point,\n  FullRect,\n  EdgeOptions,\n} from '@interactjs/types'\n\nimport { closest, getElementRect, parentNode } from './domUtils'\nimport extend from './extend'\nimport is from './is'\n\nexport function getStringOptionResult (value: any, target: HasGetRect, element: Node) {\n  if (value === 'parent') {\n    return parentNode(element)\n  }\n\n  if (value === 'self') {\n    return target.getRect(element as Element)\n  }\n\n  return closest(element, value)\n}\n\nexport function resolveRectLike<T extends any[]> (\n  value: RectResolvable<T>,\n  target?: HasGetRect,\n  element?: Node,\n  functionArgs?: T,\n) {\n  let returnValue: any = value\n  if (is.string(returnValue)) {\n    returnValue = getStringOptionResult(returnValue, target, element)\n  } else if (is.func(returnValue)) {\n    returnValue = returnValue(...functionArgs)\n  }\n\n  if (is.element(returnValue)) {\n    returnValue = getElementRect(returnValue)\n  }\n\n  return returnValue as Rect\n}\n\nexport function rectToXY (rect: Rect | Point) {\n  return (\n    rect && {\n      x: 'x' in rect ? rect.x : rect.left,\n      y: 'y' in rect ? rect.y : rect.top,\n    }\n  )\n}\n\nexport function xywhToTlbr<T extends Partial<Rect & Point>> (rect: T) {\n  if (rect && !('left' in rect && 'top' in rect)) {\n    rect = extend({}, rect)\n\n    rect.left = rect.x || 0\n    rect.top = rect.y || 0\n    rect.right = rect.right || rect.left + rect.width\n    rect.bottom = rect.bottom || rect.top + rect.height\n  }\n\n  return rect as Rect & T\n}\n\nexport function tlbrToXywh (rect: Rect & Partial<Point>) {\n  if (rect && !('x' in rect && 'y' in rect)) {\n    rect = extend({}, rect)\n\n    rect.x = rect.left || 0\n    rect.y = rect.top || 0\n    rect.width = rect.width || (rect.right || 0) - rect.x\n    rect.height = rect.height || (rect.bottom || 0) - rect.y\n  }\n\n  return rect as FullRect & Point\n}\n\nexport function addEdges (edges: EdgeOptions, rect: Rect, delta: Point) {\n  if (edges.left) {\n    rect.left += delta.x\n  }\n  if (edges.right) {\n    rect.right += delta.x\n  }\n  if (edges.top) {\n    rect.top += delta.y\n  }\n  if (edges.bottom) {\n    rect.bottom += delta.y\n  }\n\n  rect.width = rect.right - rect.left\n  rect.height = rect.bottom - rect.top\n}\n","import type { PerActionDefaults } from '@interactjs/core/options'\nimport type { ActionName } from '@interactjs/core/scope'\nimport type { HasGetRect } from '@interactjs/types/index'\n\nimport { rectToXY, resolveRectLike } from './rect'\n\nexport default function (\n  target: HasGetRect & { options: PerActionDefaults },\n  element: Node,\n  actionName?: ActionName,\n) {\n  const actionOptions = (target.options as any)[actionName]\n  const actionOrigin = actionOptions && actionOptions.origin\n  const origin = actionOrigin || target.options.origin\n\n  const originRect = resolveRectLike(origin, target, element, [target && element])\n\n  return rectToXY(originRect) || { x: 0, y: 0 }\n}\n","import type { EventTypes, Listener, ListenersArg } from '@interactjs/types/index'\n\nimport extend from './extend'\nimport is from './is'\n\nexport interface NormalizedListeners {\n  [type: string]: Listener[]\n}\n\nexport default function normalize (\n  type: EventTypes,\n  listeners?: ListenersArg | ListenersArg[],\n  result?: NormalizedListeners,\n): NormalizedListeners {\n  result = result || {}\n\n  if (is.string(type) && type.search(' ') !== -1) {\n    type = split(type)\n  }\n\n  if (is.array(type)) {\n    return type.reduce<NormalizedListeners>((acc, t) => extend(acc, normalize(t, listeners, result)), result)\n  }\n\n  // ({ type: fn }) -> ('', { type: fn })\n  if (is.object(type)) {\n    listeners = type\n    type = ''\n  }\n\n  if (is.func(listeners)) {\n    result[type] = result[type] || []\n    result[type].push(listeners)\n  } else if (is.array(listeners)) {\n    for (const l of listeners) {\n      normalize(type, l, result)\n    }\n  } else if (is.object(listeners)) {\n    for (const prefix in listeners) {\n      const combinedTypes = split(prefix).map((p) => `${type}${p}`)\n\n      normalize(combinedTypes, listeners[prefix], result)\n    }\n  }\n\n  return result as NormalizedListeners\n}\n\nfunction split (type: string) {\n  return type.trim().split(/ +/)\n}\n","export default (x: number, y: number) => Math.sqrt(x * x + y * y)\n","function pointerExtend<T> (dest: Partial<T>, source: T) {\n  for (const prop in source) {\n    const prefixedPropREs = pointerExtend.prefixedPropREs\n    let deprecated = false\n\n    // skip deprecated prefixed properties\n    for (const vendor in prefixedPropREs) {\n      if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {\n        deprecated = true\n        break\n      }\n    }\n\n    if (!deprecated && typeof source[prop] !== 'function') {\n      dest[prop] = source[prop]\n    }\n  }\n  return dest\n}\n\npointerExtend.prefixedPropREs = {\n  webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/,\n  moz: /(Pressure)$/,\n} as { [prefix: string]: RegExp }\n\nexport default pointerExtend\n","import type { InteractEvent } from '@interactjs/core/InteractEvent'\nimport type { CoordsSetMember, PointerType, Point, PointerEventType, Element } from '@interactjs/types/index'\n\nimport browser from './browser'\nimport dom from './domObjects'\nimport * as domUtils from './domUtils'\nimport hypot from './hypot'\nimport is from './is'\nimport pointerExtend from './pointerExtend'\n\nexport function copyCoords (dest: CoordsSetMember, src: CoordsSetMember) {\n  dest.page = dest.page || ({} as any)\n  dest.page.x = src.page.x\n  dest.page.y = src.page.y\n\n  dest.client = dest.client || ({} as any)\n  dest.client.x = src.client.x\n  dest.client.y = src.client.y\n\n  dest.timeStamp = src.timeStamp\n}\n\nexport function setCoordDeltas (targetObj: CoordsSetMember, prev: CoordsSetMember, cur: CoordsSetMember) {\n  targetObj.page.x = cur.page.x - prev.page.x\n  targetObj.page.y = cur.page.y - prev.page.y\n  targetObj.client.x = cur.client.x - prev.client.x\n  targetObj.client.y = cur.client.y - prev.client.y\n  targetObj.timeStamp = cur.timeStamp - prev.timeStamp\n}\n\nexport function setCoordVelocity (targetObj: CoordsSetMember, delta: CoordsSetMember) {\n  const dt = Math.max(delta.timeStamp / 1000, 0.001)\n\n  targetObj.page.x = delta.page.x / dt\n  targetObj.page.y = delta.page.y / dt\n  targetObj.client.x = delta.client.x / dt\n  targetObj.client.y = delta.client.y / dt\n  targetObj.timeStamp = dt\n}\n\nexport function setZeroCoords (targetObj: CoordsSetMember) {\n  targetObj.page.x = 0\n  targetObj.page.y = 0\n  targetObj.client.x = 0\n  targetObj.client.y = 0\n}\n\nexport function isNativePointer (pointer: any) {\n  return pointer instanceof dom.Event || pointer instanceof dom.Touch\n}\n\n// Get specified X/Y coords for mouse or event.touches[0]\nexport function getXY (type: string, pointer: PointerType | InteractEvent, xy: Point) {\n  xy = xy || ({} as Point)\n  type = type || 'page'\n\n  xy.x = pointer[(type + 'X') as keyof PointerType]\n  xy.y = pointer[(type + 'Y') as keyof PointerType]\n\n  return xy\n}\n\nexport function getPageXY (pointer: PointerType | InteractEvent, page?: Point) {\n  page = page || { x: 0, y: 0 }\n\n  // Opera Mobile handles the viewport and scrolling oddly\n  if (browser.isOperaMobile && isNativePointer(pointer)) {\n    getXY('screen', pointer, page)\n\n    page.x += window.scrollX\n    page.y += window.scrollY\n  } else {\n    getXY('page', pointer, page)\n  }\n\n  return page\n}\n\nexport function getClientXY (pointer: PointerType, client: Point) {\n  client = client || ({} as any)\n\n  if (browser.isOperaMobile && isNativePointer(pointer)) {\n    // Opera Mobile handles the viewport and scrolling oddly\n    getXY('screen', pointer, client)\n  } else {\n    getXY('client', pointer, client)\n  }\n\n  return client\n}\n\nexport function getPointerId (pointer: { pointerId?: number, identifier?: number, type?: string }) {\n  return is.number(pointer.pointerId) ? pointer.pointerId! : pointer.identifier!\n}\n\nexport function setCoords (dest: CoordsSetMember, pointers: any[], timeStamp: number) {\n  const pointer = pointers.length > 1 ? pointerAverage(pointers) : pointers[0]\n\n  getPageXY(pointer, dest.page)\n  getClientXY(pointer, dest.client)\n\n  dest.timeStamp = timeStamp\n}\n\nexport function getTouchPair (event: TouchEvent | PointerType[]) {\n  const touches: PointerType[] = []\n\n  // array of touches is supplied\n  if (is.array(event)) {\n    touches[0] = event[0]\n    touches[1] = event[1]\n  }\n  // an event\n  else {\n    if (event.type === 'touchend') {\n      if (event.touches.length === 1) {\n        touches[0] = event.touches[0]\n        touches[1] = event.changedTouches[0]\n      } else if (event.touches.length === 0) {\n        touches[0] = event.changedTouches[0]\n        touches[1] = event.changedTouches[1]\n      }\n    } else {\n      touches[0] = event.touches[0]\n      touches[1] = event.touches[1]\n    }\n  }\n\n  return touches\n}\n\nexport function pointerAverage (pointers: PointerType[]) {\n  const average = {\n    pageX: 0,\n    pageY: 0,\n    clientX: 0,\n    clientY: 0,\n    screenX: 0,\n    screenY: 0,\n  }\n\n  type CoordKeys = keyof typeof average\n\n  for (const pointer of pointers) {\n    for (const prop in average) {\n      average[prop as CoordKeys] += pointer[prop as CoordKeys]\n    }\n  }\n  for (const prop in average) {\n    average[prop as CoordKeys] /= pointers.length\n  }\n\n  return average\n}\n\nexport function touchBBox (event: PointerType[]) {\n  if (!event.length) {\n    return null\n  }\n\n  const touches = getTouchPair(event)\n  const minX = Math.min(touches[0].pageX, touches[1].pageX)\n  const minY = Math.min(touches[0].pageY, touches[1].pageY)\n  const maxX = Math.max(touches[0].pageX, touches[1].pageX)\n  const maxY = Math.max(touches[0].pageY, touches[1].pageY)\n\n  return {\n    x: minX,\n    y: minY,\n    left: minX,\n    top: minY,\n    right: maxX,\n    bottom: maxY,\n    width: maxX - minX,\n    height: maxY - minY,\n  }\n}\n\nexport function touchDistance (event: PointerType[] | TouchEvent, deltaSource: string) {\n  const sourceX = (deltaSource + 'X') as 'pageX'\n  const sourceY = (deltaSource + 'Y') as 'pageY'\n  const touches = getTouchPair(event)\n\n  const dx = touches[0][sourceX] - touches[1][sourceX]\n  const dy = touches[0][sourceY] - touches[1][sourceY]\n\n  return hypot(dx, dy)\n}\n\nexport function touchAngle (event: PointerType[] | TouchEvent, deltaSource: string) {\n  const sourceX = (deltaSource + 'X') as 'pageX'\n  const sourceY = (deltaSource + 'Y') as 'pageY'\n  const touches = getTouchPair(event)\n  const dx = touches[1][sourceX] - touches[0][sourceX]\n  const dy = touches[1][sourceY] - touches[0][sourceY]\n  const angle = (180 * Math.atan2(dy, dx)) / Math.PI\n\n  return angle\n}\n\nexport function getPointerType (pointer: { pointerType?: string, identifier?: number, type?: string }) {\n  return is.string(pointer.pointerType)\n    ? pointer.pointerType\n    : is.number(pointer.pointerType)\n      ? [undefined, undefined, 'touch', 'pen', 'mouse'][pointer.pointerType]!\n      : // if the PointerEvent API isn't available, then the \"pointer\" must\n    // be either a MouseEvent, TouchEvent, or Touch object\n      /touch/.test(pointer.type || '') || pointer instanceof dom.Touch\n        ? 'touch'\n        : 'mouse'\n}\n\n// [ event.target, event.currentTarget ]\nexport function getEventTargets (event: Event) {\n  const path = is.func(event.composedPath)\n    ? (event.composedPath() as Element[])\n    : ((event as unknown) as { path: Element[] }).path\n\n  return [\n    domUtils.getActualElement(path ? path[0] : (event.target as Element)),\n    domUtils.getActualElement(event.currentTarget as Element),\n  ]\n}\n\nexport function newCoords (): CoordsSetMember {\n  return {\n    page: { x: 0, y: 0 },\n    client: { x: 0, y: 0 },\n    timeStamp: 0,\n  }\n}\n\nexport function coordsToEvent (coords: MockCoords) {\n  const event = {\n    coords,\n    get page () {\n      return this.coords.page\n    },\n    get client () {\n      return this.coords.client\n    },\n    get timeStamp () {\n      return this.coords.timeStamp\n    },\n    get pageX () {\n      return this.coords.page.x\n    },\n    get pageY () {\n      return this.coords.page.y\n    },\n    get clientX () {\n      return this.coords.client.x\n    },\n    get clientY () {\n      return this.coords.client.y\n    },\n    get pointerId () {\n      return this.coords.pointerId\n    },\n    get target () {\n      return this.coords.target\n    },\n    get type () {\n      return this.coords.type\n    },\n    get pointerType () {\n      return this.coords.pointerType\n    },\n    get buttons () {\n      return this.coords.buttons\n    },\n    preventDefault () {},\n  }\n\n  return event as typeof event & PointerType & PointerEventType\n}\n\nexport interface MockCoords {\n  page: Point\n  client: Point\n  timeStamp?: number\n  pointerId?: any\n  target?: any\n  type?: string\n  pointerType?: string\n  buttons?: number\n}\n\nexport { pointerExtend }\n","import type { Interactable } from '@interactjs/core/Interactable'\nimport type { Interaction, InteractionProxy } from '@interactjs/core/Interaction'\nimport type { ActionName } from '@interactjs/core/scope'\n\nexport class BaseEvent<T extends ActionName | null = never> {\n  type: string\n  target: EventTarget\n  currentTarget: Node\n  interactable: Interactable\n  _interaction: Interaction<T>\n  timeStamp: any\n  immediatePropagationStopped = false\n  propagationStopped = false\n\n  constructor (interaction: Interaction<T>) {\n    this._interaction = interaction\n  }\n\n  preventDefault () {}\n\n  /**\n   * Don't call any other listeners (even on the current target)\n   */\n  stopPropagation () {\n    this.propagationStopped = true\n  }\n\n  /**\n   * Don't call listeners on the remaining targets\n   */\n  stopImmediatePropagation () {\n    this.immediatePropagationStopped = this.propagationStopped = true\n  }\n}\n\n// defined outside of class definition to avoid assignment of undefined during\n// construction\nexport interface BaseEvent<T extends ActionName> {\n  interaction: InteractionProxy<T>\n}\n\n// getters and setters defined here to support typescript 3.6 and below which\n// don't support getter and setters in .d.ts files\nObject.defineProperty(BaseEvent.prototype, 'interaction', {\n  get (this: BaseEvent) {\n    return this._interaction._proxy\n  },\n  set (this: BaseEvent) {},\n})\n","type Filter<T> = (element: T, index: number, array: T[]) => boolean\n\nexport const contains = <T>(array: T[], target: T) => array.indexOf(target) !== -1\n\nexport const remove = <T>(array: T[], target: T) => array.splice(array.indexOf(target), 1)\n\nexport const merge = <T, U>(target: Array<T | U>, source: U[]) => {\n  for (const item of source) {\n    target.push(item)\n  }\n\n  return target\n}\n\nexport const from = <T = any>(source: ArrayLike<T>) => merge([] as T[], source as T[])\n\nexport const findIndex = <T>(array: T[], func: Filter<T>) => {\n  for (let i = 0; i < array.length; i++) {\n    if (func(array[i], i, array)) {\n      return i\n    }\n  }\n\n  return -1\n}\n\nexport const find = <T = any>(array: T[], func: Filter<T>) => array[findIndex(array, func)]\n","import { BaseEvent } from '@interactjs/core/BaseEvent'\nimport type { InteractEvent } from '@interactjs/core/InteractEvent'\nimport type { Interactable } from '@interactjs/core/Interactable'\nimport type { Element } from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\n\nimport type { DropState } from './plugin'\n\nexport class DropEvent extends BaseEvent<'drag'> {\n  target: Element\n  dropzone: Interactable\n  dragEvent: InteractEvent<'drag'>\n  relatedTarget: Element\n  draggable: Interactable\n  timeStamp: number\n  propagationStopped = false\n  immediatePropagationStopped = false\n\n  /**\n   * Class of events fired on dropzones during drags with acceptable targets.\n   */\n  constructor (dropState: DropState, dragEvent: InteractEvent<'drag'>, type: string) {\n    super(dragEvent._interaction)\n\n    const { element, dropzone } = type === 'dragleave' ? dropState.prev : dropState.cur\n\n    this.type = type\n    this.target = element\n    this.currentTarget = element\n    this.dropzone = dropzone\n    this.dragEvent = dragEvent\n    this.relatedTarget = dragEvent.target\n    this.draggable = dragEvent.interactable\n    this.timeStamp = dragEvent.timeStamp\n  }\n\n  /**\n   * If this is a `dropactivate` event, the dropzone element will be\n   * deactivated.\n   *\n   * If this is a `dragmove` or `dragenter`, a `dragleave` will be fired on the\n   * dropzone element and more.\n   */\n  reject () {\n    const { dropState } = this._interaction\n\n    if (\n      this.type !== 'dropactivate' &&\n      (!this.dropzone || dropState.cur.dropzone !== this.dropzone || dropState.cur.element !== this.target)\n    ) {\n      return\n    }\n\n    dropState.prev.dropzone = this.dropzone\n    dropState.prev.element = this.target\n\n    dropState.rejected = true\n    dropState.events.enter = null\n\n    this.stopImmediatePropagation()\n\n    if (this.type === 'dropactivate') {\n      const activeDrops = dropState.activeDrops\n      const index = arr.findIndex(\n        activeDrops,\n        ({ dropzone, element }) => dropzone === this.dropzone && element === this.target,\n      )\n\n      dropState.activeDrops.splice(index, 1)\n\n      const deactivateEvent = new DropEvent(dropState, this.dragEvent, 'dropdeactivate')\n\n      deactivateEvent.dropzone = this.dropzone\n      deactivateEvent.target = this.target\n\n      this.dropzone.fire(deactivateEvent)\n    } else {\n      this.dropzone.fire(new DropEvent(dropState, this.dragEvent, 'dragleave'))\n    }\n  }\n\n  preventDefault () {}\n\n  stopPropagation () {\n    this.propagationStopped = true\n  }\n\n  stopImmediatePropagation () {\n    this.immediatePropagationStopped = this.propagationStopped = true\n  }\n}\n","import type { EventPhase, InteractEvent } from '@interactjs/core/InteractEvent'\nimport type { Interactable } from '@interactjs/core/Interactable'\nimport type { Interaction, DoPhaseArg } from '@interactjs/core/Interaction'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type { DropzoneOptions, Element, PointerEventType, Rect } from '@interactjs/types/index'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport getOriginXY from '@interactjs/utils/getOriginXY'\nimport is from '@interactjs/utils/is'\nimport normalizeListeners from '@interactjs/utils/normalizeListeners'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nimport type { DragEvent } from '../drag/plugin'\nimport drag from '../drag/plugin'\n\nimport { DropEvent } from './DropEvent'\n\nexport interface DropzoneMethod {\n  (this: Interactable, options: DropzoneOptions | boolean): Interactable\n  (): DropzoneOptions\n}\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    dropzone: DropzoneMethod\n    dropCheck: (\n      dragEvent: InteractEvent,\n      event: PointerEventType,\n      draggable: Interactable,\n      draggableElement: Element,\n      dropElemen: Element,\n      rect: any,\n    ) => boolean\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    dropState?: DropState\n  }\n}\n\ndeclare module '@interactjs/core/InteractEvent' {\n  interface InteractEvent {\n    prevDropzone?: Interactable\n    dropzone?: Interactable\n    dragEnter?: Element\n    dragLeave?: Element\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface ActionDefaults {\n    drop: DropzoneOptions\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface ActionMap {\n    drop?: typeof drop\n  }\n\n  interface Scope {\n    dynamicDrop?: boolean\n  }\n\n  interface SignalArgs {\n    'actions/drop:start': DropSignalArg\n    'actions/drop:move': DropSignalArg\n    'actions/drop:end': DropSignalArg\n  }\n}\n\ndeclare module '@interactjs/core/InteractStatic' {\n  interface InteractStatic {\n    dynamicDrop: (this: InteractStatic, newValue?: boolean) => boolean | this\n  }\n}\n\ninterface DropSignalArg {\n  interaction: Interaction<'drag'>\n  dragEvent: DragEvent\n}\n\nexport interface ActiveDrop {\n  dropzone: Interactable\n  element: Element\n  rect: Rect\n}\n\nexport interface DropState {\n  cur: {\n    // the dropzone a drag target might be dropped into\n    dropzone: Interactable\n    // the element at the time of checking\n    element: Element\n  }\n  prev: {\n    // the dropzone that was recently dragged away from\n    dropzone: Interactable\n    // the element at the time of checking\n    element: Element\n  }\n  // wheather the potential drop was rejected from a listener\n  rejected: boolean\n  // the drop events related to the current drag event\n  events: FiredDropEvents\n  activeDrops: ActiveDrop[]\n}\n\nfunction install (scope: Scope) {\n  const {\n    actions,\n    /** @lends module:interact */\n    interactStatic: interact,\n    /** @lends Interactable */\n    Interactable,\n    defaults,\n  } = scope\n\n  scope.usePlugin(drag)\n\n  /**\n   *\n   * ```js\n   * interact('.drop').dropzone({\n   *   accept: '.can-drop' || document.getElementById('single-drop'),\n   *   overlap: 'pointer' || 'center' || zeroToOne\n   * }\n   * ```\n   *\n   * Returns or sets whether draggables can be dropped onto this target to\n   * trigger drop events\n   *\n   * Dropzones can receive the following events:\n   *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\n   *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\n   *  - `dragmove` when a draggable that has entered the dropzone is moved\n   *  - `drop` when a draggable is dropped into this dropzone\n   *\n   * Use the `accept` option to allow only elements that match the given CSS\n   * selector or element. The value can be:\n   *\n   *  - **an Element** - only that element can be dropped into this dropzone.\n   *  - **a string**, - the element being dragged must match it as a CSS selector.\n   *  - **`null`** - accept options is cleared - it accepts any element.\n   *\n   * Use the `overlap` option to set how drops are checked for. The allowed\n   * values are:\n   *\n   *   - `'pointer'`, the pointer must be over the dropzone (default)\n   *   - `'center'`, the draggable element's center must be over the dropzone\n   *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\n   *   e.g. `0.5` for drop to happen when half of the area of the draggable is\n   *   over the dropzone\n   *\n   * Use the `checker` option to specify a function to check if a dragged element\n   * is over this Interactable.\n   *\n   * @param {boolean | object | null} [options] The new options to be set.\n   * @return {object | Interactable} The current setting or this Interactable\n   */\n  Interactable.prototype.dropzone = function (this: Interactable, options?: DropzoneOptions | boolean) {\n    return dropzoneMethod(this, options)\n  } as Interactable['dropzone']\n\n  /**\n   * ```js\n   * interact(target)\n   * .dropChecker(function(dragEvent,         // related dragmove or dragend event\n   *                       event,             // TouchEvent/PointerEvent/MouseEvent\n   *                       dropped,           // bool result of the default checker\n   *                       dropzone,          // dropzone Interactable\n   *                       dropElement,       // dropzone elemnt\n   *                       draggable,         // draggable Interactable\n   *                       draggableElement) {// draggable element\n   *\n   *   return dropped && event.target.hasAttribute('allow-drop')\n   * }\n   * ```\n   */\n  Interactable.prototype.dropCheck = function (\n    this: Interactable,\n    dragEvent,\n    event,\n    draggable,\n    draggableElement,\n    dropElement,\n    rect,\n  ) {\n    return dropCheckMethod(this, dragEvent, event, draggable, draggableElement, dropElement, rect)\n  }\n\n  /**\n   * Returns or sets whether the dimensions of dropzone elements are calculated\n   * on every dragmove or only on dragstart for the default dropChecker\n   *\n   * @param {boolean} [newValue] True to check on each move. False to check only\n   * before start\n   * @return {boolean | interact} The current setting or interact\n   */\n  interact.dynamicDrop = function (newValue?: boolean) {\n    if (is.bool(newValue)) {\n      // if (dragging && scope.dynamicDrop !== newValue && !newValue) {\n      //  calcRects(dropzones)\n      // }\n\n      scope.dynamicDrop = newValue\n\n      return interact\n    }\n    return scope.dynamicDrop\n  }\n\n  extend(actions.phaselessTypes, {\n    dragenter: true,\n    dragleave: true,\n    dropactivate: true,\n    dropdeactivate: true,\n    dropmove: true,\n    drop: true,\n  })\n  actions.methodDict.drop = 'dropzone'\n\n  scope.dynamicDrop = false\n\n  defaults.actions.drop = drop.defaults\n}\n\nfunction collectDrops ({ interactables }: Scope, draggableElement: Element) {\n  const drops: ActiveDrop[] = []\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (const dropzone of interactables.list) {\n    if (!dropzone.options.drop.enabled) {\n      continue\n    }\n\n    const accept = dropzone.options.drop.accept\n\n    // test the draggable draggableElement against the dropzone's accept setting\n    if (\n      (is.element(accept) && accept !== draggableElement) ||\n      (is.string(accept) && !domUtils.matchesSelector(draggableElement, accept)) ||\n      (is.func(accept) && !accept({ dropzone, draggableElement }))\n    ) {\n      continue\n    }\n\n    // query for new elements if necessary\n    const dropElements = (is.string(dropzone.target)\n      ? dropzone._context.querySelectorAll(dropzone.target)\n      : is.array(dropzone.target)\n        ? dropzone.target\n        : [dropzone.target]) as Element[]\n\n    for (const dropzoneElement of dropElements) {\n      if (dropzoneElement !== draggableElement) {\n        drops.push({\n          dropzone,\n          element: dropzoneElement,\n          rect: dropzone.getRect(dropzoneElement),\n        })\n      }\n    }\n  }\n\n  return drops\n}\n\nfunction fireActivationEvents (activeDrops: ActiveDrop[], event: DropEvent) {\n  // loop through all active dropzones and trigger event\n  for (const { dropzone, element } of activeDrops.slice()) {\n    event.dropzone = dropzone\n\n    // set current element as event target\n    event.target = element\n    dropzone.fire(event)\n    event.propagationStopped = event.immediatePropagationStopped = false\n  }\n}\n\n// return a new array of possible drops. getActiveDrops should always be\n// called when a drag has just started or a drag event happens while\n// dynamicDrop is true\nfunction getActiveDrops (scope: Scope, dragElement: Element) {\n  // get dropzones and their elements that could receive the draggable\n  const activeDrops = collectDrops(scope, dragElement)\n\n  for (const activeDrop of activeDrops) {\n    activeDrop.rect = activeDrop.dropzone.getRect(activeDrop.element)\n  }\n\n  return activeDrops\n}\n\nfunction getDrop (\n  { dropState, interactable: draggable, element: dragElement }: Partial<Interaction>,\n  dragEvent,\n  pointerEvent,\n) {\n  const validDrops = []\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (const { dropzone, element: dropzoneElement, rect } of dropState.activeDrops) {\n    validDrops.push(\n      dropzone.dropCheck(dragEvent, pointerEvent, draggable, dragElement, dropzoneElement, rect)\n        ? dropzoneElement\n        : null,\n    )\n  }\n\n  // get the most appropriate dropzone based on DOM depth and order\n  const dropIndex = domUtils.indexOfDeepestElement(validDrops)\n\n  return dropState.activeDrops[dropIndex] || null\n}\n\nfunction getDropEvents (interaction: Interaction, _pointerEvent, dragEvent: DragEvent) {\n  const { dropState } = interaction\n  const dropEvents = {\n    enter: null,\n    leave: null,\n    activate: null,\n    deactivate: null,\n    move: null,\n    drop: null,\n  }\n\n  if (dragEvent.type === 'dragstart') {\n    dropEvents.activate = new DropEvent(dropState, dragEvent, 'dropactivate')\n\n    dropEvents.activate.target = null\n    dropEvents.activate.dropzone = null\n  }\n  if (dragEvent.type === 'dragend') {\n    dropEvents.deactivate = new DropEvent(dropState, dragEvent, 'dropdeactivate')\n\n    dropEvents.deactivate.target = null\n    dropEvents.deactivate.dropzone = null\n  }\n\n  if (dropState.rejected) {\n    return dropEvents\n  }\n\n  if (dropState.cur.element !== dropState.prev.element) {\n    // if there was a previous dropzone, create a dragleave event\n    if (dropState.prev.dropzone) {\n      dropEvents.leave = new DropEvent(dropState, dragEvent, 'dragleave')\n\n      dragEvent.dragLeave = dropEvents.leave.target = dropState.prev.element\n      dragEvent.prevDropzone = dropEvents.leave.dropzone = dropState.prev.dropzone\n    }\n    // if dropzone is not null, create a dragenter event\n    if (dropState.cur.dropzone) {\n      dropEvents.enter = new DropEvent(dropState, dragEvent, 'dragenter')\n\n      dragEvent.dragEnter = dropState.cur.element\n      dragEvent.dropzone = dropState.cur.dropzone\n    }\n  }\n\n  if (dragEvent.type === 'dragend' && dropState.cur.dropzone) {\n    dropEvents.drop = new DropEvent(dropState, dragEvent, 'drop')\n\n    dragEvent.dropzone = dropState.cur.dropzone\n    dragEvent.relatedTarget = dropState.cur.element\n  }\n  if (dragEvent.type === 'dragmove' && dropState.cur.dropzone) {\n    dropEvents.move = new DropEvent(dropState, dragEvent, 'dropmove')\n\n    dropEvents.move.dragmove = dragEvent\n    dragEvent.dropzone = dropState.cur.dropzone\n  }\n\n  return dropEvents\n}\n\ntype FiredDropEvents = Partial<\nRecord<'leave' | 'enter' | 'move' | 'drop' | 'activate' | 'deactivate', DropEvent>\n>\n\nfunction fireDropEvents (interaction: Interaction, events: FiredDropEvents) {\n  const { dropState } = interaction\n  const { activeDrops, cur, prev } = dropState\n\n  if (events.leave) {\n    prev.dropzone.fire(events.leave)\n  }\n  if (events.enter) {\n    cur.dropzone.fire(events.enter)\n  }\n  if (events.move) {\n    cur.dropzone.fire(events.move)\n  }\n  if (events.drop) {\n    cur.dropzone.fire(events.drop)\n  }\n\n  if (events.deactivate) {\n    fireActivationEvents(activeDrops, events.deactivate)\n  }\n\n  dropState.prev.dropzone = cur.dropzone\n  dropState.prev.element = cur.element\n}\n\nfunction onEventCreated ({ interaction, iEvent, event }: DoPhaseArg<'drag', EventPhase>, scope: Scope) {\n  if (iEvent.type !== 'dragmove' && iEvent.type !== 'dragend') {\n    return\n  }\n\n  const { dropState } = interaction\n\n  if (scope.dynamicDrop) {\n    dropState.activeDrops = getActiveDrops(scope, interaction.element)\n  }\n\n  const dragEvent = iEvent\n  const dropResult = getDrop(interaction, dragEvent, event)\n\n  // update rejected status\n  dropState.rejected =\n    dropState.rejected &&\n    !!dropResult &&\n    dropResult.dropzone === dropState.cur.dropzone &&\n    dropResult.element === dropState.cur.element\n\n  dropState.cur.dropzone = dropResult && dropResult.dropzone\n  dropState.cur.element = dropResult && dropResult.element\n\n  dropState.events = getDropEvents(interaction, event, dragEvent)\n}\n\nfunction dropzoneMethod(interactable: Interactable): DropzoneOptions\nfunction dropzoneMethod(interactable: Interactable, options: DropzoneOptions | boolean): Interactable\nfunction dropzoneMethod (interactable: Interactable, options?: DropzoneOptions | boolean) {\n  if (is.object(options)) {\n    interactable.options.drop.enabled = options.enabled !== false\n\n    if (options.listeners) {\n      const normalized = normalizeListeners(options.listeners)\n      // rename 'drop' to '' as it will be prefixed with 'drop'\n      const corrected = Object.keys(normalized).reduce((acc, type) => {\n        const correctedType = /^(enter|leave)/.test(type)\n          ? `drag${type}`\n          : /^(activate|deactivate|move)/.test(type)\n            ? `drop${type}`\n            : type\n\n        acc[correctedType] = normalized[type]\n\n        return acc\n      }, {})\n\n      interactable.off(interactable.options.drop.listeners)\n      interactable.on(corrected)\n      interactable.options.drop.listeners = corrected\n    }\n\n    if (is.func(options.ondrop)) {\n      interactable.on('drop', options.ondrop)\n    }\n    if (is.func(options.ondropactivate)) {\n      interactable.on('dropactivate', options.ondropactivate)\n    }\n    if (is.func(options.ondropdeactivate)) {\n      interactable.on('dropdeactivate', options.ondropdeactivate)\n    }\n    if (is.func(options.ondragenter)) {\n      interactable.on('dragenter', options.ondragenter)\n    }\n    if (is.func(options.ondragleave)) {\n      interactable.on('dragleave', options.ondragleave)\n    }\n    if (is.func(options.ondropmove)) {\n      interactable.on('dropmove', options.ondropmove)\n    }\n\n    if (/^(pointer|center)$/.test(options.overlap as string)) {\n      interactable.options.drop.overlap = options.overlap\n    } else if (is.number(options.overlap)) {\n      interactable.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0)\n    }\n    if ('accept' in options) {\n      interactable.options.drop.accept = options.accept\n    }\n    if ('checker' in options) {\n      interactable.options.drop.checker = options.checker\n    }\n\n    return interactable\n  }\n\n  if (is.bool(options)) {\n    interactable.options.drop.enabled = options\n\n    return interactable\n  }\n\n  return interactable.options.drop\n}\n\nfunction dropCheckMethod (\n  interactable: Interactable,\n  dragEvent: InteractEvent,\n  event: PointerEventType,\n  draggable: Interactable,\n  draggableElement: Element,\n  dropElement: Element,\n  rect: any,\n) {\n  let dropped = false\n\n  // if the dropzone has no rect (eg. display: none)\n  // call the custom dropChecker or just return false\n  if (!(rect = rect || interactable.getRect(dropElement))) {\n    return interactable.options.drop.checker\n      ? interactable.options.drop.checker(\n        dragEvent,\n        event,\n        dropped,\n        interactable,\n        dropElement,\n        draggable,\n        draggableElement,\n      )\n      : false\n  }\n\n  const dropOverlap = interactable.options.drop.overlap\n\n  if (dropOverlap === 'pointer') {\n    const origin = getOriginXY(draggable, draggableElement, 'drag')\n    const page = pointerUtils.getPageXY(dragEvent)\n\n    page.x += origin.x\n    page.y += origin.y\n\n    const horizontal = page.x > rect.left && page.x < rect.right\n    const vertical = page.y > rect.top && page.y < rect.bottom\n\n    dropped = horizontal && vertical\n  }\n\n  const dragRect = draggable.getRect(draggableElement)\n\n  if (dragRect && dropOverlap === 'center') {\n    const cx = dragRect.left + dragRect.width / 2\n    const cy = dragRect.top + dragRect.height / 2\n\n    dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom\n  }\n\n  if (dragRect && is.number(dropOverlap)) {\n    const overlapArea =\n      Math.max(0, Math.min(rect.right, dragRect.right) - Math.max(rect.left, dragRect.left)) *\n      Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top, dragRect.top))\n\n    const overlapRatio = overlapArea / (dragRect.width * dragRect.height)\n\n    dropped = overlapRatio >= dropOverlap\n  }\n\n  if (interactable.options.drop.checker) {\n    dropped = interactable.options.drop.checker(\n      dragEvent,\n      event,\n      dropped,\n      interactable,\n      dropElement,\n      draggable,\n      draggableElement,\n    )\n  }\n\n  return dropped\n}\n\nconst drop: Plugin = {\n  id: 'actions/drop',\n  install,\n  listeners: {\n    'interactions:before-action-start': ({ interaction }) => {\n      if (interaction.prepared.name !== 'drag') {\n        return\n      }\n\n      interaction.dropState = {\n        cur: {\n          dropzone: null,\n          element: null,\n        },\n        prev: {\n          dropzone: null,\n          element: null,\n        },\n        rejected: null,\n        events: null,\n        activeDrops: [],\n      }\n    },\n\n    'interactions:after-action-start': (\n      { interaction, event, iEvent: dragEvent }: DoPhaseArg<'drag', EventPhase>,\n      scope,\n    ) => {\n      if (interaction.prepared.name !== 'drag') {\n        return\n      }\n\n      const { dropState } = interaction\n\n      // reset active dropzones\n      dropState.activeDrops = null\n      dropState.events = null\n      dropState.activeDrops = getActiveDrops(scope, interaction.element)\n      dropState.events = getDropEvents(interaction, event, dragEvent)\n\n      if (dropState.events.activate) {\n        fireActivationEvents(dropState.activeDrops, dropState.events.activate)\n        scope.fire('actions/drop:start', { interaction, dragEvent })\n      }\n    },\n\n    'interactions:action-move': onEventCreated,\n\n    'interactions:after-action-move': (\n      { interaction, iEvent: dragEvent }: DoPhaseArg<'drag', EventPhase>,\n      scope,\n    ) => {\n      if (interaction.prepared.name !== 'drag') {\n        return\n      }\n\n      fireDropEvents(interaction, interaction.dropState.events)\n\n      scope.fire('actions/drop:move', { interaction, dragEvent })\n      interaction.dropState.events = {}\n    },\n\n    'interactions:action-end': (arg: DoPhaseArg<'drag', EventPhase>, scope) => {\n      if (arg.interaction.prepared.name !== 'drag') {\n        return\n      }\n\n      const { interaction, iEvent: dragEvent } = arg\n\n      onEventCreated(arg, scope)\n      fireDropEvents(interaction, interaction.dropState.events)\n      scope.fire('actions/drop:end', { interaction, dragEvent })\n    },\n\n    'interactions:stop': ({ interaction }) => {\n      if (interaction.prepared.name !== 'drag') {\n        return\n      }\n\n      const { dropState } = interaction\n\n      if (dropState) {\n        dropState.activeDrops = null\n        dropState.events = null\n        dropState.cur.dropzone = null\n        dropState.cur.element = null\n        dropState.prev.dropzone = null\n        dropState.prev.element = null\n        dropState.rejected = false\n      }\n    },\n  },\n  getActiveDrops,\n  getDrop,\n  getDropEvents,\n  fireDropEvents,\n  defaults: {\n    enabled: false,\n    accept: null,\n    overlap: 'pointer',\n  } as DropzoneOptions,\n}\n\nexport default drop\n","import type { InteractEvent, EventPhase } from '@interactjs/core/InteractEvent'\nimport type { Interaction, DoPhaseArg } from '@interactjs/core/Interaction'\nimport type { Options } from '@interactjs/core/options'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type { ActionMethod, GesturableOptions, Rect, PointerType } from '@interactjs/types/index'\nimport is from '@interactjs/utils/is'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nexport type GesturableMethod = ActionMethod<GesturableOptions>\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    gesture?: {\n      angle: number // angle from first to second touch\n      distance: number\n      scale: number // gesture.distance / gesture.startDistance\n      startAngle: number // angle of line joining two touches\n      startDistance: number // distance between two touches of touchStart\n    }\n  }\n}\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    gesturable: GesturableMethod\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface ActionDefaults {\n    gesture: GesturableOptions\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface ActionMap {\n    gesture?: typeof gesture\n  }\n}\n\nexport interface GestureEvent extends InteractEvent<'gesture'> {\n  distance: number\n  angle: number\n  da: number // angle change\n  scale: number // ratio of distance start to current event\n  ds: number // scale change\n  box: Rect // enclosing box of all points\n  touches: PointerType[]\n}\n\nexport interface GestureSignalArg extends DoPhaseArg<'gesture', EventPhase> {\n  iEvent: GestureEvent\n  interaction: Interaction<'gesture'>\n}\n\nfunction install (scope: Scope) {\n  const { actions, Interactable, defaults } = scope\n\n  /**\n   * ```js\n   * interact(element).gesturable({\n   *     onstart: function (event) {},\n   *     onmove : function (event) {},\n   *     onend  : function (event) {},\n   *\n   *     // limit multiple gestures.\n   *     // See the explanation in {@link Interactable.draggable} example\n   *     max: Infinity,\n   *     maxPerElement: 1,\n   * })\n   *\n   * var isGestureable = interact(element).gesturable()\n   * ```\n   *\n   * Gets or sets whether multitouch gestures can be performed on the target\n   *\n   * @param {boolean | object} [options] true/false or An object with event\n   * listeners to be fired on gesture events (makes the Interactable gesturable)\n   * @return {boolean | Interactable} A boolean indicating if this can be the\n   * target of gesture events, or this Interactable\n   */\n  Interactable.prototype.gesturable = function (\n    this: InstanceType<typeof Interactable>,\n    options: GesturableOptions | boolean,\n  ) {\n    if (is.object(options)) {\n      this.options.gesture.enabled = options.enabled !== false\n      this.setPerAction('gesture', options)\n      this.setOnEvents('gesture', options)\n\n      return this\n    }\n\n    if (is.bool(options)) {\n      this.options.gesture.enabled = options\n\n      return this\n    }\n\n    return this.options.gesture as Options\n  } as GesturableMethod\n\n  actions.map.gesture = gesture\n  actions.methodDict.gesture = 'gesturable'\n\n  defaults.actions.gesture = gesture.defaults\n}\n\nfunction updateGestureProps ({ interaction, iEvent, phase }: GestureSignalArg) {\n  if (interaction.prepared.name !== 'gesture') return\n\n  const pointers = interaction.pointers.map((p) => p.pointer)\n  const starting = phase === 'start'\n  const ending = phase === 'end'\n  const deltaSource = interaction.interactable.options.deltaSource\n\n  iEvent.touches = [pointers[0], pointers[1]]\n\n  if (starting) {\n    iEvent.distance = pointerUtils.touchDistance(pointers, deltaSource)\n    iEvent.box = pointerUtils.touchBBox(pointers)\n    iEvent.scale = 1\n    iEvent.ds = 0\n    iEvent.angle = pointerUtils.touchAngle(pointers, deltaSource)\n    iEvent.da = 0\n\n    interaction.gesture.startDistance = iEvent.distance\n    interaction.gesture.startAngle = iEvent.angle\n  } else if (ending) {\n    const prevEvent = interaction.prevEvent as GestureEvent\n\n    iEvent.distance = prevEvent.distance\n    iEvent.box = prevEvent.box\n    iEvent.scale = prevEvent.scale\n    iEvent.ds = 0\n    iEvent.angle = prevEvent.angle\n    iEvent.da = 0\n  } else {\n    iEvent.distance = pointerUtils.touchDistance(pointers, deltaSource)\n    iEvent.box = pointerUtils.touchBBox(pointers)\n    iEvent.scale = iEvent.distance / interaction.gesture.startDistance\n    iEvent.angle = pointerUtils.touchAngle(pointers, deltaSource)\n\n    iEvent.ds = iEvent.scale - interaction.gesture.scale\n    iEvent.da = iEvent.angle - interaction.gesture.angle\n  }\n\n  interaction.gesture.distance = iEvent.distance\n  interaction.gesture.angle = iEvent.angle\n\n  if (is.number(iEvent.scale) && iEvent.scale !== Infinity && !isNaN(iEvent.scale)) {\n    interaction.gesture.scale = iEvent.scale\n  }\n}\n\nconst gesture: Plugin = {\n  id: 'actions/gesture',\n  before: ['actions/drag', 'actions/resize'],\n  install,\n  listeners: {\n    'interactions:action-start': updateGestureProps,\n    'interactions:action-move': updateGestureProps,\n    'interactions:action-end': updateGestureProps,\n\n    'interactions:new': ({ interaction }) => {\n      interaction.gesture = {\n        angle: 0,\n        distance: 0,\n        scale: 1,\n        startAngle: 0,\n        startDistance: 0,\n      }\n    },\n\n    'auto-start:check': (arg) => {\n      if (arg.interaction.pointers.length < 2) {\n        return undefined\n      }\n\n      const gestureOptions = arg.interactable.options.gesture\n\n      if (!(gestureOptions && gestureOptions.enabled)) {\n        return undefined\n      }\n\n      arg.action = { name: 'gesture' }\n\n      return false\n    },\n  },\n\n  defaults: {},\n\n  getCursor () {\n    return ''\n  },\n}\n\nexport default gesture\n","import type { EventPhase, InteractEvent } from '@interactjs/core/InteractEvent'\nimport type { Interactable } from '@interactjs/core/Interactable'\nimport type { ActionProps, Interaction } from '@interactjs/core/Interaction'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type {\n  ActionMethod,\n  ResizableOptions,\n  FullRect,\n  OrBoolean,\n  Point,\n  Rect,\n} from '@interactjs/types/index'\nimport * as dom from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\n\nexport type EdgeName = 'top' | 'left' | 'bottom' | 'right'\n\nexport type ResizableMethod = ActionMethod<ResizableOptions>\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    resizable: ResizableMethod\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    resizeAxes: 'x' | 'y' | 'xy'\n    resizeStartAspectRatio: number\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface ActionDefaults {\n    resize: ResizableOptions\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface ActionMap {\n    resize?: typeof resize\n  }\n}\n\nexport interface ResizeEvent<P extends EventPhase = EventPhase> extends InteractEvent<'resize', P> {\n  deltaRect?: FullRect\n  edges?: ActionProps['edges']\n}\n\nfunction install (scope: Scope) {\n  const {\n    actions,\n    browser,\n    /** @lends Interactable */\n    Interactable, // tslint:disable-line no-shadowed-variable\n    defaults,\n  } = scope\n\n  // Less Precision with touch input\n\n  resize.cursors = initCursors(browser)\n  resize.defaultMargin = browser.supportsTouch || browser.supportsPointerEvent ? 20 : 10\n\n  /**\n   * ```js\n   * interact(element).resizable({\n   *   onstart: function (event) {},\n   *   onmove : function (event) {},\n   *   onend  : function (event) {},\n   *\n   *   edges: {\n   *     top   : true,       // Use pointer coords to check for resize.\n   *     left  : false,      // Disable resizing from left edge.\n   *     bottom: '.resize-s',// Resize if pointer target matches selector\n   *     right : handleEl    // Resize if pointer target is the given Element\n   *   },\n   *\n   *     // Width and height can be adjusted independently. When `true`, width and\n   *     // height are adjusted at a 1:1 ratio.\n   *     square: false,\n   *\n   *     // Width and height can be adjusted independently. When `true`, width and\n   *     // height maintain the aspect ratio they had when resizing started.\n   *     preserveAspectRatio: false,\n   *\n   *   // a value of 'none' will limit the resize rect to a minimum of 0x0\n   *   // 'negate' will allow the rect to have negative width/height\n   *   // 'reposition' will keep the width/height positive by swapping\n   *   // the top and bottom edges and/or swapping the left and right edges\n   *   invert: 'none' || 'negate' || 'reposition'\n   *\n   *   // limit multiple resizes.\n   *   // See the explanation in the {@link Interactable.draggable} example\n   *   max: Infinity,\n   *   maxPerElement: 1,\n   * })\n   *\n   * var isResizeable = interact(element).resizable()\n   * ```\n   *\n   * Gets or sets whether resize actions can be performed on the target\n   *\n   * @param {boolean | object} [options] true/false or An object with event\n   * listeners to be fired on resize events (object makes the Interactable\n   * resizable)\n   * @return {boolean | Interactable} A boolean indicating if this can be the\n   * target of resize elements, or this Interactable\n   */\n  Interactable.prototype.resizable = function (this: Interactable, options: ResizableOptions | boolean) {\n    return resizable(this, options, scope)\n  } as ResizableMethod\n\n  actions.map.resize = resize\n  actions.methodDict.resize = 'resizable'\n\n  defaults.actions.resize = resize.defaults\n}\n\nfunction resizeChecker (arg) {\n  const { interaction, interactable, element, rect, buttons } = arg\n\n  if (!rect) {\n    return undefined\n  }\n\n  const page = extend({}, interaction.coords.cur.page)\n  const resizeOptions = interactable.options.resize\n\n  if (\n    !(resizeOptions && resizeOptions.enabled) ||\n    // check mouseButton setting if the pointer is down\n    (interaction.pointerIsDown &&\n      /mouse|pointer/.test(interaction.pointerType) &&\n      (buttons & resizeOptions.mouseButtons) === 0)\n  ) {\n    return undefined\n  }\n\n  // if using resize.edges\n  if (is.object(resizeOptions.edges)) {\n    const resizeEdges = {\n      left: false,\n      right: false,\n      top: false,\n      bottom: false,\n    }\n\n    for (const edge in resizeEdges) {\n      resizeEdges[edge] = checkResizeEdge(\n        edge,\n        resizeOptions.edges[edge],\n        page,\n        interaction._latestPointer.eventTarget,\n        element,\n        rect,\n        resizeOptions.margin || resize.defaultMargin,\n      )\n    }\n\n    resizeEdges.left = resizeEdges.left && !resizeEdges.right\n    resizeEdges.top = resizeEdges.top && !resizeEdges.bottom\n\n    if (resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom) {\n      arg.action = {\n        name: 'resize',\n        edges: resizeEdges,\n      }\n    }\n  } else {\n    const right = resizeOptions.axis !== 'y' && page.x > rect.right - resize.defaultMargin\n    const bottom = resizeOptions.axis !== 'x' && page.y > rect.bottom - resize.defaultMargin\n\n    if (right || bottom) {\n      arg.action = {\n        name: 'resize',\n        axes: (right ? 'x' : '') + (bottom ? 'y' : ''),\n      }\n    }\n  }\n\n  return arg.action ? false : undefined\n}\n\nfunction resizable (interactable: Interactable, options: OrBoolean<ResizableOptions> | boolean, scope: Scope) {\n  if (is.object(options)) {\n    interactable.options.resize.enabled = options.enabled !== false\n    interactable.setPerAction('resize', options)\n    interactable.setOnEvents('resize', options)\n\n    if (is.string(options.axis) && /^x$|^y$|^xy$/.test(options.axis)) {\n      interactable.options.resize.axis = options.axis\n    } else if (options.axis === null) {\n      interactable.options.resize.axis = scope.defaults.actions.resize.axis\n    }\n\n    if (is.bool(options.preserveAspectRatio)) {\n      interactable.options.resize.preserveAspectRatio = options.preserveAspectRatio\n    } else if (is.bool(options.square)) {\n      interactable.options.resize.square = options.square\n    }\n\n    return interactable\n  }\n  if (is.bool(options)) {\n    interactable.options.resize.enabled = options\n\n    return interactable\n  }\n  return interactable.options.resize\n}\n\nfunction checkResizeEdge (\n  name: string,\n  value: any,\n  page: Point,\n  element: Node,\n  interactableElement: Element,\n  rect: Rect,\n  margin: number,\n) {\n  // false, '', undefined, null\n  if (!value) {\n    return false\n  }\n\n  // true value, use pointer coords and element rect\n  if (value === true) {\n    // if dimensions are negative, \"switch\" edges\n    const width = is.number(rect.width) ? rect.width : rect.right - rect.left\n    const height = is.number(rect.height) ? rect.height : rect.bottom - rect.top\n\n    // don't use margin greater than half the relevent dimension\n    margin = Math.min(margin, Math.abs((name === 'left' || name === 'right' ? width : height) / 2))\n\n    if (width < 0) {\n      if (name === 'left') {\n        name = 'right'\n      } else if (name === 'right') {\n        name = 'left'\n      }\n    }\n    if (height < 0) {\n      if (name === 'top') {\n        name = 'bottom'\n      } else if (name === 'bottom') {\n        name = 'top'\n      }\n    }\n\n    if (name === 'left') {\n      return page.x < (width >= 0 ? rect.left : rect.right) + margin\n    }\n    if (name === 'top') {\n      return page.y < (height >= 0 ? rect.top : rect.bottom) + margin\n    }\n\n    if (name === 'right') {\n      return page.x > (width >= 0 ? rect.right : rect.left) - margin\n    }\n    if (name === 'bottom') {\n      return page.y > (height >= 0 ? rect.bottom : rect.top) - margin\n    }\n  }\n\n  // the remaining checks require an element\n  if (!is.element(element)) {\n    return false\n  }\n\n  return is.element(value)\n    ? // the value is an element to use as a resize handle\n    value === element\n    : // otherwise check if element matches value as selector\n    dom.matchesUpTo(element, value, interactableElement)\n}\n\n/* eslint-disable multiline-ternary */\n// eslint-disable-next-line @typescript-eslint/consistent-type-imports\nfunction initCursors (browser: typeof import('@interactjs/utils/browser').default) {\n  return browser.isIe9\n    ? {\n      x: 'e-resize',\n      y: 's-resize',\n      xy: 'se-resize',\n\n      top: 'n-resize',\n      left: 'w-resize',\n      bottom: 's-resize',\n      right: 'e-resize',\n      topleft: 'se-resize',\n      bottomright: 'se-resize',\n      topright: 'ne-resize',\n      bottomleft: 'ne-resize',\n    }\n    : {\n      x: 'ew-resize',\n      y: 'ns-resize',\n      xy: 'nwse-resize',\n\n      top: 'ns-resize',\n      left: 'ew-resize',\n      bottom: 'ns-resize',\n      right: 'ew-resize',\n      topleft: 'nwse-resize',\n      bottomright: 'nwse-resize',\n      topright: 'nesw-resize',\n      bottomleft: 'nesw-resize',\n    }\n}\n/* eslint-enable multiline-ternary */\n\nfunction start ({ iEvent, interaction }: { iEvent: InteractEvent<any, any>, interaction: Interaction }) {\n  if (interaction.prepared.name !== 'resize' || !interaction.prepared.edges) {\n    return\n  }\n\n  const resizeEvent = iEvent as ResizeEvent\n  const rect = interaction.rect\n\n  interaction._rects = {\n    start: extend({}, rect),\n    corrected: extend({}, rect),\n    previous: extend({}, rect),\n    delta: {\n      left: 0,\n      right: 0,\n      width: 0,\n      top: 0,\n      bottom: 0,\n      height: 0,\n    },\n  }\n\n  resizeEvent.edges = interaction.prepared.edges\n  resizeEvent.rect = interaction._rects.corrected\n  resizeEvent.deltaRect = interaction._rects.delta\n}\n\nfunction move ({ iEvent, interaction }: { iEvent: InteractEvent<any, any>, interaction: Interaction }) {\n  if (interaction.prepared.name !== 'resize' || !interaction.prepared.edges) return\n\n  const resizeEvent = iEvent as ResizeEvent\n  const resizeOptions = interaction.interactable.options.resize\n  const invert = resizeOptions.invert\n  const invertible = invert === 'reposition' || invert === 'negate'\n\n  const current = interaction.rect\n  const { start: startRect, corrected, delta: deltaRect, previous } = interaction._rects\n\n  extend(previous, corrected)\n\n  if (invertible) {\n    // if invertible, copy the current rect\n    extend(corrected, current)\n\n    if (invert === 'reposition') {\n      // swap edge values if necessary to keep width/height positive\n      if (corrected.top > corrected.bottom) {\n        const swap = corrected.top\n\n        corrected.top = corrected.bottom\n        corrected.bottom = swap\n      }\n      if (corrected.left > corrected.right) {\n        const swap = corrected.left\n\n        corrected.left = corrected.right\n        corrected.right = swap\n      }\n    }\n  } else {\n    // if not invertible, restrict to minimum of 0x0 rect\n    corrected.top = Math.min(current.top, startRect.bottom)\n    corrected.bottom = Math.max(current.bottom, startRect.top)\n    corrected.left = Math.min(current.left, startRect.right)\n    corrected.right = Math.max(current.right, startRect.left)\n  }\n\n  corrected.width = corrected.right - corrected.left\n  corrected.height = corrected.bottom - corrected.top\n\n  for (const edge in corrected) {\n    deltaRect[edge] = corrected[edge] - previous[edge]\n  }\n\n  resizeEvent.edges = interaction.prepared.edges\n  resizeEvent.rect = corrected\n  resizeEvent.deltaRect = deltaRect\n}\n\nfunction end ({ iEvent, interaction }: { iEvent: InteractEvent<any, any>, interaction: Interaction }) {\n  if (interaction.prepared.name !== 'resize' || !interaction.prepared.edges) return\n\n  const resizeEvent = iEvent as ResizeEvent\n\n  resizeEvent.edges = interaction.prepared.edges\n  resizeEvent.rect = interaction._rects.corrected\n  resizeEvent.deltaRect = interaction._rects.delta\n}\n\nfunction updateEventAxes ({\n  iEvent,\n  interaction,\n}: {\n  iEvent: InteractEvent<any, any>\n  interaction: Interaction\n}) {\n  if (interaction.prepared.name !== 'resize' || !interaction.resizeAxes) return\n\n  const options = interaction.interactable.options\n  const resizeEvent = iEvent as ResizeEvent\n\n  if (options.resize.square) {\n    if (interaction.resizeAxes === 'y') {\n      resizeEvent.delta.x = resizeEvent.delta.y\n    } else {\n      resizeEvent.delta.y = resizeEvent.delta.x\n    }\n    resizeEvent.axes = 'xy'\n  } else {\n    resizeEvent.axes = interaction.resizeAxes\n\n    if (interaction.resizeAxes === 'x') {\n      resizeEvent.delta.y = 0\n    } else if (interaction.resizeAxes === 'y') {\n      resizeEvent.delta.x = 0\n    }\n  }\n}\n\nconst resize: Plugin = {\n  id: 'actions/resize',\n  before: ['actions/drag'],\n  install,\n  listeners: {\n    'interactions:new': ({ interaction }) => {\n      interaction.resizeAxes = 'xy'\n    },\n\n    'interactions:action-start': (arg) => {\n      start(arg)\n      updateEventAxes(arg)\n    },\n    'interactions:action-move': (arg) => {\n      move(arg)\n      updateEventAxes(arg)\n    },\n    'interactions:action-end': end,\n    'auto-start:check': resizeChecker,\n  },\n\n  defaults: {\n    square: false,\n    preserveAspectRatio: false,\n    axis: 'xy',\n\n    // use default margin\n    margin: NaN,\n\n    // object with props left, right, top, bottom which are\n    // true/false values to resize when the pointer is over that edge,\n    // CSS selectors to match the handles for each direction\n    // or the Elements for each handle\n    edges: null,\n\n    // a value of 'none' will limit the resize rect to a minimum of 0x0\n    // 'negate' will alow the rect to have negative width/height\n    // 'reposition' will keep the width/height positive by swapping\n    // the top and bottom edges and/or swapping the left and right edges\n    invert: 'none',\n  } as ResizableOptions,\n\n  cursors: null as ReturnType<typeof initCursors>,\n\n  getCursor ({ edges, axis, name }: ActionProps) {\n    const cursors = resize.cursors\n    let result: string = null\n\n    if (axis) {\n      result = cursors[name + axis]\n    } else if (edges) {\n      let cursorKey = ''\n\n      for (const edge of ['top', 'bottom', 'left', 'right']) {\n        if (edges[edge]) {\n          cursorKey += edge\n        }\n      }\n\n      result = cursors[cursorKey]\n    }\n\n    return result\n  },\n\n  defaultMargin: null as number,\n}\n\nexport default resize\n","import type { Scope } from '@interactjs/core/scope'\n\nimport drag from './drag/plugin'\nimport drop from './drop/plugin'\nimport gesture from './gesture/plugin'\nimport resize from './resize/plugin'\n\nexport default {\n  id: 'actions',\n  install (scope: Scope) {\n    scope.usePlugin(gesture)\n    scope.usePlugin(resize)\n    scope.usePlugin(drag)\n    scope.usePlugin(drop)\n  },\n}\n","let lastTime = 0\nlet request: typeof requestAnimationFrame\nlet cancel: typeof cancelAnimationFrame\n\nfunction init (global: Window | typeof globalThis) {\n  request = global.requestAnimationFrame\n  cancel = global.cancelAnimationFrame\n\n  if (!request) {\n    const vendors = ['ms', 'moz', 'webkit', 'o']\n\n    for (const vendor of vendors) {\n      request = global[`${vendor}RequestAnimationFrame` as 'requestAnimationFrame']\n      cancel =\n        global[`${vendor}CancelAnimationFrame` as 'cancelAnimationFrame'] ||\n        global[`${vendor}CancelRequestAnimationFrame` as 'cancelAnimationFrame']\n    }\n  }\n\n  request = request && request.bind(global)\n  cancel = cancel && cancel.bind(global)\n\n  if (!request) {\n    request = (callback) => {\n      const currTime = Date.now()\n      const timeToCall = Math.max(0, 16 - (currTime - lastTime))\n      const token = global.setTimeout(() => {\n        // eslint-disable-next-line node/no-callback-literal\n        callback(currTime + timeToCall)\n      }, timeToCall)\n\n      lastTime = currTime + timeToCall\n      return token as any\n    }\n\n    cancel = (token) => clearTimeout(token)\n  }\n}\n\nexport default {\n  request: (callback: FrameRequestCallback) => request(callback),\n  cancel: (token: number) => cancel(token),\n  init,\n}\n","import type { Interactable } from '@interactjs/core/Interactable'\nimport type Interaction from '@interactjs/core/Interaction'\nimport type { ActionName, Scope, Plugin } from '@interactjs/core/scope'\nimport type { PointerType } from '@interactjs/types/index'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport is from '@interactjs/utils/is'\nimport raf from '@interactjs/utils/raf'\nimport { getStringOptionResult } from '@interactjs/utils/rect'\nimport { getWindow } from '@interactjs/utils/window'\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    autoScroll: typeof autoScroll\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    autoScroll?: typeof autoScroll\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface PerActionDefaults {\n    autoScroll?: AutoScrollOptions\n  }\n}\n\nexport interface AutoScrollOptions {\n  container?: Window | HTMLElement\n  margin?: number\n  distance?: number\n  interval?: number\n  speed?: number\n  enabled?: boolean\n}\n\nfunction install (scope: Scope) {\n  const { defaults, actions } = scope\n\n  scope.autoScroll = autoScroll\n  autoScroll.now = () => scope.now()\n\n  actions.phaselessTypes.autoscroll = true\n  defaults.perAction.autoScroll = autoScroll.defaults\n}\n\nconst autoScroll = {\n  defaults: {\n    enabled: false,\n    margin: 60,\n\n    // the item that is scrolled (Window or HTMLElement)\n    container: null as AutoScrollOptions['container'],\n\n    // the scroll speed in pixels per second\n    speed: 300,\n  } as AutoScrollOptions,\n\n  now: Date.now,\n\n  interaction: null as Interaction,\n  i: 0, // the handle returned by window.setInterval\n\n  // Direction each pulse is to scroll in\n  x: 0,\n  y: 0,\n\n  isScrolling: false,\n  prevTime: 0,\n  margin: 0,\n  speed: 0,\n\n  start (interaction: Interaction) {\n    autoScroll.isScrolling = true\n    raf.cancel(autoScroll.i)\n\n    interaction.autoScroll = autoScroll\n    autoScroll.interaction = interaction\n    autoScroll.prevTime = autoScroll.now()\n    autoScroll.i = raf.request(autoScroll.scroll)\n  },\n\n  stop () {\n    autoScroll.isScrolling = false\n    if (autoScroll.interaction) {\n      autoScroll.interaction.autoScroll = null\n    }\n    raf.cancel(autoScroll.i)\n  },\n\n  // scroll the window by the values in scroll.x/y\n  scroll () {\n    const { interaction } = autoScroll\n    const { interactable, element } = interaction\n    const actionName = interaction.prepared.name\n    const options = interactable.options[actionName].autoScroll\n    const container = getContainer(options.container, interactable, element)\n    const now = autoScroll.now()\n    // change in time in seconds\n    const dt = (now - autoScroll.prevTime) / 1000\n    // displacement\n    const s = options.speed * dt\n\n    if (s >= 1) {\n      const scrollBy = {\n        x: autoScroll.x * s,\n        y: autoScroll.y * s,\n      }\n\n      if (scrollBy.x || scrollBy.y) {\n        const prevScroll = getScroll(container)\n\n        if (is.window(container)) {\n          container.scrollBy(scrollBy.x, scrollBy.y)\n        } else if (container) {\n          container.scrollLeft += scrollBy.x\n          container.scrollTop += scrollBy.y\n        }\n\n        const curScroll = getScroll(container)\n        const delta = {\n          x: curScroll.x - prevScroll.x,\n          y: curScroll.y - prevScroll.y,\n        }\n\n        if (delta.x || delta.y) {\n          interactable.fire({\n            type: 'autoscroll',\n            target: element,\n            interactable,\n            delta,\n            interaction,\n            container,\n          })\n        }\n      }\n\n      autoScroll.prevTime = now\n    }\n\n    if (autoScroll.isScrolling) {\n      raf.cancel(autoScroll.i)\n      autoScroll.i = raf.request(autoScroll.scroll)\n    }\n  },\n  check (interactable: Interactable, actionName: ActionName) {\n    const options = interactable.options\n\n    return options[actionName].autoScroll?.enabled\n  },\n  onInteractionMove<T extends ActionName> ({\n    interaction,\n    pointer,\n  }: {\n    interaction: Interaction<T>\n    pointer: PointerType\n  }) {\n    if (\n      !(interaction.interacting() && autoScroll.check(interaction.interactable, interaction.prepared.name))\n    ) {\n      return\n    }\n\n    if (interaction.simulation) {\n      autoScroll.x = autoScroll.y = 0\n      return\n    }\n\n    let top: boolean\n    let right: boolean\n    let bottom: boolean\n    let left: boolean\n\n    const { interactable, element } = interaction\n    const actionName = interaction.prepared.name\n    const options = interactable.options[actionName].autoScroll\n    const container = getContainer(options.container, interactable, element)\n\n    if (is.window(container)) {\n      left = pointer.clientX < autoScroll.margin\n      top = pointer.clientY < autoScroll.margin\n      right = pointer.clientX > container.innerWidth - autoScroll.margin\n      bottom = pointer.clientY > container.innerHeight - autoScroll.margin\n    } else {\n      const rect = domUtils.getElementClientRect(container)\n\n      left = pointer.clientX < rect.left + autoScroll.margin\n      top = pointer.clientY < rect.top + autoScroll.margin\n      right = pointer.clientX > rect.right - autoScroll.margin\n      bottom = pointer.clientY > rect.bottom - autoScroll.margin\n    }\n\n    autoScroll.x = right ? 1 : left ? -1 : 0\n    autoScroll.y = bottom ? 1 : top ? -1 : 0\n\n    if (!autoScroll.isScrolling) {\n      // set the autoScroll properties to those of the target\n      autoScroll.margin = options.margin\n      autoScroll.speed = options.speed\n\n      autoScroll.start(interaction)\n    }\n  },\n}\n\nexport function getContainer (value: any, interactable: Interactable, element: Element) {\n  return (\n    (is.string(value) ? getStringOptionResult(value, interactable, element) : value) || getWindow(element)\n  )\n}\n\nexport function getScroll (container: any) {\n  if (is.window(container)) {\n    container = window.document.body\n  }\n\n  return { x: container.scrollLeft, y: container.scrollTop }\n}\n\nexport function getScrollSize (container: any) {\n  if (is.window(container)) {\n    container = window.document.body\n  }\n\n  return { x: container.scrollWidth, y: container.scrollHeight }\n}\n\nexport function getScrollSizeDelta<T extends ActionName> (\n  {\n    interaction,\n    element,\n  }: {\n    interaction: Partial<Interaction<T>>\n    element: Element\n  },\n  func: any,\n) {\n  const scrollOptions = interaction && interaction.interactable.options[interaction.prepared.name].autoScroll\n\n  if (!scrollOptions || !scrollOptions.enabled) {\n    func()\n    return { x: 0, y: 0 }\n  }\n\n  const scrollContainer = getContainer(scrollOptions.container, interaction.interactable, element)\n\n  const prevSize = getScroll(scrollContainer)\n  func()\n  const curSize = getScroll(scrollContainer)\n\n  return {\n    x: curSize.x - prevSize.x,\n    y: curSize.y - prevSize.y,\n  }\n}\n\nconst autoScrollPlugin: Plugin = {\n  id: 'auto-scroll',\n  install,\n  listeners: {\n    'interactions:new': ({ interaction }) => {\n      interaction.autoScroll = null\n    },\n\n    'interactions:destroy': ({ interaction }) => {\n      interaction.autoScroll = null\n      autoScroll.stop()\n      if (autoScroll.interaction) {\n        autoScroll.interaction = null\n      }\n    },\n\n    'interactions:stop': autoScroll.stop,\n\n    'interactions:action-move': (arg: any) => autoScroll.onInteractionMove(arg),\n  },\n}\n\nexport default autoScrollPlugin\n","import type { ActionProps } from '@interactjs/core/Interaction'\nimport type { ActionName } from '@interactjs/core/scope'\n\nimport { window } from './window'\n\nexport function warnOnce<T> (this: T, method: (...args: any[]) => any, message: string) {\n  let warned = false\n\n  return function (this: T) {\n    if (!warned) {\n      ;(window as any).console.warn(message)\n      warned = true\n    }\n\n    return method.apply(this, arguments)\n  }\n}\n\nexport function copyAction<T extends ActionName> (dest: ActionProps<any>, src: ActionProps<T>) {\n  dest.name = src.name\n  dest.axis = src.axis\n  dest.edges = src.edges\n\n  return dest\n}\n\nexport const sign = (n: number) => (n >= 0 ? 1 : -1)\n","import type { Interactable } from '@interactjs/core/Interactable'\nimport type { Interaction, ActionProps } from '@interactjs/core/Interaction'\nimport type { Scope } from '@interactjs/core/scope'\nimport type { PointerType, PointerEventType, Element } from '@interactjs/types/index'\nimport is from '@interactjs/utils/is'\nimport { warnOnce } from '@interactjs/utils/misc'\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    getAction: (\n      this: Interactable,\n      pointer: PointerType,\n      event: PointerEventType,\n      interaction: Interaction,\n      element: Element,\n    ) => ActionProps | null\n    styleCursor: typeof styleCursor\n    actionChecker: typeof actionChecker\n    ignoreFrom: {\n      (...args: any[]): Interactable\n      (): boolean\n    }\n    allowFrom: {\n      (...args: any[]): Interactable\n      (): boolean\n    }\n  }\n}\n\nfunction install (scope: Scope) {\n  const {\n    /** @lends Interactable */\n    Interactable, // tslint:disable-line no-shadowed-variable\n  } = scope\n\n  Interactable.prototype.getAction = function getAction (\n    this: Interactable,\n    pointer: PointerType,\n    event: PointerEventType,\n    interaction: Interaction,\n    element: Element,\n  ): ActionProps {\n    const action = defaultActionChecker(this, event, interaction, element, scope)\n\n    if (this.options.actionChecker) {\n      return this.options.actionChecker(pointer, event, action, this, element, interaction)\n    }\n\n    return action\n  }\n\n  /**\n   * If the target of the `mousedown`, `pointerdown` or `touchstart` event or any\n   * of it's parents match the given CSS selector or Element, no\n   * drag/resize/gesture is started.\n   *\n   * @deprecated\n   * Don't use this method. Instead set the `ignoreFrom` option for each action\n   * or for `pointerEvents`\n   *\n   * ```js\n   * interact(targett)\n   *   .draggable({\n   *     ignoreFrom: 'input, textarea, a[href]'',\n   *   })\n   *   .pointerEvents({\n   *     ignoreFrom: '[no-pointer]',\n   *   })\n   * ```\n   *\n   * @param {string | Element | null} [newValue] a CSS selector string, an\n   * Element or `null` to not ignore any elements\n   * @return {string | Element | object} The current ignoreFrom value or this\n   * Interactable\n   */\n  Interactable.prototype.ignoreFrom = warnOnce(function (this: Interactable, newValue) {\n    return this._backCompatOption('ignoreFrom', newValue)\n  }, 'Interactable.ignoreFrom() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue}).')\n\n  /**\n   *\n   * A drag/resize/gesture is started only If the target of the `mousedown`,\n   * `pointerdown` or `touchstart` event or any of it's parents match the given\n   * CSS selector or Element.\n   *\n   * @deprecated\n   * Don't use this method. Instead set the `allowFrom` option for each action\n   * or for `pointerEvents`\n   *\n   * ```js\n   * interact(targett)\n   *   .resizable({\n   *     allowFrom: '.resize-handle',\n   *   .pointerEvents({\n   *     allowFrom: '.handle',,\n   *   })\n   * ```\n   *\n   * @param {string | Element | null} [newValue] a CSS selector string, an\n   * Element or `null` to allow from any element\n   * @return {string | Element | object} The current allowFrom value or this\n   * Interactable\n   */\n  Interactable.prototype.allowFrom = warnOnce(function (this: Interactable, newValue) {\n    return this._backCompatOption('allowFrom', newValue)\n  }, 'Interactable.allowFrom() has been deprecated. Use Interactble.draggable({allowFrom: newValue}).')\n\n  /**\n   * ```js\n   * interact('.resize-drag')\n   *   .resizable(true)\n   *   .draggable(true)\n   *   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n   *\n   *     if (interact.matchesSelector(event.target, '.drag-handle')) {\n   *       // force drag with handle target\n   *       action.name = drag\n   *     }\n   *     else {\n   *       // resize from the top and right edges\n   *       action.name  = 'resize'\n   *       action.edges = { top: true, right: true }\n   *     }\n   *\n   *     return action\n   * })\n   * ```\n   *\n   * Returns or sets the function used to check action to be performed on\n   * pointerDown\n   *\n   * @param {function | null} [checker] A function which takes a pointer event,\n   * defaultAction string, interactable, element and interaction as parameters\n   * and returns an object with name property 'drag' 'resize' or 'gesture' and\n   * optionally an `edges` object with boolean 'top', 'left', 'bottom' and right\n   * props.\n   * @return {Function | Interactable} The checker function or this Interactable\n   */\n  Interactable.prototype.actionChecker = actionChecker\n\n  /**\n   * Returns or sets whether the the cursor should be changed depending on the\n   * action that would be performed if the mouse were pressed and dragged.\n   *\n   * @param {boolean} [newValue]\n   * @return {boolean | Interactable} The current setting or this Interactable\n   */\n  Interactable.prototype.styleCursor = styleCursor\n}\n\nfunction defaultActionChecker (\n  interactable: Interactable,\n  event: PointerEventType,\n  interaction: Interaction,\n  element: Element,\n  scope: Scope,\n) {\n  const rect = interactable.getRect(element)\n  const buttons =\n    (event as MouseEvent).buttons ||\n    {\n      0: 1,\n      1: 4,\n      3: 8,\n      4: 16,\n    }[(event as MouseEvent).button as 0 | 1 | 3 | 4]\n  const arg = {\n    action: null,\n    interactable,\n    interaction,\n    element,\n    rect,\n    buttons,\n  }\n\n  scope.fire('auto-start:check', arg)\n\n  return arg.action\n}\n\nfunction styleCursor(this: Interactable): boolean\nfunction styleCursor(this: Interactable, newValue: boolean): typeof this\nfunction styleCursor (this: Interactable, newValue?: boolean) {\n  if (is.bool(newValue)) {\n    this.options.styleCursor = newValue\n\n    return this\n  }\n\n  if (newValue === null) {\n    delete this.options.styleCursor\n\n    return this\n  }\n\n  return this.options.styleCursor\n}\n\nfunction actionChecker (this: Interactable, checker: any) {\n  if (is.func(checker)) {\n    this.options.actionChecker = checker\n\n    return this\n  }\n\n  if (checker === null) {\n    delete this.options.actionChecker\n\n    return this\n  }\n\n  return this.options.actionChecker\n}\n\nexport default {\n  id: 'auto-start/interactableMethods',\n  install,\n}\n","import type { Interactable } from '@interactjs/core/Interactable'\nimport type { Interaction, ActionProps } from '@interactjs/core/Interaction'\nimport type { Scope, SignalArgs, ActionName, Plugin } from '@interactjs/core/scope'\nimport type { CursorChecker, PointerType, PointerEventType, Element } from '@interactjs/types/index'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport { copyAction } from '@interactjs/utils/misc'\n\nimport InteractableMethods from './InteractableMethods'\n\ndeclare module '@interactjs/core/InteractStatic' {\n  export interface InteractStatic {\n    maxInteractions: (newValue: any) => any\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    autoStart: AutoStart\n  }\n\n  interface SignalArgs {\n    'autoStart:before-start': Omit<SignalArgs['interactions:move'], 'interaction'> & {\n      interaction: Interaction<ActionName>\n    }\n    'autoStart:prepared': { interaction: Interaction }\n    'auto-start:check': CheckSignalArg\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface BaseDefaults {\n    actionChecker?: any\n    cursorChecker?: any\n    styleCursor?: any\n  }\n\n  interface PerActionDefaults {\n    manualStart?: boolean\n    max?: number\n    maxPerElement?: number\n    allowFrom?: string | Element\n    ignoreFrom?: string | Element\n    cursorChecker?: CursorChecker\n\n    // only allow left button by default\n    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\n    // TODO: docst\n    mouseButtons?: 0 | 1 | 2 | 4 | 8 | 16\n  }\n}\n\ninterface CheckSignalArg {\n  interactable: Interactable\n  interaction: Interaction\n  element: Element\n  action: ActionProps<ActionName>\n  buttons: number\n}\n\nexport interface AutoStart {\n  // Allow this many interactions to happen simultaneously\n  maxInteractions: number\n  withinInteractionLimit: typeof withinInteractionLimit\n  cursorElement: Element\n}\n\nfunction install (scope: Scope) {\n  const { interactStatic: interact, defaults } = scope\n\n  scope.usePlugin(InteractableMethods)\n\n  defaults.base.actionChecker = null\n  defaults.base.styleCursor = true\n\n  extend(defaults.perAction, {\n    manualStart: false,\n    max: Infinity,\n    maxPerElement: 1,\n    allowFrom: null,\n    ignoreFrom: null,\n\n    // only allow left button by default\n    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\n    mouseButtons: 1,\n  })\n\n  /**\n   * Returns or sets the maximum number of concurrent interactions allowed.  By\n   * default only 1 interaction is allowed at a time (for backwards\n   * compatibility). To allow multiple interactions on the same Interactables and\n   * elements, you need to enable it in the draggable, resizable and gesturable\n   * `'max'` and `'maxPerElement'` options.\n   *\n   * @alias module:interact.maxInteractions\n   *\n   * @param {number} [newValue] Any number. newValue <= 0 means no interactions.\n   */\n  interact.maxInteractions = (newValue: number) => maxInteractions(newValue, scope)\n\n  scope.autoStart = {\n    // Allow this many interactions to happen simultaneously\n    maxInteractions: Infinity,\n    withinInteractionLimit,\n    cursorElement: null,\n  }\n}\n\nfunction prepareOnDown (\n  { interaction, pointer, event, eventTarget }: SignalArgs['interactions:down'],\n  scope: Scope,\n) {\n  if (interaction.interacting()) return\n\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget, scope)\n  prepare(interaction, actionInfo, scope)\n}\n\nfunction prepareOnMove (\n  { interaction, pointer, event, eventTarget }: SignalArgs['interactions:move'],\n  scope: Scope,\n) {\n  if (interaction.pointerType !== 'mouse' || interaction.pointerIsDown || interaction.interacting()) return\n\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget as Element, scope)\n  prepare(interaction, actionInfo, scope)\n}\n\nfunction startOnMove (arg: SignalArgs['interactions:move'], scope: Scope) {\n  const { interaction } = arg\n\n  if (\n    !interaction.pointerIsDown ||\n    interaction.interacting() ||\n    !interaction.pointerWasMoved ||\n    !interaction.prepared.name\n  ) {\n    return\n  }\n\n  scope.fire('autoStart:before-start', arg)\n\n  const { interactable } = interaction\n  const actionName = (interaction as Interaction<ActionName>).prepared.name\n\n  if (actionName && interactable) {\n    // check manualStart and interaction limit\n    if (\n      interactable.options[actionName].manualStart ||\n      !withinInteractionLimit(interactable, interaction.element, interaction.prepared, scope)\n    ) {\n      interaction.stop()\n    } else {\n      interaction.start(interaction.prepared, interactable, interaction.element)\n      setInteractionCursor(interaction, scope)\n    }\n  }\n}\n\nfunction clearCursorOnStop ({ interaction }: { interaction: Interaction }, scope: Scope) {\n  const { interactable } = interaction\n\n  if (interactable && interactable.options.styleCursor) {\n    setCursor(interaction.element, '', scope)\n  }\n}\n\n// Check if the current interactable supports the action.\n// If so, return the validated action. Otherwise, return null\nfunction validateAction<T extends ActionName> (\n  action: ActionProps<T>,\n  interactable: Interactable,\n  element: Element,\n  eventTarget: Node,\n  scope: Scope,\n) {\n  if (\n    interactable.testIgnoreAllow(interactable.options[action.name], element, eventTarget) &&\n    interactable.options[action.name].enabled &&\n    withinInteractionLimit(interactable, element, action, scope)\n  ) {\n    return action\n  }\n\n  return null\n}\n\nfunction validateMatches (\n  interaction: Interaction,\n  pointer: PointerType,\n  event: PointerEventType,\n  matches: Interactable[],\n  matchElements: Element[],\n  eventTarget: Node,\n  scope: Scope,\n) {\n  for (let i = 0, len = matches.length; i < len; i++) {\n    const match = matches[i]\n    const matchElement = matchElements[i]\n    const matchAction = match.getAction(pointer, event, interaction, matchElement)\n\n    if (!matchAction) {\n      continue\n    }\n\n    const action = validateAction<ActionName>(matchAction, match, matchElement, eventTarget, scope)\n\n    if (action) {\n      return {\n        action,\n        interactable: match,\n        element: matchElement,\n      }\n    }\n  }\n\n  return { action: null, interactable: null, element: null }\n}\n\nfunction getActionInfo (\n  interaction: Interaction,\n  pointer: PointerType,\n  event: PointerEventType,\n  eventTarget: Node,\n  scope: Scope,\n) {\n  let matches: Interactable[] = []\n  let matchElements: Element[] = []\n\n  let element = eventTarget as Element\n\n  function pushMatches (interactable: Interactable) {\n    matches.push(interactable)\n    matchElements.push(element)\n  }\n\n  while (is.element(element)) {\n    matches = []\n    matchElements = []\n\n    scope.interactables.forEachMatch(element, pushMatches)\n\n    const actionInfo = validateMatches(\n      interaction,\n      pointer,\n      event,\n      matches,\n      matchElements,\n      eventTarget,\n      scope,\n    )\n\n    if (actionInfo.action && !actionInfo.interactable.options[actionInfo.action.name].manualStart) {\n      return actionInfo\n    }\n\n    element = domUtils.parentNode(element) as Element\n  }\n\n  return { action: null, interactable: null, element: null }\n}\n\nfunction prepare (\n  interaction: Interaction,\n  {\n    action,\n    interactable,\n    element,\n  }: {\n    action: ActionProps<any>\n    interactable: Interactable\n    element: Element\n  },\n  scope: Scope,\n) {\n  action = action || { name: null }\n\n  interaction.interactable = interactable\n  interaction.element = element\n  copyAction(interaction.prepared, action)\n\n  interaction.rect = interactable && action.name ? interactable.getRect(element) : null\n\n  setInteractionCursor(interaction, scope)\n\n  scope.fire('autoStart:prepared', { interaction })\n}\n\nfunction withinInteractionLimit<T extends ActionName> (\n  interactable: Interactable,\n  element: Element,\n  action: ActionProps<T>,\n  scope: Scope,\n) {\n  const options = interactable.options\n  const maxActions = options[action.name].max\n  const maxPerElement = options[action.name].maxPerElement\n  const autoStartMax = scope.autoStart.maxInteractions\n  let activeInteractions = 0\n  let interactableCount = 0\n  let elementCount = 0\n\n  // no actions if any of these values == 0\n  if (!(maxActions && maxPerElement && autoStartMax)) {\n    return false\n  }\n\n  for (const interaction of scope.interactions.list) {\n    const otherAction = interaction.prepared.name\n\n    if (!interaction.interacting()) {\n      continue\n    }\n\n    activeInteractions++\n\n    if (activeInteractions >= autoStartMax) {\n      return false\n    }\n\n    if (interaction.interactable !== interactable) {\n      continue\n    }\n\n    interactableCount += otherAction === action.name ? 1 : 0\n\n    if (interactableCount >= maxActions) {\n      return false\n    }\n\n    if (interaction.element === element) {\n      elementCount++\n\n      if (otherAction === action.name && elementCount >= maxPerElement) {\n        return false\n      }\n    }\n  }\n\n  return autoStartMax > 0\n}\n\nfunction maxInteractions (newValue: any, scope: Scope) {\n  if (is.number(newValue)) {\n    scope.autoStart.maxInteractions = newValue\n\n    return this\n  }\n\n  return scope.autoStart.maxInteractions\n}\n\nfunction setCursor (element: Element, cursor: string, scope: Scope) {\n  const { cursorElement: prevCursorElement } = scope.autoStart\n\n  if (prevCursorElement && prevCursorElement !== element) {\n    prevCursorElement.style.cursor = ''\n  }\n\n  element.ownerDocument.documentElement.style.cursor = cursor\n  element.style.cursor = cursor\n  scope.autoStart.cursorElement = cursor ? element : null\n}\n\nfunction setInteractionCursor<T extends ActionName> (interaction: Interaction<T>, scope: Scope) {\n  const { interactable, element, prepared } = interaction\n\n  if (!(interaction.pointerType === 'mouse' && interactable && interactable.options.styleCursor)) {\n    // clear previous target element cursor\n    if (scope.autoStart.cursorElement) {\n      setCursor(scope.autoStart.cursorElement, '', scope)\n    }\n\n    return\n  }\n\n  let cursor = ''\n\n  if (prepared.name) {\n    const cursorChecker = interactable.options[prepared.name].cursorChecker\n\n    if (is.func(cursorChecker)) {\n      cursor = cursorChecker(prepared, interactable, element, interaction._interacting)\n    } else {\n      cursor = scope.actions.map[prepared.name].getCursor(prepared)\n    }\n  }\n\n  setCursor(interaction.element, cursor || '', scope)\n}\n\nconst autoStart: Plugin = {\n  id: 'auto-start/base',\n  before: ['actions'],\n  install,\n  listeners: {\n    'interactions:down': prepareOnDown,\n    'interactions:move': (arg, scope) => {\n      prepareOnMove(arg, scope)\n      startOnMove(arg, scope)\n    },\n    'interactions:stop': clearCursorOnStop,\n  },\n  maxInteractions,\n  withinInteractionLimit,\n  validateAction,\n}\n\nexport default autoStart\n","import type { Interactable } from '@interactjs/core/Interactable'\nimport type Interaction from '@interactjs/core/Interaction'\nimport type { SignalArgs, Scope, ActionName } from '@interactjs/core/scope'\nimport type { Element } from '@interactjs/types/index'\nimport { parentNode } from '@interactjs/utils/domUtils'\nimport is from '@interactjs/utils/is'\n\nimport autoStart from './base'\n\nfunction beforeStart ({ interaction, eventTarget, dx, dy }: SignalArgs['interactions:move'], scope: Scope) {\n  if (interaction.prepared.name !== 'drag') return\n\n  // check if a drag is in the correct axis\n  const absX = Math.abs(dx)\n  const absY = Math.abs(dy)\n  const targetOptions = interaction.interactable.options.drag\n  const startAxis = targetOptions.startAxis\n  const currentAxis = absX > absY ? 'x' : absX < absY ? 'y' : 'xy'\n\n  interaction.prepared.axis =\n    targetOptions.lockAxis === 'start'\n      ? (currentAxis[0] as 'x' | 'y') // always lock to one axis even if currentAxis === 'xy'\n      : targetOptions.lockAxis\n\n  // if the movement isn't in the startAxis of the interactable\n  if (currentAxis !== 'xy' && startAxis !== 'xy' && startAxis !== currentAxis) {\n    // cancel the prepared action\n    ;(interaction as Interaction<ActionName>).prepared.name = null\n\n    // then try to get a drag from another ineractable\n    let element = eventTarget as Element\n\n    const getDraggable = function (interactable: Interactable): Interactable | void {\n      if (interactable === interaction.interactable) return\n\n      const options = interaction.interactable.options.drag\n\n      if (!options.manualStart && interactable.testIgnoreAllow(options, element, eventTarget)) {\n        const action = interactable.getAction(\n          interaction.downPointer,\n          interaction.downEvent,\n          interaction,\n          element,\n        )\n\n        if (\n          action &&\n          action.name === 'drag' &&\n          checkStartAxis(currentAxis, interactable) &&\n          autoStart.validateAction(action, interactable, element, eventTarget, scope)\n        ) {\n          return interactable\n        }\n      }\n    }\n\n    // check all interactables\n    while (is.element(element)) {\n      const interactable = scope.interactables.forEachMatch(element, getDraggable)\n\n      if (interactable) {\n        ;(interaction as Interaction<ActionName>).prepared.name = 'drag'\n        interaction.interactable = interactable\n        interaction.element = element\n        break\n      }\n\n      element = parentNode(element) as Element\n    }\n  }\n}\n\nfunction checkStartAxis (startAxis: string, interactable: Interactable) {\n  if (!interactable) {\n    return false\n  }\n\n  const thisAxis = interactable.options.drag.startAxis\n\n  return startAxis === 'xy' || thisAxis === 'xy' || thisAxis === startAxis\n}\n\nexport default {\n  id: 'auto-start/dragAxis',\n  listeners: { 'autoStart:before-start': beforeStart },\n}\n","import type Interaction from '@interactjs/core/Interaction'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\n\nimport basePlugin from './base'\n\ndeclare module '@interactjs/core/options' {\n  interface PerActionDefaults {\n    hold?: number\n    delay?: number\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    autoStartHoldTimer?: any\n  }\n}\n\nfunction install (scope: Scope) {\n  const { defaults } = scope\n\n  scope.usePlugin(basePlugin)\n\n  defaults.perAction.hold = 0\n  defaults.perAction.delay = 0\n}\n\nfunction getHoldDuration (interaction: Interaction) {\n  const actionName = interaction.prepared && interaction.prepared.name\n\n  if (!actionName) {\n    return null\n  }\n\n  const options = interaction.interactable.options\n\n  return options[actionName].hold || options[actionName].delay\n}\n\nconst hold: Plugin = {\n  id: 'auto-start/hold',\n  install,\n  listeners: {\n    'interactions:new': ({ interaction }) => {\n      interaction.autoStartHoldTimer = null\n    },\n\n    'autoStart:prepared': ({ interaction }) => {\n      const hold = getHoldDuration(interaction)\n\n      if (hold > 0) {\n        interaction.autoStartHoldTimer = setTimeout(() => {\n          interaction.start(interaction.prepared, interaction.interactable, interaction.element)\n        }, hold)\n      }\n    },\n\n    'interactions:move': ({ interaction, duplicate }) => {\n      if (interaction.autoStartHoldTimer && interaction.pointerWasMoved && !duplicate) {\n        clearTimeout(interaction.autoStartHoldTimer)\n        interaction.autoStartHoldTimer = null\n      }\n    },\n\n    // prevent regular down->move autoStart\n    'autoStart:before-start': ({ interaction }) => {\n      const holdDuration = getHoldDuration(interaction)\n\n      if (holdDuration > 0) {\n        interaction.prepared.name = null\n      }\n    },\n  },\n  getHoldDuration,\n}\nexport default hold\n","import type { Scope } from '@interactjs/core/scope'\n\nimport autoStart from './base'\nimport dragAxis from './dragAxis'\nimport hold from './hold'\n\nexport default {\n  id: 'auto-start',\n  install (scope: Scope) {\n    scope.usePlugin(autoStart)\n    scope.usePlugin(hold)\n    scope.usePlugin(dragAxis)\n  },\n}\n","import type { Interactable } from '@interactjs/core/Interactable'\nimport type Interaction from '@interactjs/core/Interaction'\nimport type { Scope } from '@interactjs/core/scope'\nimport type { PointerEventType } from '@interactjs/types/index'\nimport { matchesSelector, nodeContains } from '@interactjs/utils/domUtils'\nimport is from '@interactjs/utils/is'\nimport { getWindow } from '@interactjs/utils/window'\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    preventDefault: typeof preventDefault\n    checkAndPreventDefault: (event: Event) => void\n  }\n}\n\ntype PreventDefaultValue = 'always' | 'never' | 'auto'\nfunction preventDefault(this: Interactable): PreventDefaultValue\nfunction preventDefault(this: Interactable, newValue: PreventDefaultValue): typeof this\nfunction preventDefault (this: Interactable, newValue?: PreventDefaultValue) {\n  if (/^(always|never|auto)$/.test(newValue)) {\n    this.options.preventDefault = newValue\n    return this\n  }\n\n  if (is.bool(newValue)) {\n    this.options.preventDefault = newValue ? 'always' : 'never'\n    return this\n  }\n\n  return this.options.preventDefault\n}\n\nfunction checkAndPreventDefault (interactable: Interactable, scope: Scope, event: Event) {\n  const setting = interactable.options.preventDefault\n\n  if (setting === 'never') return\n\n  if (setting === 'always') {\n    event.preventDefault()\n    return\n  }\n\n  // setting === 'auto'\n\n  // if the browser supports passive event listeners and isn't running on iOS,\n  // don't preventDefault of touch{start,move} events. CSS touch-action and\n  // user-select should be used instead of calling event.preventDefault().\n  if (scope.events.supportsPassive && /^touch(start|move)$/.test(event.type)) {\n    const doc = getWindow(event.target).document\n    const docOptions = scope.getDocOptions(doc)\n\n    if (!(docOptions && docOptions.events) || docOptions.events.passive !== false) {\n      return\n    }\n  }\n\n  // don't preventDefault of pointerdown events\n  if (/^(mouse|pointer|touch)*(down|start)/i.test(event.type)) {\n    return\n  }\n\n  // don't preventDefault on editable elements\n  if (\n    is.element(event.target) &&\n    matchesSelector(event.target, 'input,select,textarea,[contenteditable=true],[contenteditable=true] *')\n  ) {\n    return\n  }\n\n  event.preventDefault()\n}\n\nfunction onInteractionEvent ({ interaction, event }: { interaction: Interaction, event: PointerEventType }) {\n  if (interaction.interactable) {\n    interaction.interactable.checkAndPreventDefault(event as Event)\n  }\n}\n\nexport function install (scope: Scope) {\n  /** @lends Interactable */\n  const { Interactable } = scope\n\n  /**\n   * Returns or sets whether to prevent the browser's default behaviour in\n   * response to pointer events. Can be set to:\n   *  - `'always'` to always prevent\n   *  - `'never'` to never prevent\n   *  - `'auto'` to let interact.js try to determine what would be best\n   *\n   * @param {string} [newValue] `'always'`, `'never'` or `'auto'`\n   * @return {string | Interactable} The current setting or this Interactable\n   */\n  Interactable.prototype.preventDefault = preventDefault\n\n  Interactable.prototype.checkAndPreventDefault = function (event) {\n    return checkAndPreventDefault(this, scope, event)\n  }\n\n  // prevent native HTML5 drag on interact.js target elements\n  scope.interactions.docEvents.push({\n    type: 'dragstart',\n    listener (event) {\n      for (const interaction of scope.interactions.list) {\n        if (\n          interaction.element &&\n          (interaction.element === event.target || nodeContains(interaction.element, event.target))\n        ) {\n          interaction.interactable.checkAndPreventDefault(event)\n          return\n        }\n      }\n    },\n  })\n}\n\nexport default {\n  id: 'core/interactablePreventDefault',\n  install,\n  listeners: ['down', 'move', 'up', 'cancel'].reduce((acc, eventType) => {\n    acc[`interactions:${eventType}`] = onInteractionEvent\n    return acc\n  }, {} as any),\n}\n","export default {}\n","import type Interaction from '@interactjs/core/Interaction'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport visualizer from '@interactjs/dev-tools/visualizer/plugin'\nimport type { Element, OptionMethod } from '@interactjs/types/index'\nimport domObjects from '@interactjs/utils/domObjects'\nimport { parentNode } from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport * as win from '@interactjs/utils/window'\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    logger: Logger\n  }\n}\n\ndeclare module '@interactjs/core/InteractStatic' {\n  export interface InteractStatic {\n    visializer: typeof visualizer\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface BaseDefaults {\n    devTools?: DevToolsOptions\n  }\n}\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    devTools: OptionMethod<DevToolsOptions>\n  }\n}\n\nexport interface DevToolsOptions {\n  ignore: { [P in keyof typeof CheckName]?: boolean }\n}\n\nexport interface Logger {\n  warn: (...args: any[]) => void\n  error: (...args: any[]) => void\n  log: (...args: any[]) => void\n}\n\nexport interface Check {\n  name: CheckName\n  text: string\n  perform: (interaction: Interaction) => boolean\n  getInfo: (interaction: Interaction) => any[]\n}\n\nenum CheckName {\n  touchAction = 'touchAction',\n  boxSizing = 'boxSizing',\n  noListeners = 'noListeners',\n}\n\nconst prefix = '[interact.js] '\nconst links = {\n  touchAction: 'https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action',\n  boxSizing: 'https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing',\n}\n\n// eslint-disable-next-line no-undef\nconst isProduction = process.env.NODE_ENV === 'production'\n\nfunction install (scope: Scope, { logger }: { logger?: Logger } = {}) {\n  const { Interactable, defaults } = scope\n\n  scope.logger = logger || console\n\n  defaults.base.devTools = {\n    ignore: {},\n  }\n\n  Interactable.prototype.devTools = function (options?: object) {\n    if (options) {\n      extend(this.options.devTools, options)\n      return this\n    }\n\n    return this.options.devTools\n  }\n\n  scope.usePlugin(visualizer)\n}\n\nconst checks: Check[] = [\n  {\n    name: CheckName.touchAction,\n    perform ({ element }) {\n      return !parentHasStyle(element, 'touchAction', /pan-|pinch|none/)\n    },\n    getInfo ({ element }) {\n      return [element, links.touchAction]\n    },\n    text: 'Consider adding CSS \"touch-action: none\" to this element\\n',\n  },\n\n  {\n    name: CheckName.boxSizing,\n    perform (interaction) {\n      const { element } = interaction\n\n      return (\n        interaction.prepared.name === 'resize' &&\n        element instanceof domObjects.HTMLElement &&\n        !hasStyle(element, 'boxSizing', /border-box/)\n      )\n    },\n    text: 'Consider adding CSS \"box-sizing: border-box\" to this resizable element',\n    getInfo ({ element }) {\n      return [element, links.boxSizing]\n    },\n  },\n\n  {\n    name: CheckName.noListeners,\n    perform (interaction) {\n      const actionName = interaction.prepared.name\n      const moveListeners = interaction.interactable.events.types[`${actionName}move`] || []\n\n      return !moveListeners.length\n    },\n    getInfo (interaction) {\n      return [interaction.prepared.name, interaction.interactable]\n    },\n    text: 'There are no listeners set for this action',\n  },\n]\n\nfunction hasStyle (element: HTMLElement, prop: keyof CSSStyleDeclaration, styleRe: RegExp) {\n  const value = element.style[prop] || win.window.getComputedStyle(element)[prop]\n  return styleRe.test((value || '').toString())\n}\n\nfunction parentHasStyle (element: Element, prop: keyof CSSStyleDeclaration, styleRe: RegExp) {\n  let parent = element as HTMLElement\n\n  while (is.element(parent)) {\n    if (hasStyle(parent, prop, styleRe)) {\n      return true\n    }\n\n    parent = parentNode(parent) as HTMLElement\n  }\n\n  return false\n}\n\nconst id = 'dev-tools'\nconst defaultExport: Plugin = isProduction\n  ? { id, install: () => {} }\n  : {\n    id,\n    install,\n    listeners: {\n      'interactions:action-start': ({ interaction }, scope) => {\n        for (const check of checks) {\n          const options = interaction.interactable && interaction.interactable.options\n\n          if (\n            !(options && options.devTools && options.devTools.ignore[check.name]) &&\n              check.perform(interaction)\n          ) {\n            scope.logger.warn(prefix + check.text, ...check.getInfo(interaction))\n          }\n        }\n      },\n    },\n    checks,\n    CheckName,\n    links,\n    prefix,\n  }\n\nexport default defaultExport\n","import * as arr from './arr'\nimport is from './is'\n\n// tslint:disable-next-line ban-types\nexport default function clone<T extends Object> (source: T): Partial<T> {\n  const dest = {} as Partial<T>\n\n  for (const prop in source) {\n    const value = source[prop]\n\n    if (is.plainObject(value)) {\n      dest[prop] = clone(value) as any\n    } else if (is.array(value)) {\n      dest[prop] = arr.from(value) as typeof value\n    } else {\n      dest[prop] = value\n    }\n  }\n\n  return dest\n}\n","import type { EventPhase } from '@interactjs/core/InteractEvent'\nimport type { Interaction, DoAnyPhaseArg } from '@interactjs/core/Interaction'\nimport type { EdgeOptions, FullRect, Point, Rect } from '@interactjs/types/index'\nimport clone from '@interactjs/utils/clone'\nimport extend from '@interactjs/utils/extend'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nimport type { Modifier, ModifierArg, ModifierState } from './base'\n\nexport interface ModificationResult {\n  delta: Point\n  rectDelta: Rect\n  coords: Point\n  rect: FullRect\n  eventProps: any[]\n  changed: boolean\n}\n\ninterface MethodArg {\n  phase: EventPhase\n  pageCoords: Point\n  rect: FullRect\n  coords: Point\n  preEnd?: boolean\n  skipModifiers?: number\n}\n\nexport default class Modification {\n  states: ModifierState[] = []\n  startOffset: Rect = { left: 0, right: 0, top: 0, bottom: 0 }\n  startDelta!: Point\n  result!: ModificationResult\n  endResult!: Point\n  edges!: EdgeOptions\n  readonly interaction: Readonly<Interaction>\n\n  constructor (interaction: Interaction) {\n    this.interaction = interaction\n    this.result = createResult()\n  }\n\n  start ({ phase }: { phase: EventPhase }, pageCoords: Point) {\n    const { interaction } = this\n    const modifierList = getModifierList(interaction)\n    this.prepareStates(modifierList)\n\n    this.edges = extend({}, interaction.edges)\n    this.startOffset = getRectOffset(interaction.rect, pageCoords)\n    this.startDelta = { x: 0, y: 0 }\n\n    const arg = this.fillArg({\n      phase,\n      pageCoords,\n      preEnd: false,\n    })\n\n    this.result = createResult()\n    this.startAll(arg)\n\n    const result = (this.result = this.setAll(arg))\n\n    return result\n  }\n\n  fillArg (arg: Partial<ModifierArg>) {\n    const { interaction } = this\n\n    arg.interaction = interaction\n    arg.interactable = interaction.interactable\n    arg.element = interaction.element\n    arg.rect = arg.rect || interaction.rect\n    arg.edges = this.edges\n    arg.startOffset = this.startOffset\n\n    return arg as ModifierArg\n  }\n\n  startAll (arg: MethodArg & Partial<ModifierArg>) {\n    for (const state of this.states) {\n      if (state.methods.start) {\n        arg.state = state\n        state.methods.start(arg as ModifierArg)\n      }\n    }\n  }\n\n  setAll (arg: MethodArg & Partial<ModifierArg>): ModificationResult {\n    const { phase, preEnd, skipModifiers, rect: unmodifiedRect } = arg\n\n    arg.coords = extend({}, arg.pageCoords)\n    arg.rect = extend({}, unmodifiedRect)\n\n    const states = skipModifiers ? this.states.slice(skipModifiers) : this.states\n\n    const newResult = createResult(arg.coords, arg.rect)\n\n    for (const state of states) {\n      const { options } = state\n      const lastModifierCoords = extend({}, arg.coords)\n      let returnValue = null\n\n      if (state.methods?.set && this.shouldDo(options, preEnd, phase)) {\n        arg.state = state\n        returnValue = state.methods.set(arg as ModifierArg<never>)\n\n        rectUtils.addEdges(this.interaction.edges, arg.rect, {\n          x: arg.coords.x - lastModifierCoords.x,\n          y: arg.coords.y - lastModifierCoords.y,\n        })\n      }\n\n      newResult.eventProps.push(returnValue)\n    }\n\n    newResult.delta.x = arg.coords.x - arg.pageCoords.x\n    newResult.delta.y = arg.coords.y - arg.pageCoords.y\n\n    newResult.rectDelta.left = arg.rect.left - unmodifiedRect.left\n    newResult.rectDelta.right = arg.rect.right - unmodifiedRect.right\n    newResult.rectDelta.top = arg.rect.top - unmodifiedRect.top\n    newResult.rectDelta.bottom = arg.rect.bottom - unmodifiedRect.bottom\n\n    const prevCoords = this.result.coords\n    const prevRect = this.result.rect\n\n    if (prevCoords && prevRect) {\n      const rectChanged =\n        newResult.rect.left !== prevRect.left ||\n        newResult.rect.right !== prevRect.right ||\n        newResult.rect.top !== prevRect.top ||\n        newResult.rect.bottom !== prevRect.bottom\n\n      newResult.changed =\n        rectChanged || prevCoords.x !== newResult.coords.x || prevCoords.y !== newResult.coords.y\n    }\n\n    return newResult\n  }\n\n  applyToInteraction (arg: { phase: EventPhase, rect?: Rect }) {\n    const { interaction } = this\n    const { phase } = arg\n    const curCoords = interaction.coords.cur\n    const startCoords = interaction.coords.start\n    const { result, startDelta } = this\n    const curDelta = result.delta\n\n    if (phase === 'start') {\n      extend(this.startDelta, result.delta)\n    }\n\n    for (const [coordsSet, delta] of [\n      [startCoords, startDelta],\n      [curCoords, curDelta],\n    ] as const) {\n      coordsSet.page.x += delta.x\n      coordsSet.page.y += delta.y\n      coordsSet.client.x += delta.x\n      coordsSet.client.y += delta.y\n    }\n\n    const { rectDelta } = this.result\n    const rect = arg.rect || interaction.rect\n\n    rect.left += rectDelta.left\n    rect.right += rectDelta.right\n    rect.top += rectDelta.top\n    rect.bottom += rectDelta.bottom\n\n    rect.width = rect.right - rect.left\n    rect.height = rect.bottom - rect.top\n  }\n\n  setAndApply (\n    arg: Partial<DoAnyPhaseArg> & {\n      phase: EventPhase\n      preEnd?: boolean\n      skipModifiers?: number\n      modifiedCoords?: Point\n    },\n  ): void | false {\n    const { interaction } = this\n    const { phase, preEnd, skipModifiers } = arg\n\n    const result = this.setAll(\n      this.fillArg({\n        preEnd,\n        phase,\n        pageCoords: arg.modifiedCoords || interaction.coords.cur.page,\n      }),\n    )\n\n    this.result = result\n\n    // don't fire an action move if a modifier would keep the event in the same\n    // cordinates as before\n    if (\n      !result.changed &&\n      (!skipModifiers || skipModifiers < this.states.length) &&\n      interaction.interacting()\n    ) {\n      return false\n    }\n\n    if (arg.modifiedCoords) {\n      const { page } = interaction.coords.cur\n      const adjustment = {\n        x: arg.modifiedCoords.x - page.x,\n        y: arg.modifiedCoords.y - page.y,\n      }\n\n      result.coords.x += adjustment.x\n      result.coords.y += adjustment.y\n      result.delta.x += adjustment.x\n      result.delta.y += adjustment.y\n    }\n\n    this.applyToInteraction(arg)\n  }\n\n  beforeEnd (arg: Omit<DoAnyPhaseArg, 'iEvent'> & { state?: ModifierState }): void | false {\n    const { interaction, event } = arg\n    const states = this.states\n\n    if (!states || !states.length) {\n      return\n    }\n\n    let doPreend = false\n\n    for (const state of states) {\n      arg.state = state\n      const { options, methods } = state\n\n      const endPosition = methods.beforeEnd && methods.beforeEnd((arg as unknown) as ModifierArg)\n\n      if (endPosition) {\n        this.endResult = endPosition\n        return false\n      }\n\n      doPreend = doPreend || (!doPreend && this.shouldDo(options, true, arg.phase, true))\n    }\n\n    if (doPreend) {\n      // trigger a final modified move before ending\n      interaction.move({ event, preEnd: true })\n    }\n  }\n\n  stop (arg: { interaction: Interaction }) {\n    const { interaction } = arg\n\n    if (!this.states || !this.states.length) {\n      return\n    }\n\n    const modifierArg: Partial<ModifierArg> = extend(\n      {\n        states: this.states,\n        interactable: interaction.interactable,\n        element: interaction.element,\n        rect: null,\n      },\n      arg,\n    )\n\n    this.fillArg(modifierArg)\n\n    for (const state of this.states) {\n      modifierArg.state = state\n\n      if (state.methods.stop) {\n        state.methods.stop(modifierArg as ModifierArg)\n      }\n    }\n\n    this.states = null\n    this.endResult = null\n  }\n\n  prepareStates (modifierList: Modifier[]) {\n    this.states = []\n\n    for (let index = 0; index < modifierList.length; index++) {\n      const { options, methods, name } = modifierList[index]\n\n      this.states.push({\n        options,\n        methods,\n        index,\n        name,\n      })\n    }\n\n    return this.states\n  }\n\n  restoreInteractionCoords ({ interaction: { coords, rect, modification } }: { interaction: Interaction }) {\n    if (!modification.result) return\n\n    const { startDelta } = modification\n    const { delta: curDelta, rectDelta } = modification.result\n\n    const coordsAndDeltas = [\n      [coords.start, startDelta],\n      [coords.cur, curDelta],\n    ]\n\n    for (const [coordsSet, delta] of coordsAndDeltas as any) {\n      coordsSet.page.x -= delta.x\n      coordsSet.page.y -= delta.y\n      coordsSet.client.x -= delta.x\n      coordsSet.client.y -= delta.y\n    }\n\n    rect.left -= rectDelta.left\n    rect.right -= rectDelta.right\n    rect.top -= rectDelta.top\n    rect.bottom -= rectDelta.bottom\n  }\n\n  shouldDo (options, preEnd?: boolean, phase?: string, requireEndOnly?: boolean) {\n    if (\n      // ignore disabled modifiers\n      !options ||\n      options.enabled === false ||\n      // check if we require endOnly option to fire move before end\n      (requireEndOnly && !options.endOnly) ||\n      // don't apply endOnly modifiers when not ending\n      (options.endOnly && !preEnd) ||\n      // check if modifier should run be applied on start\n      (phase === 'start' && !options.setStart)\n    ) {\n      return false\n    }\n\n    return true\n  }\n\n  copyFrom (other: Modification) {\n    this.startOffset = other.startOffset\n    this.startDelta = other.startDelta\n    this.edges = other.edges\n    this.states = other.states.map((s) => clone(s) as ModifierState)\n    this.result = createResult(extend({}, other.result.coords), extend({}, other.result.rect))\n  }\n\n  destroy () {\n    for (const prop in this) {\n      this[prop] = null\n    }\n  }\n}\n\nfunction createResult (coords?: Point, rect?: FullRect): ModificationResult {\n  return {\n    rect,\n    coords,\n    delta: { x: 0, y: 0 },\n    rectDelta: {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0,\n    },\n    eventProps: [],\n    changed: true,\n  }\n}\n\nfunction getModifierList (interaction) {\n  const actionOptions = interaction.interactable.options[interaction.prepared.name]\n  const actionModifiers = actionOptions.modifiers\n\n  if (actionModifiers && actionModifiers.length) {\n    return actionModifiers\n  }\n\n  return ['snap', 'snapSize', 'snapEdges', 'restrict', 'restrictEdges', 'restrictSize']\n    .map((type) => {\n      const options = actionOptions[type]\n\n      return (\n        options &&\n        options.enabled && {\n          options,\n          methods: options._methods,\n        }\n      )\n    })\n    .filter((m) => !!m)\n}\n\nexport function getRectOffset (rect, coords) {\n  return rect\n    ? {\n      left: coords.x - rect.left,\n      top: coords.y - rect.top,\n      right: rect.right - coords.x,\n      bottom: rect.bottom - coords.y,\n    }\n    : {\n      left: 0,\n      top: 0,\n      right: 0,\n      bottom: 0,\n    }\n}\n","import type { EventPhase, InteractEvent } from '@interactjs/core/InteractEvent'\nimport type { Interactable } from '@interactjs/core/Interactable'\nimport type Interaction from '@interactjs/core/Interaction'\nimport type { Plugin } from '@interactjs/core/scope'\nimport type { EdgeOptions, FullRect, Point, Rect } from '@interactjs/types/index'\n\nimport Modification from './Modification'\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    modification?: Modification\n  }\n}\n\ndeclare module '@interactjs/core/InteractEvent' {\n  interface InteractEvent {\n    modifiers?: Array<{\n      name: string\n      [key: string]: any\n    }>\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface PerActionDefaults {\n    modifiers?: Modifier[]\n  }\n}\n\nexport interface Modifier<\n  Defaults = any,\n  State extends ModifierState = any,\n  Name extends string = any,\n  Result = any\n> {\n  options: Defaults\n  methods: {\n    start?: (arg: ModifierArg<State>) => void\n    set?: (arg: ModifierArg<State>) => Result\n    beforeEnd?: (arg: ModifierArg<State>) => Point | void\n    stop?: (arg: ModifierArg<State>) => void\n  }\n  name?: Name\n  enable: () => Modifier<Defaults, State, Name, Result>\n  disable: () => Modifier<Defaults, State, Name, Result>\n}\n\nexport type ModifierState<Defaults = unknown, StateProps = unknown, Name extends string = any> = {\n  options: Defaults\n  methods?: Modifier<Defaults>['methods']\n  index?: number\n  name?: Name\n} & StateProps\n\nexport interface ModifierArg<State extends ModifierState = ModifierState> {\n  interaction: Interaction\n  interactable: Interactable\n  phase: EventPhase\n  rect: FullRect\n  edges: EdgeOptions\n  state: State\n  element: Element\n  pageCoords: Point\n  prevCoords: Point\n  prevRect?: FullRect\n  coords: Point\n  startOffset: Rect\n  preEnd?: boolean\n}\n\nexport interface ModifierModule<\n  Defaults extends { enabled?: boolean },\n  State extends ModifierState,\n  Result = unknown\n> {\n  defaults?: Defaults\n  start?(arg: ModifierArg<State>): void\n  set?(arg: ModifierArg<State>): Result\n  beforeEnd?(arg: ModifierArg<State>): Point | void\n  stop?(arg: ModifierArg<State>): void\n}\n\nexport interface ModifierFunction<\n  Defaults extends { enabled?: boolean },\n  State extends ModifierState,\n  Name extends string\n> {\n  (_options?: Partial<Defaults>): Modifier<Defaults, State, Name>\n  _defaults: Defaults\n  _methods: ModifierModule<Defaults, State>\n}\n\nexport function makeModifier<\n  Defaults extends { enabled?: boolean },\n  State extends ModifierState,\n  Name extends string,\n  Result\n> (module: ModifierModule<Defaults, State, Result>, name?: Name) {\n  const { defaults } = module\n  const methods = {\n    start: module.start,\n    set: module.set,\n    beforeEnd: module.beforeEnd,\n    stop: module.stop,\n  }\n\n  const modifier = (_options?: Partial<Defaults>) => {\n    const options = (_options || {}) as Defaults\n\n    options.enabled = options.enabled !== false\n\n    // add missing defaults to options\n    for (const prop in defaults) {\n      if (!(prop in options)) {\n        ;(options as any)[prop] = defaults[prop]\n      }\n    }\n\n    const m: Modifier<Defaults, State, Name, Result> = {\n      options,\n      methods,\n      name,\n      enable: () => {\n        options.enabled = true\n        return m\n      },\n      disable: () => {\n        options.enabled = false\n        return m\n      },\n    }\n\n    return m\n  }\n\n  if (name && typeof name === 'string') {\n    // for backwrads compatibility\n    modifier._defaults = defaults\n    modifier._methods = methods\n  }\n\n  return modifier\n}\n\nexport function addEventModifiers ({\n  iEvent,\n  interaction,\n}: {\n  iEvent: InteractEvent<any>\n  interaction: Interaction<any>\n}) {\n  const result = interaction.modification!.result\n\n  if (result) {\n    iEvent.modifiers = result.eventProps\n  }\n}\n\nconst modifiersBase: Plugin = {\n  id: 'modifiers/base',\n  before: ['actions'],\n  install: (scope) => {\n    scope.defaults.perAction.modifiers = []\n  },\n  listeners: {\n    'interactions:new': ({ interaction }) => {\n      interaction.modification = new Modification(interaction)\n    },\n\n    'interactions:before-action-start': (arg) => {\n      const modification = arg.interaction.modification!\n\n      modification.start(arg, arg.interaction.coords.start.page)\n      arg.interaction.edges = modification.edges\n      modification.applyToInteraction(arg)\n    },\n\n    'interactions:before-action-move': (arg) => arg.interaction.modification.setAndApply(arg),\n\n    'interactions:before-action-end': (arg) => arg.interaction.modification.beforeEnd(arg),\n\n    'interactions:action-start': addEventModifiers,\n    'interactions:action-move': addEventModifiers,\n    'interactions:action-end': addEventModifiers,\n\n    'interactions:after-action-start': (arg) => arg.interaction.modification.restoreInteractionCoords(arg),\n    'interactions:after-action-move': (arg) => arg.interaction.modification.restoreInteractionCoords(arg),\n\n    'interactions:stop': (arg) => arg.interaction.modification.stop(arg),\n  },\n}\n\nexport default modifiersBase\n","import type { Point, Listeners, OrBoolean, Element } from '@interactjs/types/index'\n\nexport interface Defaults {\n  base: BaseDefaults\n  perAction: PerActionDefaults\n  actions: ActionDefaults\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface ActionDefaults {}\n\nexport interface BaseDefaults {\n  preventDefault?: 'auto' | 'never' | string\n  deltaSource?: 'page' | 'client'\n  context?: Node\n}\n\nexport interface PerActionDefaults {\n  enabled?: boolean\n  origin?: Point | string | Element\n  listeners?: Listeners\n  allowFrom?: string | Element\n  ignoreFrom?: string | Element\n}\n\nexport type Options = Partial<BaseDefaults> &\nPartial<PerActionDefaults> &\n{\n  [P in keyof ActionDefaults]?: Partial<ActionDefaults[P]>\n}\n\n// export interface Options extends BaseDefaults, PerActionDefaults {}\n\nexport interface OptionsArg extends BaseDefaults, OrBoolean<Partial<ActionDefaults>> {}\n\nexport const defaults: Defaults = {\n  base: {\n    preventDefault: 'auto',\n    deltaSource: 'page',\n  },\n\n  perAction: {\n    enabled: false,\n    origin: { x: 0, y: 0 },\n  },\n\n  actions: {} as ActionDefaults,\n}\n","import type { ActionName } from '@interactjs/core/scope'\nimport type { Point, FullRect, PointerEventType, Element } from '@interactjs/types/index'\nimport extend from '@interactjs/utils/extend'\nimport getOriginXY from '@interactjs/utils/getOriginXY'\nimport hypot from '@interactjs/utils/hypot'\n\nimport { BaseEvent } from './BaseEvent'\nimport type { Interaction } from './Interaction'\nimport { defaults } from './options'\n\nexport type EventPhase = keyof PhaseMap\n\nexport interface PhaseMap {\n  start: true\n  move: true\n  end: true\n}\n\n// defined outside of class definition to avoid assignment of undefined during\n// construction\nexport interface InteractEvent {\n  pageX: number\n  pageY: number\n\n  clientX: number\n  clientY: number\n\n  dx: number\n  dy: number\n\n  velocityX: number\n  velocityY: number\n}\n\nexport class InteractEvent<\n  T extends ActionName = never,\n  P extends EventPhase = EventPhase\n> extends BaseEvent<T> {\n  target: Element\n  currentTarget: Element\n  relatedTarget: Element | null = null\n  screenX?: number\n  screenY?: number\n  button: number\n  buttons: number\n  ctrlKey: boolean\n  shiftKey: boolean\n  altKey: boolean\n  metaKey: boolean\n  page: Point\n  client: Point\n  delta: Point\n  rect: FullRect\n  x0: number\n  y0: number\n  t0: number\n  dt: number\n  duration: number\n  clientX0: number\n  clientY0: number\n  velocity: Point\n  speed: number\n  swipe: ReturnType<InteractEvent<T>['getSwipe']>\n  timeStamp: any\n  // resize\n  axes?: 'x' | 'y' | 'xy'\n  preEnd?: boolean\n\n  /** */\n  constructor (\n    interaction: Interaction<T>,\n    event: PointerEventType,\n    actionName: T,\n    phase: P,\n    element: Element,\n    preEnd?: boolean,\n    type?: string,\n  ) {\n    super(interaction)\n\n    element = element || interaction.element\n\n    const target = interaction.interactable\n    const deltaSource = (((target && target.options) || defaults) as any).deltaSource as 'page' | 'client'\n    const origin = getOriginXY(target, element, actionName)\n    const starting = phase === 'start'\n    const ending = phase === 'end'\n    const prevEvent = starting ? this : interaction.prevEvent\n    const coords = starting\n      ? interaction.coords.start\n      : ending\n        ? { page: prevEvent.page, client: prevEvent.client, timeStamp: interaction.coords.cur.timeStamp }\n        : interaction.coords.cur\n\n    this.page = extend({}, coords.page)\n    this.client = extend({}, coords.client)\n    this.rect = extend({}, interaction.rect)\n    this.timeStamp = coords.timeStamp\n\n    if (!ending) {\n      this.page.x -= origin.x\n      this.page.y -= origin.y\n\n      this.client.x -= origin.x\n      this.client.y -= origin.y\n    }\n\n    this.ctrlKey = event.ctrlKey\n    this.altKey = event.altKey\n    this.shiftKey = event.shiftKey\n    this.metaKey = event.metaKey\n    this.button = (event as MouseEvent).button\n    this.buttons = (event as MouseEvent).buttons\n    this.target = element\n    this.currentTarget = element\n    this.preEnd = preEnd\n    this.type = type || actionName + (phase || '')\n    this.interactable = target\n\n    this.t0 = starting ? interaction.pointers[interaction.pointers.length - 1].downTime : prevEvent.t0\n\n    this.x0 = interaction.coords.start.page.x - origin.x\n    this.y0 = interaction.coords.start.page.y - origin.y\n    this.clientX0 = interaction.coords.start.client.x - origin.x\n    this.clientY0 = interaction.coords.start.client.y - origin.y\n\n    if (starting || ending) {\n      this.delta = { x: 0, y: 0 }\n    } else {\n      this.delta = {\n        x: this[deltaSource].x - prevEvent[deltaSource].x,\n        y: this[deltaSource].y - prevEvent[deltaSource].y,\n      }\n    }\n\n    this.dt = interaction.coords.delta.timeStamp\n    this.duration = this.timeStamp - this.t0\n\n    // velocity and speed in pixels per second\n    this.velocity = extend({}, interaction.coords.velocity[deltaSource])\n    this.speed = hypot(this.velocity.x, this.velocity.y)\n\n    this.swipe = ending || phase === 'inertiastart' ? this.getSwipe() : null\n  }\n\n  getSwipe () {\n    const interaction = this._interaction\n\n    if (interaction.prevEvent.speed < 600 || this.timeStamp - interaction.prevEvent.timeStamp > 150) {\n      return null\n    }\n\n    let angle = (180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX)) / Math.PI\n    const overlap = 22.5\n\n    if (angle < 0) {\n      angle += 360\n    }\n\n    const left = 135 - overlap <= angle && angle < 225 + overlap\n    const up = 225 - overlap <= angle && angle < 315 + overlap\n\n    const right = !left && (315 - overlap <= angle || angle < 45 + overlap)\n    const down = !up && 45 - overlap <= angle && angle < 135 + overlap\n\n    return {\n      up,\n      down,\n      left,\n      right,\n      angle,\n      speed: interaction.prevEvent.speed,\n      velocity: {\n        x: interaction.prevEvent.velocityX,\n        y: interaction.prevEvent.velocityY,\n      },\n    }\n  }\n\n  preventDefault () {}\n\n  /**\n   * Don't call listeners on the remaining targets\n   */\n  stopImmediatePropagation () {\n    this.immediatePropagationStopped = this.propagationStopped = true\n  }\n\n  /**\n   * Don't call any other listeners (even on the current target)\n   */\n  stopPropagation () {\n    this.propagationStopped = true\n  }\n}\n\n// getters and setters defined here to support typescript 3.6 and below which\n// don't support getter and setters in .d.ts files\nObject.defineProperties(InteractEvent.prototype, {\n  pageX: {\n    get () {\n      return this.page.x\n    },\n    set (value) {\n      this.page.x = value\n    },\n  },\n  pageY: {\n    get () {\n      return this.page.y\n    },\n    set (value) {\n      this.page.y = value\n    },\n  },\n\n  clientX: {\n    get () {\n      return this.client.x\n    },\n    set (value) {\n      this.client.x = value\n    },\n  },\n  clientY: {\n    get () {\n      return this.client.y\n    },\n    set (value) {\n      this.client.y = value\n    },\n  },\n\n  dx: {\n    get () {\n      return this.delta.x\n    },\n    set (value) {\n      this.delta.x = value\n    },\n  },\n  dy: {\n    get () {\n      return this.delta.y\n    },\n    set (value) {\n      this.delta.y = value\n    },\n  },\n\n  velocityX: {\n    get () {\n      return this.velocity.x\n    },\n    set (value) {\n      this.velocity.x = value\n    },\n  },\n  velocityY: {\n    get () {\n      return this.velocity.y\n    },\n    set (value) {\n      this.velocity.y = value\n    },\n  },\n})\n","import type { PointerEventType, PointerType } from '@interactjs/types/index'\n\nexport class PointerInfo {\n  id: number\n  pointer: PointerType\n  event: PointerEventType\n  downTime: number\n  downTarget: Node\n\n  constructor (id: number, pointer: PointerType, event: PointerEventType, downTime: number, downTarget: Node) {\n    this.id = id\n    this.pointer = pointer\n    this.event = event\n    this.downTime = downTime\n    this.downTarget = downTarget\n  }\n}\n","import type { ActionDefaults } from '@interactjs/core/options'\nimport type {\n  Element,\n  EdgeOptions,\n  PointerEventType,\n  PointerType,\n  FullRect,\n  CoordsSet,\n} from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\nimport extend from '@interactjs/utils/extend'\nimport hypot from '@interactjs/utils/hypot'\nimport { warnOnce, copyAction } from '@interactjs/utils/misc'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nimport type { EventPhase } from './InteractEvent'\nimport { InteractEvent } from './InteractEvent'\nimport type { Interactable } from './Interactable'\nimport { PointerInfo } from './PointerInfo'\nimport type { ActionName, Scope } from './scope'\n\nexport interface ActionProps<T extends ActionName | null = never> {\n  name: T\n  axis?: 'x' | 'y' | 'xy' | null\n  edges?: EdgeOptions | null\n}\n\nexport enum _ProxyValues {\n  interactable = '',\n  element = '',\n  prepared = '',\n  pointerIsDown = '',\n  pointerWasMoved = '',\n  _proxy = '',\n}\n\nexport enum _ProxyMethods {\n  start = '',\n  move = '',\n  end = '',\n  stop = '',\n  interacting = '',\n}\n\nexport type PointerArgProps<T extends {} = {}> = {\n  pointer: PointerType\n  event: PointerEventType\n  eventTarget: Node\n  pointerIndex: number\n  pointerInfo: PointerInfo\n  interaction: Interaction<never>\n} & T\n\nexport interface DoPhaseArg<T extends ActionName, P extends EventPhase> {\n  event: PointerEventType\n  phase: EventPhase\n  interaction: Interaction<T>\n  iEvent: InteractEvent<T, P>\n  preEnd?: boolean\n  type?: string\n}\n\nexport type DoAnyPhaseArg = DoPhaseArg<ActionName, EventPhase>\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactions:new': { interaction: Interaction<ActionName> }\n    'interactions:down': PointerArgProps<{\n      type: 'down'\n    }>\n    'interactions:move': PointerArgProps<{\n      type: 'move'\n      dx: number\n      dy: number\n      duplicate: boolean\n    }>\n    'interactions:up': PointerArgProps<{\n      type: 'up'\n      curEventTarget: EventTarget\n    }>\n    'interactions:cancel': SignalArgs['interactions:up'] & {\n      type: 'cancel'\n      curEventTarget: EventTarget\n    }\n    'interactions:update-pointer': PointerArgProps<{\n      down: boolean\n    }>\n    'interactions:remove-pointer': PointerArgProps\n    'interactions:blur': { interaction: Interaction<never>, event: Event, type: 'blur' }\n    'interactions:before-action-start': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-start': DoAnyPhaseArg\n    'interactions:after-action-start': DoAnyPhaseArg\n    'interactions:before-action-move': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-move': DoAnyPhaseArg\n    'interactions:after-action-move': DoAnyPhaseArg\n    'interactions:before-action-end': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-end': DoAnyPhaseArg\n    'interactions:after-action-end': DoAnyPhaseArg\n    'interactions:stop': { interaction: Interaction }\n  }\n}\n\nexport type InteractionProxy<T extends ActionName | null = never> = Pick<\nInteraction<T>,\nkeyof typeof _ProxyValues | keyof typeof _ProxyMethods\n>\n\nlet idCounter = 0\n\nexport class Interaction<T extends ActionName | null = ActionName> {\n  // current interactable being interacted with\n  interactable: Interactable = null\n\n  // the target element of the interactable\n  element: Element = null\n  rect: FullRect\n  _rects?: {\n    start: FullRect\n    corrected: FullRect\n    previous: FullRect\n    delta: FullRect\n  }\n  edges: EdgeOptions\n\n  _scopeFire: Scope['fire']\n\n  // action that's ready to be fired on next move event\n  prepared: ActionProps<T> = {\n    name: null,\n    axis: null,\n    edges: null,\n  }\n\n  pointerType: string\n\n  // keep track of added pointers\n  pointers: PointerInfo[] = []\n\n  // pointerdown/mousedown/touchstart event\n  downEvent: PointerEventType = null\n\n  downPointer: PointerType = {} as PointerType\n\n  _latestPointer: {\n    pointer: PointerType\n    event: PointerEventType\n    eventTarget: Node\n  } = {\n    pointer: null,\n    event: null,\n    eventTarget: null,\n  }\n\n  // previous action event\n  prevEvent: InteractEvent<T, EventPhase> = null\n\n  pointerIsDown = false\n  pointerWasMoved = false\n  _interacting = false\n  _ending = false\n  _stopped = true\n  _proxy: InteractionProxy<T> = null\n\n  simulation = null\n\n  /** @internal */ get pointerMoveTolerance () {\n    return 1\n  }\n\n  /**\n   * @alias Interaction.prototype.move\n   */\n  doMove = warnOnce(function (this: Interaction, signalArg: any) {\n    this.move(signalArg)\n  }, 'The interaction.doMove() method has been renamed to interaction.move()')\n\n  coords: CoordsSet = {\n    // Starting InteractEvent pointer coordinates\n    start: pointerUtils.newCoords(),\n    // Previous native pointer move event coordinates\n    prev: pointerUtils.newCoords(),\n    // current native pointer move event coordinates\n    cur: pointerUtils.newCoords(),\n    // Change in coordinates and time of the pointer\n    delta: pointerUtils.newCoords(),\n    // pointer velocity\n    velocity: pointerUtils.newCoords(),\n  }\n\n  readonly _id: number = idCounter++\n\n  /** */\n  constructor ({ pointerType, scopeFire }: { pointerType?: string, scopeFire: Scope['fire'] }) {\n    this._scopeFire = scopeFire\n    this.pointerType = pointerType\n\n    const that = this\n\n    this._proxy = {} as InteractionProxy<T>\n\n    for (const key in _ProxyValues) {\n      Object.defineProperty(this._proxy, key, {\n        get () {\n          return that[key]\n        },\n      })\n    }\n\n    for (const key in _ProxyMethods) {\n      Object.defineProperty(this._proxy, key, {\n        value: (...args: any[]) => that[key](...args),\n      })\n    }\n\n    this._scopeFire('interactions:new', { interaction: this })\n  }\n\n  pointerDown (pointer: PointerType, event: PointerEventType, eventTarget: Node) {\n    const pointerIndex = this.updatePointer(pointer, event, eventTarget, true)\n    const pointerInfo = this.pointers[pointerIndex]\n\n    this._scopeFire('interactions:down', {\n      pointer,\n      event,\n      eventTarget,\n      pointerIndex,\n      pointerInfo,\n      type: 'down',\n      interaction: (this as unknown) as Interaction<never>,\n    })\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable({\n   *     // disable the default drag start by down->move\n   *     manualStart: true\n   *   })\n   *   // start dragging after the user holds the pointer down\n   *   .on('hold', function (event) {\n   *     var interaction = event.interaction\n   *\n   *     if (!interaction.interacting()) {\n   *       interaction.start({ name: 'drag' },\n   *                         event.interactable,\n   *                         event.currentTarget)\n   *     }\n   * })\n   * ```\n   *\n   * Start an action with the given Interactable and Element as tartgets. The\n   * action must be enabled for the target Interactable and an appropriate\n   * number of pointers must be held down - 1 for drag/resize, 2 for gesture.\n   *\n   * Use it with `interactable.<action>able({ manualStart: false })` to always\n   * [start actions manually](https://github.com/taye/interact.js/issues/114)\n   *\n   * @param {object} action   The action to be performed - drag, resize, etc.\n   * @param {Interactable} target  The Interactable to target\n   * @param {Element} element The DOM Element to target\n   * @return {Boolean} Whether the interaction was successfully started\n   */\n  start<A extends ActionName> (action: ActionProps<A>, interactable: Interactable, element: Element): boolean {\n    if (\n      this.interacting() ||\n      !this.pointerIsDown ||\n      this.pointers.length < (action.name === 'gesture' ? 2 : 1) ||\n      !interactable.options[action.name as keyof ActionDefaults].enabled\n    ) {\n      return false\n    }\n\n    copyAction(this.prepared, action)\n\n    this.interactable = interactable\n    this.element = element\n    this.rect = interactable.getRect(element)\n    this.edges = this.prepared.edges\n      ? extend({}, this.prepared.edges)\n      : { left: true, right: true, top: true, bottom: true }\n    this._stopped = false\n    this._interacting =\n      this._doPhase({\n        interaction: this,\n        event: this.downEvent,\n        phase: 'start',\n      }) && !this._stopped\n\n    return this._interacting\n  }\n\n  pointerMove (pointer: PointerType, event: PointerEventType, eventTarget: Node) {\n    if (!this.simulation && !(this.modification && this.modification.endResult)) {\n      this.updatePointer(pointer, event, eventTarget, false)\n    }\n\n    const duplicateMove =\n      this.coords.cur.page.x === this.coords.prev.page.x &&\n      this.coords.cur.page.y === this.coords.prev.page.y &&\n      this.coords.cur.client.x === this.coords.prev.client.x &&\n      this.coords.cur.client.y === this.coords.prev.client.y\n\n    let dx: number\n    let dy: number\n\n    // register movement greater than pointerMoveTolerance\n    if (this.pointerIsDown && !this.pointerWasMoved) {\n      dx = this.coords.cur.client.x - this.coords.start.client.x\n      dy = this.coords.cur.client.y - this.coords.start.client.y\n\n      this.pointerWasMoved = hypot(dx, dy) > this.pointerMoveTolerance\n    }\n\n    const pointerIndex = this.getPointerIndex(pointer)\n    const signalArg = {\n      pointer,\n      pointerIndex,\n      pointerInfo: this.pointers[pointerIndex],\n      event,\n      type: 'move' as const,\n      eventTarget,\n      dx,\n      dy,\n      duplicate: duplicateMove,\n      interaction: (this as unknown) as Interaction<never>,\n    }\n\n    if (!duplicateMove) {\n      // set pointer coordinate, time changes and velocity\n      pointerUtils.setCoordVelocity(this.coords.velocity, this.coords.delta)\n    }\n\n    this._scopeFire('interactions:move', signalArg)\n\n    if (!duplicateMove && !this.simulation) {\n      // if interacting, fire an 'action-move' signal etc\n      if (this.interacting()) {\n        signalArg.type = null\n        this.move(signalArg)\n      }\n\n      if (this.pointerWasMoved) {\n        pointerUtils.copyCoords(this.coords.prev, this.coords.cur)\n      }\n    }\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable(true)\n   *   .on('dragmove', function (event) {\n   *     if (someCondition) {\n   *       // change the snap settings\n   *       event.interactable.draggable({ snap: { targets: [] }})\n   *       // fire another move event with re-calculated snap\n   *       event.interaction.move()\n   *     }\n   *   })\n   * ```\n   *\n   * Force a move of the current action at the same coordinates. Useful if\n   * snap/restrict has been changed and you want a movement with the new\n   * settings.\n   */\n  move (signalArg?: any) {\n    if (!signalArg || !signalArg.event) {\n      pointerUtils.setZeroCoords(this.coords.delta)\n    }\n\n    signalArg = extend(\n      {\n        pointer: this._latestPointer.pointer,\n        event: this._latestPointer.event,\n        eventTarget: this._latestPointer.eventTarget,\n        interaction: this,\n      },\n      signalArg || {},\n    )\n\n    signalArg.phase = 'move'\n\n    this._doPhase(signalArg)\n  }\n\n  // End interact move events and stop auto-scroll unless simulation is running\n  pointerUp (pointer: PointerType, event: PointerEventType, eventTarget: Node, curEventTarget: EventTarget) {\n    let pointerIndex = this.getPointerIndex(pointer)\n\n    if (pointerIndex === -1) {\n      pointerIndex = this.updatePointer(pointer, event, eventTarget, false)\n    }\n\n    const type = /cancel$/i.test(event.type) ? 'cancel' : 'up'\n\n    this._scopeFire(`interactions:${type}` as 'interactions:up' | 'interactions:cancel', {\n      pointer,\n      pointerIndex,\n      pointerInfo: this.pointers[pointerIndex],\n      event,\n      eventTarget,\n      type: type as any,\n      curEventTarget,\n      interaction: (this as unknown) as Interaction<never>,\n    })\n\n    if (!this.simulation) {\n      this.end(event)\n    }\n\n    this.removePointer(pointer, event)\n  }\n\n  documentBlur (event: Event) {\n    this.end(event as any)\n    this._scopeFire('interactions:blur', {\n      event,\n      type: 'blur',\n      interaction: (this as unknown) as Interaction<never>,\n    })\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable(true)\n   *   .on('move', function (event) {\n   *     if (event.pageX > 1000) {\n   *       // end the current action\n   *       event.interaction.end()\n   *       // stop all further listeners from being called\n   *       event.stopImmediatePropagation()\n   *     }\n   *   })\n   * ```\n   *\n   * @param {PointerEvent} [event]\n   */\n  end (event?: PointerEventType) {\n    this._ending = true\n    event = event || this._latestPointer.event\n    let endPhaseResult: boolean\n\n    if (this.interacting()) {\n      endPhaseResult = this._doPhase({\n        event,\n        interaction: this,\n        phase: 'end',\n      })\n    }\n\n    this._ending = false\n\n    if (endPhaseResult === true) {\n      this.stop()\n    }\n  }\n\n  currentAction () {\n    return this._interacting ? this.prepared.name : null\n  }\n\n  interacting () {\n    return this._interacting\n  }\n\n  /** */\n  stop () {\n    this._scopeFire('interactions:stop', { interaction: this })\n\n    this.interactable = this.element = null\n\n    this._interacting = false\n    this._stopped = true\n    this.prepared.name = this.prevEvent = null\n  }\n\n  getPointerIndex (pointer: PointerType) {\n    const pointerId = pointerUtils.getPointerId(pointer)\n\n    // mouse and pen interactions may have only one pointer\n    return this.pointerType === 'mouse' || this.pointerType === 'pen'\n      ? this.pointers.length - 1\n      : arr.findIndex(this.pointers, (curPointer) => curPointer.id === pointerId)\n  }\n\n  getPointerInfo (pointer: any) {\n    return this.pointers[this.getPointerIndex(pointer)]\n  }\n\n  updatePointer (pointer: PointerType, event: PointerEventType, eventTarget: Node, down?: boolean) {\n    const id = pointerUtils.getPointerId(pointer)\n    let pointerIndex = this.getPointerIndex(pointer)\n    let pointerInfo = this.pointers[pointerIndex]\n\n    down = down === false ? false : down || /(down|start)$/i.test(event.type)\n\n    if (!pointerInfo) {\n      pointerInfo = new PointerInfo(id, pointer, event, null, null)\n\n      pointerIndex = this.pointers.length\n      this.pointers.push(pointerInfo)\n    } else {\n      pointerInfo.pointer = pointer\n    }\n\n    pointerUtils.setCoords(\n      this.coords.cur,\n      this.pointers.map((p) => p.pointer),\n      this._now(),\n    )\n    pointerUtils.setCoordDeltas(this.coords.delta, this.coords.prev, this.coords.cur)\n\n    if (down) {\n      this.pointerIsDown = true\n\n      pointerInfo.downTime = this.coords.cur.timeStamp\n      pointerInfo.downTarget = eventTarget\n      pointerUtils.pointerExtend(this.downPointer, pointer)\n\n      if (!this.interacting()) {\n        pointerUtils.copyCoords(this.coords.start, this.coords.cur)\n        pointerUtils.copyCoords(this.coords.prev, this.coords.cur)\n\n        this.downEvent = event\n        this.pointerWasMoved = false\n      }\n    }\n\n    this._updateLatestPointer(pointer, event, eventTarget)\n\n    this._scopeFire('interactions:update-pointer', {\n      pointer,\n      event,\n      eventTarget,\n      down,\n      pointerInfo,\n      pointerIndex,\n      interaction: (this as unknown) as Interaction<never>,\n    })\n\n    return pointerIndex\n  }\n\n  removePointer (pointer: PointerType, event: PointerEventType) {\n    const pointerIndex = this.getPointerIndex(pointer)\n\n    if (pointerIndex === -1) return\n\n    const pointerInfo = this.pointers[pointerIndex]\n\n    this._scopeFire('interactions:remove-pointer', {\n      pointer,\n      event,\n      eventTarget: null,\n      pointerIndex,\n      pointerInfo,\n      interaction: (this as unknown) as Interaction<never>,\n    })\n\n    this.pointers.splice(pointerIndex, 1)\n    this.pointerIsDown = false\n  }\n\n  _updateLatestPointer (pointer: PointerType, event: PointerEventType, eventTarget: Node) {\n    this._latestPointer.pointer = pointer\n    this._latestPointer.event = event\n    this._latestPointer.eventTarget = eventTarget\n  }\n\n  destroy () {\n    this._latestPointer.pointer = null\n    this._latestPointer.event = null\n    this._latestPointer.eventTarget = null\n  }\n\n  _createPreparedEvent<P extends EventPhase> (\n    event: PointerEventType,\n    phase: P,\n    preEnd?: boolean,\n    type?: string,\n  ) {\n    return new InteractEvent<T, P>(this, event, this.prepared.name, phase, this.element, preEnd, type)\n  }\n\n  _fireEvent<P extends EventPhase> (iEvent: InteractEvent<T, P>) {\n    this.interactable.fire(iEvent)\n\n    if (!this.prevEvent || iEvent.timeStamp >= this.prevEvent.timeStamp) {\n      this.prevEvent = iEvent\n    }\n  }\n\n  _doPhase<P extends EventPhase> (\n    signalArg: Omit<DoPhaseArg<T, P>, 'iEvent'> & { iEvent?: InteractEvent<T, P> },\n  ) {\n    const { event, phase, preEnd, type } = signalArg\n    const { rect } = this\n\n    if (rect && phase === 'move') {\n      // update the rect changes due to pointer move\n      rectUtils.addEdges(this.edges, rect, this.coords.delta[this.interactable.options.deltaSource])\n\n      rect.width = rect.right - rect.left\n      rect.height = rect.bottom - rect.top\n    }\n\n    const beforeResult = this._scopeFire(`interactions:before-action-${phase}` as any, signalArg)\n\n    if (beforeResult === false) {\n      return false\n    }\n\n    const iEvent = (signalArg.iEvent = this._createPreparedEvent(event, phase, preEnd, type))\n\n    this._scopeFire(`interactions:action-${phase}` as any, signalArg)\n\n    if (phase === 'start') {\n      this.prevEvent = iEvent\n    }\n\n    this._fireEvent(iEvent)\n\n    this._scopeFire(`interactions:after-action-${phase}` as any, signalArg)\n\n    return true\n  }\n\n  _now () {\n    return Date.now()\n  }\n}\n\nexport default Interaction\nexport { PointerInfo }\n","import type Interaction from '@interactjs/core/Interaction'\nimport { _ProxyMethods } from '@interactjs/core/Interaction'\nimport type { Plugin } from '@interactjs/core/scope'\nimport type { Point } from '@interactjs/types/index'\nimport * as rectUtils from '@interactjs/utils/rect'\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    offsetBy?: typeof offsetBy\n    offset: {\n      total: Point\n      pending: Point\n    }\n  }\n\n  enum _ProxyMethods {\n    offsetBy = '',\n  }\n}\n\n;(_ProxyMethods as any).offsetBy = ''\n\nexport function addTotal (interaction: Interaction) {\n  if (!interaction.pointerIsDown) {\n    return\n  }\n\n  addToCoords(interaction.coords.cur, interaction.offset.total)\n\n  interaction.offset.pending.x = 0\n  interaction.offset.pending.y = 0\n}\n\nfunction beforeAction ({ interaction }: { interaction: Interaction }) {\n  applyPending(interaction)\n}\n\nfunction beforeEnd ({ interaction }: { interaction: Interaction }): boolean | void {\n  const hadPending = applyPending(interaction)\n\n  if (!hadPending) return\n\n  interaction.move({ offset: true })\n  interaction.end()\n\n  return false\n}\n\nfunction end ({ interaction }: { interaction: Interaction }) {\n  interaction.offset.total.x = 0\n  interaction.offset.total.y = 0\n  interaction.offset.pending.x = 0\n  interaction.offset.pending.y = 0\n}\n\nexport function applyPending (interaction: Interaction) {\n  if (!hasPending(interaction)) {\n    return false\n  }\n\n  const { pending } = interaction.offset\n\n  addToCoords(interaction.coords.cur, pending)\n  addToCoords(interaction.coords.delta, pending)\n  rectUtils.addEdges(interaction.edges, interaction.rect, pending)\n\n  pending.x = 0\n  pending.y = 0\n\n  return true\n}\n\nfunction offsetBy (this: Interaction, { x, y }: Point) {\n  this.offset.pending.x += x\n  this.offset.pending.y += y\n\n  this.offset.total.x += x\n  this.offset.total.y += y\n}\n\nfunction addToCoords ({ page, client }, { x, y }: Point) {\n  page.x += x\n  page.y += y\n  client.x += x\n  client.y += y\n}\n\nfunction hasPending (interaction: Interaction) {\n  return !!(interaction.offset.pending.x || interaction.offset.pending.y)\n}\n\nconst offset: Plugin = {\n  id: 'offset',\n  before: ['modifiers', 'pointer-events', 'actions', 'inertia'],\n  install (scope) {\n    scope.Interaction.prototype.offsetBy = offsetBy\n  },\n  listeners: {\n    'interactions:new': ({ interaction }) => {\n      interaction.offset = {\n        total: { x: 0, y: 0 },\n        pending: { x: 0, y: 0 },\n      }\n    },\n    'interactions:update-pointer': ({ interaction }) => addTotal(interaction),\n    'interactions:before-action-start': beforeAction,\n    'interactions:before-action-move': beforeAction,\n    'interactions:before-action-end': beforeEnd,\n    'interactions:stop': end,\n  },\n}\n\nexport default offset\n","import type { Interaction, DoPhaseArg } from '@interactjs/core/Interaction'\nimport type { ActionName, Scope, SignalArgs, Plugin } from '@interactjs/core/scope'\nimport Modification from '@interactjs/modifiers/Modification'\nimport * as modifiers from '@interactjs/modifiers/base'\nimport offset from '@interactjs/offset/plugin'\nimport type { Point, PointerEventType } from '@interactjs/types/index'\nimport * as dom from '@interactjs/utils/domUtils'\nimport hypot from '@interactjs/utils/hypot'\nimport is from '@interactjs/utils/is'\nimport { copyCoords } from '@interactjs/utils/pointerUtils'\nimport raf from '@interactjs/utils/raf'\n\ndeclare module '@interactjs/core/InteractEvent' {\n  interface PhaseMap {\n    resume?: true\n    inertiastart?: true\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    inertia?: InertiaState\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface PerActionDefaults {\n    inertia?: {\n      enabled?: boolean\n      resistance?: number // the lambda in exponential decay\n      minSpeed?: number // target speed must be above this for inertia to start\n      endSpeed?: number // the speed at which inertia is slow enough to stop\n      allowResume?: true // allow resuming an action in inertia phase\n      smoothEndDuration?: number // animate to snap/restrict endOnly if there's no inertia\n    }\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactions:before-action-inertiastart': Omit<DoPhaseArg<ActionName, 'inertiastart'>, 'iEvent'>\n    'interactions:action-inertiastart': DoPhaseArg<ActionName, 'inertiastart'>\n    'interactions:after-action-inertiastart': DoPhaseArg<ActionName, 'inertiastart'>\n    'interactions:before-action-resume': Omit<DoPhaseArg<ActionName, 'resume'>, 'iEvent'>\n    'interactions:action-resume': DoPhaseArg<ActionName, 'resume'>\n    'interactions:after-action-resume': DoPhaseArg<ActionName, 'resume'>\n  }\n}\n\nfunction install (scope: Scope) {\n  const { defaults } = scope\n\n  scope.usePlugin(offset)\n  scope.usePlugin(modifiers.default)\n  scope.actions.phases.inertiastart = true\n  scope.actions.phases.resume = true\n\n  defaults.perAction.inertia = {\n    enabled: false,\n    resistance: 10, // the lambda in exponential decay\n    minSpeed: 100, // target speed must be above this for inertia to start\n    endSpeed: 10, // the speed at which inertia is slow enough to stop\n    allowResume: true, // allow resuming an action in inertia phase\n    smoothEndDuration: 300, // animate to snap/restrict endOnly if there's no inertia\n  }\n}\n\nexport class InertiaState {\n  active = false\n  isModified = false\n  smoothEnd = false\n  allowResume = false\n\n  modification!: Modification\n  modifierCount = 0\n  modifierArg!: modifiers.ModifierArg\n\n  startCoords!: Point\n  t0 = 0\n  v0 = 0\n\n  te = 0\n  targetOffset!: Point\n  modifiedOffset!: Point\n  currentOffset!: Point\n\n  lambda_v0? = 0 // eslint-disable-line camelcase\n  one_ve_v0? = 0 // eslint-disable-line camelcase\n  timeout!: number\n  readonly interaction: Interaction\n\n  constructor (interaction: Interaction) {\n    this.interaction = interaction\n  }\n\n  start (event: PointerEventType) {\n    const { interaction } = this\n    const options = getOptions(interaction)\n\n    if (!options || !options.enabled) {\n      return false\n    }\n\n    const { client: velocityClient } = interaction.coords.velocity\n    const pointerSpeed = hypot(velocityClient.x, velocityClient.y)\n    const modification = this.modification || (this.modification = new Modification(interaction))\n\n    modification.copyFrom(interaction.modification)\n\n    this.t0 = interaction._now()\n    this.allowResume = options.allowResume\n    this.v0 = pointerSpeed\n    this.currentOffset = { x: 0, y: 0 }\n    this.startCoords = interaction.coords.cur.page\n\n    this.modifierArg = modification.fillArg({\n      pageCoords: this.startCoords,\n      preEnd: true,\n      phase: 'inertiastart',\n    })\n\n    const thrown =\n      this.t0 - interaction.coords.cur.timeStamp < 50 &&\n      pointerSpeed > options.minSpeed &&\n      pointerSpeed > options.endSpeed\n\n    if (thrown) {\n      this.startInertia()\n    } else {\n      modification.result = modification.setAll(this.modifierArg)\n\n      if (!modification.result.changed) {\n        return false\n      }\n\n      this.startSmoothEnd()\n    }\n\n    // force modification change\n    interaction.modification.result.rect = null\n\n    // bring inertiastart event to the target coords\n    interaction.offsetBy(this.targetOffset)\n    interaction._doPhase({\n      interaction,\n      event,\n      phase: 'inertiastart',\n    })\n    interaction.offsetBy({ x: -this.targetOffset.x, y: -this.targetOffset.y })\n    // force modification change\n    interaction.modification.result.rect = null\n\n    this.active = true\n    interaction.simulation = this\n\n    return true\n  }\n\n  startInertia () {\n    const startVelocity = this.interaction.coords.velocity.client\n    const options = getOptions(this.interaction)\n    const lambda = options.resistance\n    const inertiaDur = -Math.log(options.endSpeed / this.v0) / lambda\n\n    this.targetOffset = {\n      x: (startVelocity.x - inertiaDur) / lambda,\n      y: (startVelocity.y - inertiaDur) / lambda,\n    }\n\n    this.te = inertiaDur\n    this.lambda_v0 = lambda / this.v0\n    this.one_ve_v0 = 1 - options.endSpeed / this.v0\n\n    const { modification, modifierArg } = this\n\n    modifierArg.pageCoords = {\n      x: this.startCoords.x + this.targetOffset.x,\n      y: this.startCoords.y + this.targetOffset.y,\n    }\n\n    modification.result = modification.setAll(modifierArg)\n\n    if (modification.result.changed) {\n      this.isModified = true\n      this.modifiedOffset = {\n        x: this.targetOffset.x + modification.result.delta.x,\n        y: this.targetOffset.y + modification.result.delta.y,\n      }\n    }\n\n    this.onNextFrame(() => this.inertiaTick())\n  }\n\n  startSmoothEnd () {\n    this.smoothEnd = true\n    this.isModified = true\n    this.targetOffset = {\n      x: this.modification.result.delta.x,\n      y: this.modification.result.delta.y,\n    }\n\n    this.onNextFrame(() => this.smoothEndTick())\n  }\n\n  onNextFrame (tickFn: () => void) {\n    this.timeout = raf.request(() => {\n      if (this.active) {\n        tickFn()\n      }\n    })\n  }\n\n  inertiaTick () {\n    const { interaction } = this\n    const options = getOptions(interaction)\n    const lambda = options.resistance\n    const t = (interaction._now() - this.t0) / 1000\n\n    if (t < this.te) {\n      const progress = 1 - (Math.exp(-lambda * t) - this.lambda_v0) / this.one_ve_v0\n      let newOffset: Point\n\n      if (this.isModified) {\n        newOffset = getQuadraticCurvePoint(\n          0,\n          0,\n          this.targetOffset.x,\n          this.targetOffset.y,\n          this.modifiedOffset.x,\n          this.modifiedOffset.y,\n          progress,\n        )\n      } else {\n        newOffset = {\n          x: this.targetOffset.x * progress,\n          y: this.targetOffset.y * progress,\n        }\n      }\n\n      const delta = { x: newOffset.x - this.currentOffset.x, y: newOffset.y - this.currentOffset.y }\n\n      this.currentOffset.x += delta.x\n      this.currentOffset.y += delta.y\n\n      interaction.offsetBy(delta)\n      interaction.move()\n\n      this.onNextFrame(() => this.inertiaTick())\n    } else {\n      interaction.offsetBy({\n        x: this.modifiedOffset.x - this.currentOffset.x,\n        y: this.modifiedOffset.y - this.currentOffset.y,\n      })\n\n      this.end()\n    }\n  }\n\n  smoothEndTick () {\n    const { interaction } = this\n    const t = interaction._now() - this.t0\n    const { smoothEndDuration: duration } = getOptions(interaction)\n\n    if (t < duration) {\n      const newOffset = {\n        x: easeOutQuad(t, 0, this.targetOffset.x, duration),\n        y: easeOutQuad(t, 0, this.targetOffset.y, duration),\n      }\n      const delta = {\n        x: newOffset.x - this.currentOffset.x,\n        y: newOffset.y - this.currentOffset.y,\n      }\n\n      this.currentOffset.x += delta.x\n      this.currentOffset.y += delta.y\n\n      interaction.offsetBy(delta)\n      interaction.move({ skipModifiers: this.modifierCount })\n\n      this.onNextFrame(() => this.smoothEndTick())\n    } else {\n      interaction.offsetBy({\n        x: this.targetOffset.x - this.currentOffset.x,\n        y: this.targetOffset.y - this.currentOffset.y,\n      })\n\n      this.end()\n    }\n  }\n\n  resume ({ pointer, event, eventTarget }: SignalArgs['interactions:down']) {\n    const { interaction } = this\n\n    // undo inertia changes to interaction coords\n    interaction.offsetBy({\n      x: -this.currentOffset.x,\n      y: -this.currentOffset.y,\n    })\n\n    // update pointer at pointer down position\n    interaction.updatePointer(pointer, event, eventTarget, true)\n\n    // fire resume signals and event\n    interaction._doPhase({\n      interaction,\n      event,\n      phase: 'resume',\n    })\n    copyCoords(interaction.coords.prev, interaction.coords.cur)\n\n    this.stop()\n  }\n\n  end () {\n    this.interaction.move()\n    this.interaction.end()\n    this.stop()\n  }\n\n  stop () {\n    this.active = this.smoothEnd = false\n    this.interaction.simulation = null\n    raf.cancel(this.timeout)\n  }\n}\n\nfunction start ({ interaction, event }: DoPhaseArg<ActionName, 'end'>) {\n  if (!interaction._interacting || interaction.simulation) {\n    return null\n  }\n\n  const started = interaction.inertia.start(event)\n\n  // prevent action end if inertia or smoothEnd\n  return started ? false : null\n}\n\n// Check if the down event hits the current inertia target\n// control should be return to the user\nfunction resume (arg: SignalArgs['interactions:down']) {\n  const { interaction, eventTarget } = arg\n  const state = interaction.inertia\n\n  if (!state.active) return\n\n  let element = eventTarget as Node\n\n  // climb up the DOM tree from the event target\n  while (is.element(element)) {\n    // if interaction element is the current inertia target element\n    if (element === interaction.element) {\n      state.resume(arg)\n      break\n    }\n\n    element = dom.parentNode(element)\n  }\n}\n\nfunction stop ({ interaction }: { interaction: Interaction }) {\n  const state = interaction.inertia\n\n  if (state.active) {\n    state.stop()\n  }\n}\n\nfunction getOptions ({ interactable, prepared }: Interaction) {\n  return interactable && interactable.options && prepared.name && interactable.options[prepared.name].inertia\n}\n\nconst inertia: Plugin = {\n  id: 'inertia',\n  before: ['modifiers', 'actions'],\n  install,\n  listeners: {\n    'interactions:new': ({ interaction }) => {\n      interaction.inertia = new InertiaState(interaction)\n    },\n\n    'interactions:before-action-end': start,\n    'interactions:down': resume,\n    'interactions:stop': stop,\n\n    'interactions:before-action-resume': (arg) => {\n      const { modification } = arg.interaction\n\n      modification.stop(arg)\n      modification.start(arg, arg.interaction.coords.cur.page)\n      modification.applyToInteraction(arg)\n    },\n\n    'interactions:before-action-inertiastart': (arg) => arg.interaction.modification.setAndApply(arg),\n    'interactions:action-resume': modifiers.addEventModifiers,\n    'interactions:action-inertiastart': modifiers.addEventModifiers,\n    'interactions:after-action-inertiastart': (arg) =>\n      arg.interaction.modification.restoreInteractionCoords(arg),\n    'interactions:after-action-resume': (arg) => arg.interaction.modification.restoreInteractionCoords(arg),\n  },\n}\n\n// http://stackoverflow.com/a/5634528/2280888\nfunction _getQBezierValue (t: number, p1: number, p2: number, p3: number) {\n  const iT = 1 - t\n  return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3\n}\n\nfunction getQuadraticCurvePoint (\n  startX: number,\n  startY: number,\n  cpX: number,\n  cpY: number,\n  endX: number,\n  endY: number,\n  position: number,\n) {\n  return {\n    x: _getQBezierValue(position, startX, cpX, endX),\n    y: _getQBezierValue(position, startY, cpY, endY),\n  }\n}\n\n// http://gizma.com/easing/\nfunction easeOutQuad (t: number, b: number, c: number, d: number) {\n  t /= d\n  return -c * t * (t - 2) + b\n}\n\nexport default inertia\n","import type { Listener, ListenersArg, Rect } from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\nimport extend from '@interactjs/utils/extend'\nimport type { NormalizedListeners } from '@interactjs/utils/normalizeListeners'\nimport normalize from '@interactjs/utils/normalizeListeners'\n\nfunction fireUntilImmediateStopped (event: any, listeners: Listener[]) {\n  for (const listener of listeners) {\n    if (event.immediatePropagationStopped) {\n      break\n    }\n\n    listener(event)\n  }\n}\n\nexport class Eventable {\n  options: any\n  types: NormalizedListeners = {}\n  propagationStopped = false\n  immediatePropagationStopped = false\n  global: any\n\n  constructor (options?: { [index: string]: any }) {\n    this.options = extend({}, options || {})\n  }\n\n  fire<T extends { type: string, propagationStopped?: boolean }> (event: T) {\n    let listeners: Listener[]\n    const global = this.global\n\n    // Interactable#on() listeners\n    // tslint:disable no-conditional-assignment\n    if ((listeners = this.types[event.type])) {\n      fireUntilImmediateStopped(event, listeners)\n    }\n\n    // interact.on() listeners\n    if (!event.propagationStopped && global && (listeners = global[event.type])) {\n      fireUntilImmediateStopped(event, listeners)\n    }\n  }\n\n  on (type: string, listener: ListenersArg) {\n    const listeners = normalize(type, listener)\n\n    for (type in listeners) {\n      this.types[type] = arr.merge(this.types[type] || [], listeners[type])\n    }\n  }\n\n  off (type: string, listener: ListenersArg) {\n    const listeners = normalize(type, listener)\n\n    for (type in listeners) {\n      const eventList = this.types[type]\n\n      if (!eventList || !eventList.length) {\n        continue\n      }\n\n      for (const subListener of listeners[type]) {\n        const index = eventList.indexOf(subListener)\n\n        if (index !== -1) {\n          eventList.splice(index, 1)\n        }\n      }\n    }\n  }\n\n  getRect (_element: Element): Rect {\n    return null\n  }\n}\n","import type { Actions } from '@interactjs/core/scope'\n\nexport default function isNonNativeEvent (type: string, actions: Actions) {\n  if (actions.phaselessTypes[type]) {\n    return true\n  }\n\n  for (const name in actions.map) {\n    if (type.indexOf(name) === 0 && type.substr(name.length) in actions.phases) {\n      return true\n    }\n  }\n\n  return false\n}\n","/** @module interact */\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type { Context, EventTypes, Listener, ListenersArg, Target, Element } from '@interactjs/types/index'\nimport browser from '@interactjs/utils/browser'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport is from '@interactjs/utils/is'\nimport { warnOnce } from '@interactjs/utils/misc'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nimport type { Interactable } from './Interactable'\nimport isNonNativeEvent from './isNonNativeEvent'\nimport type { Options } from './options'\n\ndeclare module '@interactjs/core/InteractStatic' {\n  export interface InteractStatic {\n    (target: Target, options?: Options): Interactable\n    getPointerAverage: typeof pointerUtils.pointerAverage\n    getTouchBBox: typeof pointerUtils.touchBBox\n    getTouchDistance: typeof pointerUtils.touchDistance\n    getTouchAngle: typeof pointerUtils.touchAngle\n    getElementRect: typeof domUtils.getElementRect\n    getElementClientRect: typeof domUtils.getElementClientRect\n    matchesSelector: typeof domUtils.matchesSelector\n    closest: typeof domUtils.closest\n    /** @internal */ globalEvents: any\n    version: string\n    /** @internal */ scope: Scope\n    use(\n      plugin: Plugin,\n      options?: {\n        [key: string]: any\n      },\n    ): any\n    isSet(target: Element, options?: any): boolean\n    on(type: string | EventTypes, listener: ListenersArg, options?: object): any\n    off(type: EventTypes, listener: any, options?: object): any\n    debug(): any\n    supportsTouch(): boolean\n    supportsPointerEvent(): boolean\n    stop(): any\n    pointerMoveTolerance(newValue?: number): any\n    addDocument(doc: Document, options?: object): void\n    removeDocument(doc: Document): void\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/consistent-type-imports\ntype _InteractStatic = import('@interactjs/core/InteractStatic').InteractStatic\n\nexport function createInteractStatic (scope: Scope): _InteractStatic {\n  /**\n   * ```js\n   * interact('#draggable').draggable(true)\n   *\n   * var rectables = interact('rect')\n   * rectables\n   *   .gesturable(true)\n   *   .on('gesturemove', function (event) {\n   *       // ...\n   *   })\n   * ```\n   *\n   * The methods of this variable can be used to set elements as interactables\n   * and also to change various default settings.\n   *\n   * Calling it as a function and passing an element or a valid CSS selector\n   * string returns an Interactable object which has various methods to configure\n   * it.\n   *\n   * @global\n   *\n   * @param {Element | string} target The HTML or SVG Element to interact with\n   * or CSS selector\n   * @return {Interactable}\n   */\n  const interact = ((target: Target, options: Options) => {\n    let interactable = scope.interactables.get(target, options)\n\n    if (!interactable) {\n      interactable = scope.interactables.new(target, options)\n      interactable.events.global = interact.globalEvents\n    }\n\n    return interactable\n  }) as _InteractStatic\n\n  // expose the functions used to calculate multi-touch properties\n  interact.getPointerAverage = pointerUtils.pointerAverage\n  interact.getTouchBBox = pointerUtils.touchBBox\n  interact.getTouchDistance = pointerUtils.touchDistance\n  interact.getTouchAngle = pointerUtils.touchAngle\n\n  interact.getElementRect = domUtils.getElementRect\n  interact.getElementClientRect = domUtils.getElementClientRect\n  interact.matchesSelector = domUtils.matchesSelector\n  interact.closest = domUtils.closest\n\n  interact.globalEvents = {} as any\n\n  // eslint-disable-next-line no-undef\n  interact.version = process.env.npm_package_version\n  interact.scope = scope\n  /**\n   * Use a plugin\n   *\n   * @alias module:interact.use\n   *\n   */\n  interact.use = function (plugin, options) {\n    this.scope.usePlugin(plugin, options)\n\n    return this\n  }\n\n  /**\n   * Check if an element or selector has been set with the {@link interact}\n   * function\n   *\n   * @alias module:interact.isSet\n   *\n   * @param {Target} target The Element or string being searched for\n   * @param {object} options\n   * @return {boolean} Indicates if the element or CSS selector was previously\n   * passed to interact\n   */\n  interact.isSet = function (target: Target, options?: { context?: Context }): boolean {\n    return !!this.scope.interactables.get(target, options && options.context)\n  }\n\n  /**\n   * @deprecated\n   * Add a global listener for an InteractEvent or adds a DOM event to `document`\n   *\n   * @alias module:interact.on\n   *\n   * @param {string | array | object} type The types of events to listen for\n   * @param {function} listener The function event (s)\n   * @param {object | boolean} [options] object or useCapture flag for\n   * addEventListener\n   * @return {object} interact\n   */\n  interact.on = warnOnce(function on (type: string | EventTypes, listener: ListenersArg, options?: object) {\n    if (is.string(type) && type.search(' ') !== -1) {\n      type = type.trim().split(/ +/)\n    }\n\n    if (is.array(type)) {\n      for (const eventType of type as any[]) {\n        this.on(eventType, listener, options)\n      }\n\n      return this\n    }\n\n    if (is.object(type)) {\n      for (const prop in type) {\n        this.on(prop, (type as any)[prop], listener)\n      }\n\n      return this\n    }\n\n    // if it is an InteractEvent type, add listener to globalEvents\n    if (isNonNativeEvent(type, this.scope.actions)) {\n      // if this type of event was never bound\n      if (!this.globalEvents[type]) {\n        this.globalEvents[type] = [listener]\n      } else {\n        this.globalEvents[type].push(listener)\n      }\n    }\n    // If non InteractEvent type, addEventListener to document\n    else {\n      this.scope.events.add(this.scope.document, type, listener as Listener, { options })\n    }\n\n    return this\n  }, 'The interact.on() method is being deprecated')\n\n  /**\n   * @deprecated\n   * Removes a global InteractEvent listener or DOM event from `document`\n   *\n   * @alias module:interact.off\n   *\n   * @param {string | array | object} type The types of events that were listened\n   * for\n   * @param {function} listener The listener function to be removed\n   * @param {object | boolean} options [options] object or useCapture flag for\n   * removeEventListener\n   * @return {object} interact\n   */\n  interact.off = warnOnce(function off (type: EventTypes, listener: any, options?: object) {\n    if (is.string(type) && type.search(' ') !== -1) {\n      type = type.trim().split(/ +/)\n    }\n\n    if (is.array(type)) {\n      for (const eventType of type) {\n        this.off(eventType, listener, options)\n      }\n\n      return this\n    }\n\n    if (is.object(type)) {\n      for (const prop in type) {\n        this.off(prop, type[prop], listener)\n      }\n\n      return this\n    }\n\n    if (isNonNativeEvent(type, this.scope.actions)) {\n      let index: number\n\n      if (type in this.globalEvents && (index = this.globalEvents[type].indexOf(listener)) !== -1) {\n        this.globalEvents[type].splice(index, 1)\n      }\n    } else {\n      this.scope.events.remove(this.scope.document, type, listener, options)\n    }\n\n    return this\n  }, 'The interact.off() method is being deprecated')\n\n  interact.debug = function () {\n    return this.scope\n  }\n\n  /**\n   * @alias module:interact.supportsTouch\n   *\n   * @return {boolean} Whether or not the browser supports touch input\n   */\n  interact.supportsTouch = function () {\n    return browser.supportsTouch\n  }\n\n  /**\n   * @alias module:interact.supportsPointerEvent\n   *\n   * @return {boolean} Whether or not the browser supports PointerEvents\n   */\n  interact.supportsPointerEvent = function () {\n    return browser.supportsPointerEvent\n  }\n\n  /**\n   * Cancels all interactions (end events are not fired)\n   *\n   * @alias module:interact.stop\n   *\n   * @return {object} interact\n   */\n  interact.stop = function () {\n    for (const interaction of this.scope.interactions.list) {\n      interaction.stop()\n    }\n\n    return this\n  }\n\n  /**\n   * Returns or sets the distance the pointer must be moved before an action\n   * sequence occurs. This also affects tolerance for tap events.\n   *\n   * @alias module:interact.pointerMoveTolerance\n   *\n   * @param {number} [newValue] The movement from the start position must be greater than this value\n   * @return {interact | number}\n   */\n  interact.pointerMoveTolerance = function (newValue?: number) {\n    if (is.number(newValue)) {\n      this.scope.interactions.pointerMoveTolerance = newValue\n\n      return this\n    }\n\n    return this.scope.interactions.pointerMoveTolerance\n  }\n\n  interact.addDocument = function (doc: Document, options?: object) {\n    this.scope.addDocument(doc, options)\n  }\n\n  interact.removeDocument = function (doc: Document) {\n    this.scope.removeDocument(doc)\n  }\n\n  return interact\n}\n","/* eslint-disable no-dupe-class-members */\nimport type { ActionMap, ActionName, Actions, Scope } from '@interactjs/core/scope'\nimport type {\n  Context,\n  Element,\n  Target,\n  Listeners,\n  OrBoolean,\n  EventTypes,\n  ListenersArg,\n  ActionMethod,\n} from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\nimport browser from '@interactjs/utils/browser'\nimport clone from '@interactjs/utils/clone'\nimport { getElementRect, matchesUpTo, nodeContains, trySelector } from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport normalizeListeners from '@interactjs/utils/normalizeListeners'\nimport { getWindow } from '@interactjs/utils/window'\n\nimport { Eventable } from './Eventable'\nimport isNonNativeEvent from './isNonNativeEvent'\nimport type { ActionDefaults, Defaults, OptionsArg, PerActionDefaults } from './options'\nimport { Options } from './options'\n\ntype IgnoreValue = string | Element | boolean\ntype DeltaSource = 'page' | 'client'\n\n/** */\nexport class Interactable implements Partial<Eventable> {\n  /** @internal */ get _defaults (): Defaults {\n    return {\n      base: {},\n      perAction: {},\n      actions: {} as ActionDefaults,\n    }\n  }\n\n  readonly options!: Required<Options>\n  readonly _actions: Actions\n  readonly target: Target\n  readonly events = new Eventable()\n  readonly _context: Context\n  readonly _win: Window\n  readonly _doc: Document\n  readonly _scopeEvents: Scope['events']\n\n  /** @internal */ _rectChecker?: typeof Interactable.prototype.getRect\n\n  /** */\n  constructor (\n    target: Target,\n    options: any,\n    defaultContext: Document | Element,\n    scopeEvents: Scope['events'],\n  ) {\n    this._actions = options.actions\n    this.target = target\n    this._context = options.context || defaultContext\n    this._win = getWindow(trySelector(target) ? this._context : target)\n    this._doc = this._win.document\n    this._scopeEvents = scopeEvents\n\n    this.set(options)\n  }\n\n  setOnEvents (actionName: ActionName, phases: NonNullable<any>) {\n    if (is.func(phases.onstart)) {\n      this.on(`${actionName}start`, phases.onstart)\n    }\n    if (is.func(phases.onmove)) {\n      this.on(`${actionName}move`, phases.onmove)\n    }\n    if (is.func(phases.onend)) {\n      this.on(`${actionName}end`, phases.onend)\n    }\n    if (is.func(phases.oninertiastart)) {\n      this.on(`${actionName}inertiastart`, phases.oninertiastart)\n    }\n\n    return this\n  }\n\n  updatePerActionListeners (actionName: ActionName, prev: Listeners, cur: Listeners) {\n    if (is.array(prev) || is.object(prev)) {\n      this.off(actionName, prev)\n    }\n\n    if (is.array(cur) || is.object(cur)) {\n      this.on(actionName, cur)\n    }\n  }\n\n  setPerAction (actionName: ActionName, options: OrBoolean<Options>) {\n    const defaults = this._defaults\n\n    // for all the default per-action options\n    for (const optionName_ in options) {\n      const optionName = optionName_ as keyof PerActionDefaults\n      const actionOptions = this.options[actionName]\n      const optionValue: any = options[optionName]\n\n      // remove old event listeners and add new ones\n      if (optionName === 'listeners') {\n        this.updatePerActionListeners(actionName, actionOptions.listeners, optionValue as Listeners)\n      }\n\n      // if the option value is an array\n      if (is.array(optionValue)) {\n        ;(actionOptions[optionName] as any) = arr.from(optionValue)\n      }\n      // if the option value is an object\n      else if (is.plainObject(optionValue)) {\n        // copy the object\n        ;(actionOptions[optionName] as any) = extend(\n          actionOptions[optionName] || ({} as any),\n          clone(optionValue),\n        )\n\n        // set anabled field to true if it exists in the defaults\n        if (\n          is.object(defaults.perAction[optionName]) &&\n          'enabled' in (defaults.perAction[optionName] as any)\n        ) {\n          ;(actionOptions[optionName] as any).enabled = optionValue.enabled !== false\n        }\n      }\n      // if the option value is a boolean and the default is an object\n      else if (is.bool(optionValue) && is.object(defaults.perAction[optionName])) {\n        ;(actionOptions[optionName] as any).enabled = optionValue\n      }\n      // if it's anything else, do a plain assignment\n      else {\n        ;(actionOptions[optionName] as any) = optionValue\n      }\n    }\n  }\n\n  /**\n   * The default function to get an Interactables bounding rect. Can be\n   * overridden using {@link Interactable.rectChecker}.\n   *\n   * @param {Element} [element] The element to measure.\n   * @return {Rect} The object's bounding rectangle.\n   */\n  getRect (element: Element) {\n    element = element || (is.element(this.target) ? this.target : null)\n\n    if (is.string(this.target)) {\n      element = element || this._context.querySelector(this.target)\n    }\n\n    return getElementRect(element)\n  }\n\n  /**\n   * Returns or sets the function used to calculate the interactable's\n   * element's rectangle\n   *\n   * @param {function} [checker] A function which returns this Interactable's\n   * bounding rectangle. See {@link Interactable.getRect}\n   * @return {function | object} The checker function or this Interactable\n   */\n  rectChecker(): (element: Element) => any | null\n  rectChecker(checker: (element: Element) => any): this\n  rectChecker (checker?: (element: Element) => any) {\n    if (is.func(checker)) {\n      this._rectChecker = checker\n\n      this.getRect = (element) => {\n        const rect = extend({}, this._rectChecker(element))\n\n        if (!(('width' in rect) as unknown)) {\n          rect.width = rect.right - rect.left\n          rect.height = rect.bottom - rect.top\n        }\n\n        return rect\n      }\n\n      return this\n    }\n\n    if (checker === null) {\n      delete this.getRect\n      delete this._rectChecker\n\n      return this\n    }\n\n    return this.getRect\n  }\n\n  _backCompatOption (optionName: keyof Options, newValue: any) {\n    if (trySelector(newValue) || is.object(newValue)) {\n      ;(this.options[optionName] as any) = newValue\n\n      for (const action in this._actions.map) {\n        ;(this.options[action as keyof ActionMap] as any)[optionName] = newValue\n      }\n\n      return this\n    }\n\n    return this.options[optionName]\n  }\n\n  /**\n   * Gets or sets the origin of the Interactable's element.  The x and y\n   * of the origin will be subtracted from action event coordinates.\n   *\n   * @param {Element | object | string} [origin] An HTML or SVG Element whose\n   * rect will be used, an object eg. { x: 0, y: 0 } or string 'parent', 'self'\n   * or any CSS selector\n   *\n   * @return {object} The current origin or this Interactable\n   */\n  origin (newValue: any) {\n    return this._backCompatOption('origin', newValue)\n  }\n\n  /**\n   * Returns or sets the mouse coordinate types used to calculate the\n   * movement of the pointer.\n   *\n   * @param {string} [newValue] Use 'client' if you will be scrolling while\n   * interacting; Use 'page' if you want autoScroll to work\n   * @return {string | object} The current deltaSource or this Interactable\n   */\n  deltaSource(): DeltaSource\n  deltaSource(newValue: DeltaSource): this\n  deltaSource (newValue?: DeltaSource) {\n    if (newValue === 'page' || newValue === 'client') {\n      this.options.deltaSource = newValue\n\n      return this\n    }\n\n    return this.options.deltaSource\n  }\n\n  /**\n   * Gets the selector context Node of the Interactable. The default is\n   * `window.document`.\n   *\n   * @return {Node} The context Node of this Interactable\n   */\n  context () {\n    return this._context\n  }\n\n  inContext (element: Document | Node) {\n    return this._context === element.ownerDocument || nodeContains(this._context, element)\n  }\n\n  testIgnoreAllow (\n    this: Interactable,\n    options: { ignoreFrom?: IgnoreValue, allowFrom?: IgnoreValue },\n    targetNode: Node,\n    eventTarget: Node,\n  ) {\n    return (\n      !this.testIgnore(options.ignoreFrom, targetNode, eventTarget) &&\n      this.testAllow(options.allowFrom, targetNode, eventTarget)\n    )\n  }\n\n  testAllow (this: Interactable, allowFrom: IgnoreValue, targetNode: Node, element: Node) {\n    if (!allowFrom) {\n      return true\n    }\n\n    if (!is.element(element)) {\n      return false\n    }\n\n    if (is.string(allowFrom)) {\n      return matchesUpTo(element, allowFrom, targetNode)\n    } else if (is.element(allowFrom)) {\n      return nodeContains(allowFrom, element)\n    }\n\n    return false\n  }\n\n  testIgnore (this: Interactable, ignoreFrom: IgnoreValue, targetNode: Node, element: Node) {\n    if (!ignoreFrom || !is.element(element)) {\n      return false\n    }\n\n    if (is.string(ignoreFrom)) {\n      return matchesUpTo(element, ignoreFrom, targetNode)\n    } else if (is.element(ignoreFrom)) {\n      return nodeContains(ignoreFrom, element)\n    }\n\n    return false\n  }\n\n  /**\n   * Calls listeners for the given InteractEvent type bound globally\n   * and directly to this Interactable\n   *\n   * @param {InteractEvent} iEvent The InteractEvent object to be fired on this\n   * Interactable\n   * @return {Interactable} this Interactable\n   */\n  fire<E extends { type: string }> (iEvent: E) {\n    this.events.fire(iEvent)\n\n    return this\n  }\n\n  _onOff (method: 'on' | 'off', typeArg: EventTypes, listenerArg?: ListenersArg | null, options?: any) {\n    if (is.object(typeArg) && !is.array(typeArg)) {\n      options = listenerArg\n      listenerArg = null\n    }\n\n    const addRemove = method === 'on' ? 'add' : 'remove'\n    const listeners = normalizeListeners(typeArg, listenerArg)\n\n    for (let type in listeners) {\n      if (type === 'wheel') {\n        type = browser.wheelEvent\n      }\n\n      for (const listener of listeners[type]) {\n        // if it is an action event type\n        if (isNonNativeEvent(type, this._actions)) {\n          this.events[method](type, listener)\n        }\n        // delegated event\n        else if (is.string(this.target)) {\n          this._scopeEvents[`${addRemove}Delegate` as 'addDelegate' | 'removeDelegate'](\n            this.target,\n            this._context,\n            type,\n            listener,\n            options,\n          )\n        }\n        // remove listener from this Interactable's element\n        else {\n          this._scopeEvents[addRemove](this.target, type, listener, options)\n        }\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Binds a listener for an InteractEvent, pointerEvent or DOM event.\n   *\n   * @param {string | array | object} types The types of events to listen\n   * for\n   * @param {function | array | object} [listener] The event listener function(s)\n   * @param {object | boolean} [options] options object or useCapture flag for\n   * addEventListener\n   * @return {Interactable} This Interactable\n   */\n  on (types: EventTypes, listener?: ListenersArg, options?: any) {\n    return this._onOff('on', types, listener, options)\n  }\n\n  /**\n   * Removes an InteractEvent, pointerEvent or DOM event listener.\n   *\n   * @param {string | array | object} types The types of events that were\n   * listened for\n   * @param {function | array | object} [listener] The event listener function(s)\n   * @param {object | boolean} [options] options object or useCapture flag for\n   * removeEventListener\n   * @return {Interactable} This Interactable\n   */\n  off (types: string | string[] | EventTypes, listener?: ListenersArg, options?: any) {\n    return this._onOff('off', types, listener, options)\n  }\n\n  /**\n   * Reset the options of this Interactable\n   *\n   * @param {object} options The new settings to apply\n   * @return {object} This Interactable\n   */\n  set (options: OptionsArg) {\n    const defaults = this._defaults\n\n    if (!is.object(options)) {\n      options = {}\n    }\n\n    ;(this.options as Required<Options>) = clone(defaults.base) as Required<Options>\n\n    for (const actionName_ in this._actions.methodDict) {\n      const actionName = actionName_ as ActionName\n      const methodName = this._actions.methodDict[actionName]\n\n      this.options[actionName] = {}\n      this.setPerAction(actionName, extend(extend({}, defaults.perAction), defaults.actions[actionName]))\n      ;(this[methodName] as ActionMethod<unknown>)(options[actionName])\n    }\n\n    for (const setting in options) {\n      if (is.func((this as any)[setting])) {\n        ;(this as any)[setting](options[setting as keyof typeof options])\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Remove this interactable from the list of interactables and remove it's\n   * action capabilities and event listeners\n   */\n  unset () {\n    if (is.string(this.target)) {\n      // remove delegated events\n      for (const type in this._scopeEvents.delegatedEvents) {\n        const delegated = this._scopeEvents.delegatedEvents[type]\n\n        for (let i = delegated.length - 1; i >= 0; i--) {\n          const { selector, context, listeners } = delegated[i]\n\n          if (selector === this.target && context === this._context) {\n            delegated.splice(i, 1)\n          }\n\n          for (let l = listeners.length - 1; l >= 0; l--) {\n            this._scopeEvents.removeDelegate(\n              this.target,\n              this._context,\n              type,\n              listeners[l][0],\n              listeners[l][1],\n            )\n          }\n        }\n      }\n    } else {\n      this._scopeEvents.remove(this.target as Node, 'all')\n    }\n  }\n}\n","import type { Interactable } from '@interactjs/core/Interactable'\nimport type { OptionsArg, Options } from '@interactjs/core/options'\nimport type { Scope } from '@interactjs/core/scope'\nimport type { Target, Context } from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactable:new': {\n      interactable: Interactable\n      target: Target\n      options: OptionsArg\n      win: Window\n    }\n  }\n}\n\ninterface InteractableScopeProp {\n  context: Context\n  interactable: Interactable\n}\n\nexport class InteractableSet {\n  // all set interactables\n  list: Interactable[] = []\n\n  selectorMap: {\n    [selector: string]: InteractableScopeProp[]\n  } = {}\n\n  scope: Scope\n\n  constructor (scope: Scope) {\n    this.scope = scope\n    scope.addListeners({\n      'interactable:unset': ({ interactable }) => {\n        const { target, _context: context } = interactable\n        const targetMappings: InteractableScopeProp[] = is.string(target)\n          ? this.selectorMap[target]\n          : (target as any)[this.scope.id]\n\n        const targetIndex = arr.findIndex(targetMappings, (m) => m.context === context)\n        if (targetMappings[targetIndex]) {\n          // Destroying mappingInfo's context and interactable\n          targetMappings[targetIndex].context = null\n          targetMappings[targetIndex].interactable = null\n        }\n        targetMappings.splice(targetIndex, 1)\n      },\n    })\n  }\n\n  new (target: Target, options?: any): Interactable {\n    options = extend(options || {}, {\n      actions: this.scope.actions,\n    })\n    const interactable = new this.scope.Interactable(target, options, this.scope.document, this.scope.events)\n    const mappingInfo = { context: interactable._context, interactable }\n\n    this.scope.addDocument(interactable._doc)\n    this.list.push(interactable)\n\n    if (is.string(target)) {\n      if (!this.selectorMap[target]) {\n        this.selectorMap[target] = []\n      }\n      this.selectorMap[target].push(mappingInfo)\n    } else {\n      if (!(interactable.target as any)[this.scope.id]) {\n        Object.defineProperty(target, this.scope.id, {\n          value: [],\n          configurable: true,\n        })\n      }\n\n      ;(target as any)[this.scope.id].push(mappingInfo)\n    }\n\n    this.scope.fire('interactable:new', {\n      target,\n      options,\n      interactable,\n      win: this.scope._win,\n    })\n\n    return interactable\n  }\n\n  get (target: Target, options?: Options) {\n    const context = (options && options.context) || this.scope.document\n    const isSelector = is.string(target)\n    const targetMappings: InteractableScopeProp[] = isSelector\n      ? this.selectorMap[target as string]\n      : (target as any)[this.scope.id]\n\n    if (!targetMappings) {\n      return null\n    }\n\n    const found = arr.find(\n      targetMappings,\n      (m) => m.context === context && (isSelector || m.interactable.inContext(target as any)),\n    )\n\n    return found && found.interactable\n  }\n\n  forEachMatch<T> (node: Node, callback: (interactable: Interactable) => T) {\n    for (const interactable of this.list) {\n      let ret: void | T\n\n      if (\n        (is.string(interactable.target)\n          ? // target is a selector and the element matches\n          is.element(node) && domUtils.matchesSelector(node, interactable.target)\n          : // target is the element\n          node === interactable.target) &&\n        // the element is in context\n        interactable.inContext(node)\n      ) {\n        ret = callback(interactable)\n      }\n\n      if (ret !== undefined) {\n        return ret\n      }\n    }\n  }\n}\n","import type { Scope } from '@interactjs/core/scope'\nimport type { Element } from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport pExtend from '@interactjs/utils/pointerExtend'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    events: ReturnType<typeof install>\n  }\n}\n\ntype Listener = (event: Event | FakeEvent) => any\n\nfunction install (scope: Scope) {\n  const targets: Array<{\n    eventTarget: EventTarget\n    events: { [type: string]: Listener[] }\n  }> = []\n\n  const delegatedEvents: {\n    [type: string]: Array<{\n      selector: string\n      context: Node\n      listeners: Array<[Listener, { capture: boolean, passive: boolean }]>\n    }>\n  } = {}\n  const documents: Document[] = []\n\n  const eventsMethods = {\n    add,\n    remove,\n\n    addDelegate,\n    removeDelegate,\n\n    delegateListener,\n    delegateUseCapture,\n    delegatedEvents,\n    documents,\n\n    targets,\n\n    supportsOptions: false,\n    supportsPassive: false,\n  }\n\n  // check if browser supports passive events and options arg\n  scope.document?.createElement('div').addEventListener('test', null, {\n    get capture () {\n      return (eventsMethods.supportsOptions = true)\n    },\n    get passive () {\n      return (eventsMethods.supportsPassive = true)\n    },\n  })\n\n  scope.events = eventsMethods\n\n  function add (eventTarget: EventTarget, type: string, listener: Listener, optionalArg?: boolean | any) {\n    const options = getOptions(optionalArg)\n    let target = arr.find(targets, (t) => t.eventTarget === eventTarget)\n\n    if (!target) {\n      target = {\n        eventTarget,\n        events: {},\n      }\n\n      targets.push(target)\n    }\n\n    if (!target.events[type]) {\n      target.events[type] = []\n    }\n\n    if (eventTarget.addEventListener && !arr.contains(target.events[type], listener)) {\n      eventTarget.addEventListener(\n        type,\n        listener as any,\n        eventsMethods.supportsOptions ? options : options.capture,\n      )\n      target.events[type].push(listener)\n    }\n  }\n\n  function remove (\n    eventTarget: EventTarget,\n    type: string,\n    listener?: 'all' | Listener,\n    optionalArg?: boolean | any,\n  ) {\n    const options = getOptions(optionalArg)\n    const targetIndex = arr.findIndex(targets, (t) => t.eventTarget === eventTarget)\n    const target = targets[targetIndex]\n\n    if (!target || !target.events) {\n      return\n    }\n\n    if (type === 'all') {\n      for (type in target.events) {\n        if (target.events.hasOwnProperty(type)) {\n          remove(eventTarget, type, 'all')\n        }\n      }\n      return\n    }\n\n    let typeIsEmpty = false\n    const typeListeners = target.events[type]\n\n    if (typeListeners) {\n      if (listener === 'all') {\n        for (let i = typeListeners.length - 1; i >= 0; i--) {\n          remove(eventTarget, type, typeListeners[i], options)\n        }\n        return\n      } else {\n        for (let i = 0; i < typeListeners.length; i++) {\n          if (typeListeners[i] === listener) {\n            eventTarget.removeEventListener(\n              type,\n              listener as any,\n              eventsMethods.supportsOptions ? options : options.capture,\n            )\n            typeListeners.splice(i, 1)\n\n            if (typeListeners.length === 0) {\n              delete target.events[type]\n              typeIsEmpty = true\n            }\n\n            break\n          }\n        }\n      }\n    }\n\n    if (typeIsEmpty && !Object.keys(target.events).length) {\n      targets.splice(targetIndex, 1)\n    }\n  }\n\n  function addDelegate (selector: string, context: Node, type: string, listener: Listener, optionalArg?: any) {\n    const options = getOptions(optionalArg)\n    if (!delegatedEvents[type]) {\n      delegatedEvents[type] = []\n\n      // add delegate listener functions\n      for (const doc of documents) {\n        add(doc, type, delegateListener)\n        add(doc, type, delegateUseCapture, true)\n      }\n    }\n\n    const delegates = delegatedEvents[type]\n    let delegate = arr.find(delegates, (d) => d.selector === selector && d.context === context)\n\n    if (!delegate) {\n      delegate = { selector, context, listeners: [] }\n      delegates.push(delegate)\n    }\n\n    delegate.listeners.push([listener, options])\n  }\n\n  function removeDelegate (\n    selector: string,\n    context: Document | Element,\n    type: string,\n    listener?: Listener,\n    optionalArg?: any,\n  ) {\n    const options = getOptions(optionalArg)\n    const delegates = delegatedEvents[type]\n    let matchFound = false\n    let index: number\n\n    if (!delegates) return\n\n    // count from last index of delegated to 0\n    for (index = delegates.length - 1; index >= 0; index--) {\n      const cur = delegates[index]\n      // look for matching selector and context Node\n      if (cur.selector === selector && cur.context === context) {\n        const { listeners } = cur\n\n        // each item of the listeners array is an array: [function, capture, passive]\n        for (let i = listeners.length - 1; i >= 0; i--) {\n          const [fn, { capture, passive }] = listeners[i]\n\n          // check if the listener functions and capture and passive flags match\n          if (fn === listener && capture === options.capture && passive === options.passive) {\n            // remove the listener from the array of listeners\n            listeners.splice(i, 1)\n\n            // if all listeners for this target have been removed\n            // remove the target from the delegates array\n            if (!listeners.length) {\n              delegates.splice(index, 1)\n\n              // remove delegate function from context\n              remove(context, type, delegateListener)\n              remove(context, type, delegateUseCapture, true)\n            }\n\n            // only remove one listener\n            matchFound = true\n            break\n          }\n        }\n\n        if (matchFound) {\n          break\n        }\n      }\n    }\n  }\n\n  // bound to the interactable context when a DOM event\n  // listener is added to a selector interactable\n  function delegateListener (event: Event | FakeEvent, optionalArg?: any) {\n    const options = getOptions(optionalArg)\n    const fakeEvent = new FakeEvent(event as Event)\n    const delegates = delegatedEvents[event.type]\n    const [eventTarget] = pointerUtils.getEventTargets(event as Event)\n    let element: Node = eventTarget\n\n    // climb up document tree looking for selector matches\n    while (is.element(element)) {\n      for (let i = 0; i < delegates.length; i++) {\n        const cur = delegates[i]\n        const { selector, context } = cur\n\n        if (\n          domUtils.matchesSelector(element, selector) &&\n          domUtils.nodeContains(context, eventTarget) &&\n          domUtils.nodeContains(context, element)\n        ) {\n          const { listeners } = cur\n\n          fakeEvent.currentTarget = element\n\n          for (const [fn, { capture, passive }] of listeners) {\n            if (capture === options.capture && passive === options.passive) {\n              fn(fakeEvent)\n            }\n          }\n        }\n      }\n\n      element = domUtils.parentNode(element)\n    }\n  }\n\n  function delegateUseCapture (this: Element, event: Event | FakeEvent) {\n    return delegateListener.call(this, event, true)\n  }\n\n  // for type inferrence\n  return eventsMethods\n}\n\nclass FakeEvent implements Partial<Event> {\n  currentTarget: Node\n  originalEvent: Event\n  type: string\n\n  constructor (originalEvent: Event) {\n    this.originalEvent = originalEvent\n    // duplicate the event so that currentTarget can be changed\n    pExtend(this, originalEvent)\n  }\n\n  preventOriginalDefault () {\n    this.originalEvent.preventDefault()\n  }\n\n  stopPropagation () {\n    this.originalEvent.stopPropagation()\n  }\n\n  stopImmediatePropagation () {\n    this.originalEvent.stopImmediatePropagation()\n  }\n}\n\nfunction getOptions (param: { [index: string]: any } | boolean): { capture: boolean, passive: boolean } {\n  if (!is.object(param)) {\n    return { capture: !!param, passive: false }\n  }\n\n  const options = extend({}, param) as any\n\n  options.capture = !!param.capture\n  options.passive = !!param.passive\n\n  return options\n}\n\nexport default {\n  id: 'events',\n  install,\n}\n","import type Interaction from '@interactjs/core/Interaction'\nimport type { Scope } from '@interactjs/core/scope'\nimport type { PointerType } from '@interactjs/types/index'\nimport * as dom from '@interactjs/utils/domUtils'\n\nexport interface SearchDetails {\n  pointer: PointerType\n  pointerId: number\n  pointerType: string\n  eventType: string\n  eventTarget: EventTarget\n  curEventTarget: EventTarget\n  scope: Scope\n}\n\nconst finder = {\n  methodOrder: ['simulationResume', 'mouseOrPen', 'hasPointer', 'idle'] as const,\n\n  search (details: SearchDetails) {\n    for (const method of finder.methodOrder) {\n      const interaction = finder[method](details)\n\n      if (interaction) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n\n  // try to resume simulation with a new pointer\n  simulationResume ({ pointerType, eventType, eventTarget, scope }: SearchDetails) {\n    if (!/down|start/i.test(eventType)) {\n      return null\n    }\n\n    for (const interaction of scope.interactions.list) {\n      let element = eventTarget as Node\n\n      if (\n        interaction.simulation &&\n        interaction.simulation.allowResume &&\n        interaction.pointerType === pointerType\n      ) {\n        while (element) {\n          // if the element is the interaction element\n          if (element === interaction.element) {\n            return interaction\n          }\n          element = dom.parentNode(element)\n        }\n      }\n    }\n\n    return null\n  },\n\n  // if it's a mouse or pen interaction\n  mouseOrPen ({ pointerId, pointerType, eventType, scope }: SearchDetails) {\n    if (pointerType !== 'mouse' && pointerType !== 'pen') {\n      return null\n    }\n\n    let firstNonActive\n\n    for (const interaction of scope.interactions.list) {\n      if (interaction.pointerType === pointerType) {\n        // if it's a down event, skip interactions with running simulations\n        if (interaction.simulation && !hasPointerId(interaction, pointerId)) {\n          continue\n        }\n\n        // if the interaction is active, return it immediately\n        if (interaction.interacting()) {\n          return interaction\n        }\n        // otherwise save it and look for another active interaction\n        else if (!firstNonActive) {\n          firstNonActive = interaction\n        }\n      }\n    }\n\n    // if no active mouse interaction was found use the first inactive mouse\n    // interaction\n    if (firstNonActive) {\n      return firstNonActive\n    }\n\n    // find any mouse or pen interaction.\n    // ignore the interaction if the eventType is a *down, and a simulation\n    // is active\n    for (const interaction of scope.interactions.list) {\n      if (interaction.pointerType === pointerType && !(/down/i.test(eventType) && interaction.simulation)) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n\n  // get interaction that has this pointer\n  hasPointer ({ pointerId, scope }: SearchDetails) {\n    for (const interaction of scope.interactions.list) {\n      if (hasPointerId(interaction, pointerId)) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n\n  // get first idle interaction with a matching pointerType\n  idle ({ pointerType, scope }: SearchDetails) {\n    for (const interaction of scope.interactions.list) {\n      // if there's already a pointer held down\n      if (interaction.pointers.length === 1) {\n        const target = interaction.interactable\n        // don't add this pointer if there is a target interactable and it\n        // isn't gesturable\n        if (target && !(target.options.gesture && target.options.gesture.enabled)) {\n          continue\n        }\n      }\n      // maximum of 2 pointers per interaction\n      else if (interaction.pointers.length >= 2) {\n        continue\n      }\n\n      if (!interaction.interacting() && pointerType === interaction.pointerType) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n}\n\nfunction hasPointerId (interaction: Interaction, pointerId: number) {\n  return interaction.pointers.some(({ id }) => id === pointerId)\n}\n\nexport default finder\n","import type { Scope, ActionName, SignalArgs, Plugin } from '@interactjs/core/scope'\nimport type { Listener } from '@interactjs/types/index'\nimport browser from '@interactjs/utils/browser'\nimport domObjects from '@interactjs/utils/domObjects'\nimport { nodeContains } from '@interactjs/utils/domUtils'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nimport InteractionBase from './Interaction'\nimport interactablePreventDefault from './interactablePreventDefault'\nimport type { SearchDetails } from './interactionFinder'\nimport finder from './interactionFinder'\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    Interaction: typeof InteractionBase\n    interactions: {\n      new: <T extends ActionName>(options: any) => InteractionBase<T>\n      list: Array<InteractionBase<ActionName>>\n      listeners: { [type: string]: Listener }\n      docEvents: Array<{ type: string, listener: Listener }>\n      pointerMoveTolerance: number\n    }\n    prevTouchTime: number\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactions:find': {\n      interaction: InteractionBase\n      searchDetails: SearchDetails\n    }\n  }\n}\n\nconst methodNames = [\n  'pointerDown',\n  'pointerMove',\n  'pointerUp',\n  'updatePointer',\n  'removePointer',\n  'windowBlur',\n]\n\nfunction install (scope: Scope) {\n  const listeners = {} as any\n\n  for (const method of methodNames) {\n    listeners[method] = doOnInteractions(method, scope)\n  }\n\n  const pEventTypes = browser.pEventTypes\n  let docEvents: typeof scope.interactions.docEvents\n\n  if (domObjects.PointerEvent) {\n    docEvents = [\n      { type: pEventTypes.down, listener: releasePointersOnRemovedEls },\n      { type: pEventTypes.down, listener: listeners.pointerDown },\n      { type: pEventTypes.move, listener: listeners.pointerMove },\n      { type: pEventTypes.up, listener: listeners.pointerUp },\n      { type: pEventTypes.cancel, listener: listeners.pointerUp },\n    ]\n  } else {\n    docEvents = [\n      { type: 'mousedown', listener: listeners.pointerDown },\n      { type: 'mousemove', listener: listeners.pointerMove },\n      { type: 'mouseup', listener: listeners.pointerUp },\n\n      { type: 'touchstart', listener: releasePointersOnRemovedEls },\n      { type: 'touchstart', listener: listeners.pointerDown },\n      { type: 'touchmove', listener: listeners.pointerMove },\n      { type: 'touchend', listener: listeners.pointerUp },\n      { type: 'touchcancel', listener: listeners.pointerUp },\n    ]\n  }\n\n  docEvents.push({\n    type: 'blur',\n    listener (event) {\n      for (const interaction of scope.interactions.list) {\n        interaction.documentBlur(event)\n      }\n    },\n  })\n\n  // for ignoring browser's simulated mouse events\n  scope.prevTouchTime = 0\n\n  scope.Interaction = class <T extends ActionName> extends InteractionBase<T> {\n    get pointerMoveTolerance () {\n      return scope.interactions.pointerMoveTolerance\n    }\n\n    set pointerMoveTolerance (value) {\n      scope.interactions.pointerMoveTolerance = value\n    }\n\n    _now () {\n      return scope.now()\n    }\n  }\n\n  scope.interactions = {\n    // all active and idle interactions\n    list: [],\n    new<T extends ActionName> (options: { pointerType?: string, scopeFire?: Scope['fire'] }) {\n      options.scopeFire = (name, arg) => scope.fire(name, arg)\n\n      const interaction = new scope.Interaction<T>(options as Required<typeof options>)\n\n      scope.interactions.list.push(interaction)\n      return interaction\n    },\n    listeners,\n    docEvents,\n    pointerMoveTolerance: 1,\n  }\n\n  function releasePointersOnRemovedEls () {\n    // for all inactive touch interactions with pointers down\n    for (const interaction of scope.interactions.list) {\n      if (!interaction.pointerIsDown || interaction.pointerType !== 'touch' || interaction._interacting) {\n        continue\n      }\n\n      // if a pointer is down on an element that is no longer in the DOM tree\n      for (const pointer of interaction.pointers) {\n        if (!scope.documents.some(({ doc }) => nodeContains(doc, pointer.downTarget))) {\n          // remove the pointer from the interaction\n          interaction.removePointer(pointer.pointer, pointer.event)\n        }\n      }\n    }\n  }\n\n  scope.usePlugin(interactablePreventDefault)\n}\n\nfunction doOnInteractions (method: string, scope: Scope) {\n  return function (event: Event) {\n    const interactions = scope.interactions.list\n\n    const pointerType = pointerUtils.getPointerType(event)\n    const [eventTarget, curEventTarget] = pointerUtils.getEventTargets(event)\n    const matches: any[] = [] // [ [pointer, interaction], ...]\n\n    if (/^touch/.test(event.type)) {\n      scope.prevTouchTime = scope.now()\n\n      // @ts-expect-error\n      for (const changedTouch of event.changedTouches) {\n        const pointer = changedTouch\n        const pointerId = pointerUtils.getPointerId(pointer)\n        const searchDetails: SearchDetails = {\n          pointer,\n          pointerId,\n          pointerType,\n          eventType: event.type,\n          eventTarget,\n          curEventTarget,\n          scope,\n        }\n        const interaction = getInteraction(searchDetails)\n\n        matches.push([\n          searchDetails.pointer,\n          searchDetails.eventTarget,\n          searchDetails.curEventTarget,\n          interaction,\n        ])\n      }\n    } else {\n      let invalidPointer = false\n\n      if (!browser.supportsPointerEvent && /mouse/.test(event.type)) {\n        // ignore mouse events while touch interactions are active\n        for (let i = 0; i < interactions.length && !invalidPointer; i++) {\n          invalidPointer = interactions[i].pointerType !== 'mouse' && interactions[i].pointerIsDown\n        }\n\n        // try to ignore mouse events that are simulated by the browser\n        // after a touch event\n        invalidPointer =\n          invalidPointer ||\n          scope.now() - scope.prevTouchTime < 500 ||\n          // on iOS and Firefox Mobile, MouseEvent.timeStamp is zero if simulated\n          event.timeStamp === 0\n      }\n\n      if (!invalidPointer) {\n        const searchDetails = {\n          pointer: event as PointerEvent,\n          pointerId: pointerUtils.getPointerId(event as PointerEvent),\n          pointerType,\n          eventType: event.type,\n          curEventTarget,\n          eventTarget,\n          scope,\n        }\n\n        const interaction = getInteraction(searchDetails)\n\n        matches.push([\n          searchDetails.pointer,\n          searchDetails.eventTarget,\n          searchDetails.curEventTarget,\n          interaction,\n        ])\n      }\n    }\n\n    // eslint-disable-next-line no-shadow\n    for (const [pointer, eventTarget, curEventTarget, interaction] of matches) {\n      interaction[method](pointer, event, eventTarget, curEventTarget)\n    }\n  }\n}\n\nfunction getInteraction (searchDetails: SearchDetails) {\n  const { pointerType, scope } = searchDetails\n\n  const foundInteraction = finder.search(searchDetails)\n  const signalArg = { interaction: foundInteraction, searchDetails }\n\n  scope.fire('interactions:find', signalArg)\n\n  return signalArg.interaction || scope.interactions.new({ pointerType })\n}\n\nfunction onDocSignal<T extends 'scope:add-document' | 'scope:remove-document'> (\n  { doc, scope, options }: SignalArgs[T],\n  eventMethodName: 'add' | 'remove',\n) {\n  const {\n    interactions: { docEvents },\n    events,\n  } = scope\n  const eventMethod = events[eventMethodName]\n\n  if (scope.browser.isIOS && !options.events) {\n    options.events = { passive: false }\n  }\n\n  // delegate event listener\n  for (const eventType in events.delegatedEvents) {\n    eventMethod(doc, eventType, events.delegateListener)\n    eventMethod(doc, eventType, events.delegateUseCapture, true)\n  }\n\n  const eventOptions = options && options.events\n\n  for (const { type, listener } of docEvents) {\n    eventMethod(doc, type, listener, eventOptions)\n  }\n}\n\nconst interactions: Plugin = {\n  id: 'core/interactions',\n  install,\n  listeners: {\n    'scope:add-document': (arg) => onDocSignal(arg, 'add'),\n    'scope:remove-document': (arg) => onDocSignal(arg, 'remove'),\n    'interactable:unset': ({ interactable }, scope) => {\n      // Stop and destroy related interactions when an Interactable is unset\n      for (let i = scope.interactions.list.length - 1; i >= 0; i--) {\n        const interaction = scope.interactions.list[i]\n\n        if (interaction.interactable !== interactable) {\n          continue\n        }\n\n        interaction.stop()\n        scope.fire('interactions:destroy', { interaction })\n        interaction.destroy()\n\n        if (scope.interactions.list.length > 2) {\n          scope.interactions.list.splice(i, 1)\n        }\n      }\n    },\n  },\n  onDocSignal,\n  doOnInteractions,\n  methodNames,\n}\n\nexport default interactions\n","import type Interaction from '@interactjs/core/Interaction'\nimport browser from '@interactjs/utils/browser'\nimport clone from '@interactjs/utils/clone'\nimport domObjects from '@interactjs/utils/domObjects'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport raf from '@interactjs/utils/raf'\nimport * as win from '@interactjs/utils/window'\n\nimport { Eventable } from './Eventable'\nimport type { PhaseMap } from './InteractEvent'\nimport { InteractEvent } from './InteractEvent'\nimport { createInteractStatic } from './InteractStatic'\nimport type { Interactable } from './Interactable'\nimport { Interactable as InteractableBase } from './Interactable'\nimport { InteractableSet } from './InteractableSet'\nimport events from './events'\nimport interactions from './interactions'\nimport type { OptionsArg } from './options'\nimport { defaults } from './options'\n\nexport interface SignalArgs {\n  'scope:add-document': DocSignalArg\n  'scope:remove-document': DocSignalArg\n  'interactable:unset': { interactable: InteractableBase }\n  'interactable:set': { interactable: InteractableBase, options: OptionsArg }\n  'interactions:destroy': { interaction: Interaction }\n}\n\nexport type ListenerName = keyof SignalArgs\n\nexport type ListenerMap = {\n  [P in ListenerName]?: (arg: SignalArgs[P], scope: Scope, signalName: P) => void | boolean\n}\n\ninterface DocSignalArg {\n  doc: Document\n  window: Window\n  scope: Scope\n  options: Record<string, any>\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface ActionMap {}\nexport type ActionName = keyof ActionMap\n\nexport interface Actions {\n  map: ActionMap\n  phases: PhaseMap\n  methodDict: { [P in ActionName]?: keyof Interactable }\n  phaselessTypes: { [type: string]: true }\n}\n\nexport interface Plugin {\n  [key: string]: any\n  id?: string\n  listeners?: ListenerMap\n  before?: string[]\n  install?(scope: Scope, options?: any): void\n}\n\nexport class Scope {\n  id = `__interact_scope_${Math.floor(Math.random() * 100)}`\n  isInitialized = false\n  listenerMaps: Array<{\n    map: ListenerMap\n    id: string\n  }> = []\n\n  browser = browser\n  defaults = clone(defaults) as typeof defaults\n  Eventable = Eventable\n  actions: Actions = {\n    map: {},\n    phases: {\n      start: true,\n      move: true,\n      end: true,\n    },\n    methodDict: {},\n    phaselessTypes: {},\n  }\n\n  interactStatic = createInteractStatic(this)\n  InteractEvent = InteractEvent\n  Interactable: typeof InteractableBase\n  interactables = new InteractableSet(this)\n\n  // main window\n  _win!: Window\n\n  // main document\n  document!: Document\n\n  // main window\n  window!: Window\n\n  // all documents being listened to\n  documents: Array<{ doc: Document, options: any }> = []\n\n  _plugins: {\n    list: Plugin[]\n    map: { [id: string]: Plugin }\n  } = {\n    list: [],\n    map: {},\n  }\n\n  constructor () {\n    const scope = this\n\n    this.Interactable = class extends InteractableBase {\n      get _defaults () {\n        return scope.defaults\n      }\n\n      set<T extends InteractableBase> (this: T, options: OptionsArg) {\n        super.set(options)\n\n        scope.fire('interactable:set', {\n          options,\n          interactable: this,\n        })\n\n        return this\n      }\n\n      unset (this: InteractableBase) {\n        super.unset()\n        scope.interactables.list.splice(scope.interactables.list.indexOf(this), 1)\n\n        scope.fire('interactable:unset', { interactable: this })\n      }\n    }\n  }\n\n  addListeners (map: ListenerMap, id?: string) {\n    this.listenerMaps.push({ id, map })\n  }\n\n  fire<T extends ListenerName> (name: T, arg: SignalArgs[T]): void | false {\n    for (const {\n      map: { [name]: listener },\n    } of this.listenerMaps) {\n      if (!!listener && listener(arg as any, this, name as never) === false) {\n        return false\n      }\n    }\n  }\n\n  onWindowUnload = (event: BeforeUnloadEvent) => this.removeDocument(event.target as Document)\n\n  init (window: Window | typeof globalThis) {\n    return this.isInitialized ? this : initScope(this, window)\n  }\n\n  pluginIsInstalled (plugin: Plugin) {\n    return this._plugins.map[plugin.id] || this._plugins.list.indexOf(plugin) !== -1\n  }\n\n  usePlugin (plugin: Plugin, options?: { [key: string]: any }) {\n    if (!this.isInitialized) {\n      return this\n    }\n\n    if (this.pluginIsInstalled(plugin)) {\n      return this\n    }\n\n    if (plugin.id) {\n      this._plugins.map[plugin.id] = plugin\n    }\n    this._plugins.list.push(plugin)\n\n    if (plugin.install) {\n      plugin.install(this, options)\n    }\n\n    if (plugin.listeners && plugin.before) {\n      let index = 0\n      const len = this.listenerMaps.length\n      const before = plugin.before.reduce((acc, id) => {\n        acc[id] = true\n        acc[pluginIdRoot(id)] = true\n        return acc\n      }, {})\n\n      for (; index < len; index++) {\n        const otherId = this.listenerMaps[index].id\n\n        if (before[otherId] || before[pluginIdRoot(otherId)]) {\n          break\n        }\n      }\n\n      this.listenerMaps.splice(index, 0, { id: plugin.id, map: plugin.listeners })\n    } else if (plugin.listeners) {\n      this.listenerMaps.push({ id: plugin.id, map: plugin.listeners })\n    }\n\n    return this\n  }\n\n  addDocument (doc: Document, options?: any): void | false {\n    // do nothing if document is already known\n    if (this.getDocIndex(doc) !== -1) {\n      return false\n    }\n\n    const window = win.getWindow(doc)\n\n    options = options ? extend({}, options) : {}\n\n    this.documents.push({ doc, options })\n    this.events.documents.push(doc)\n\n    // don't add an unload event for the main document\n    // so that the page may be cached in browser history\n    if (doc !== this.document) {\n      this.events.add(window, 'unload', this.onWindowUnload)\n    }\n\n    this.fire('scope:add-document', { doc, window, scope: this, options })\n  }\n\n  removeDocument (doc: Document) {\n    const index = this.getDocIndex(doc)\n\n    const window = win.getWindow(doc)\n    const options = this.documents[index].options\n\n    this.events.remove(window, 'unload', this.onWindowUnload)\n\n    this.documents.splice(index, 1)\n    this.events.documents.splice(index, 1)\n\n    this.fire('scope:remove-document', { doc, window, scope: this, options })\n  }\n\n  getDocIndex (doc: Document) {\n    for (let i = 0; i < this.documents.length; i++) {\n      if (this.documents[i].doc === doc) {\n        return i\n      }\n    }\n\n    return -1\n  }\n\n  getDocOptions (doc: Document) {\n    const docIndex = this.getDocIndex(doc)\n\n    return docIndex === -1 ? null : this.documents[docIndex].options\n  }\n\n  now () {\n    return (((this.window as any).Date as typeof Date) || Date).now()\n  }\n}\n\nexport function initScope (scope: Scope, window: Window | typeof globalThis) {\n  scope.isInitialized = true\n\n  if (is.window(window)) {\n    win.init(window)\n  }\n\n  domObjects.init(window)\n  browser.init(window)\n  raf.init(window)\n\n  // @ts-expect-error\n  scope.window = window\n  scope.document = window.document\n\n  scope.usePlugin(interactions)\n  scope.usePlugin(events)\n\n  return scope\n}\n\nfunction pluginIdRoot (id: string) {\n  return id && id.replace(/\\/.*$/, '')\n}\n","import { Scope } from '@interactjs/core/scope'\n\nconst scope = new Scope()\n\nconst interact = scope.interactStatic\n\nexport default interact\n\nconst _global = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : this\nscope.init(_global)\n","export default () => {}\n","export default () => {}\n","import type { SnapFunction, SnapTarget } from '@interactjs/modifiers/snap/pointer'\nimport type { Rect, Point } from '@interactjs/types/index'\n\nexport type GridOptions = (Partial<Rect> | Point) & {\n  range?: number\n  limits?: Rect\n  offset?: Point\n}\n\nexport default (grid: GridOptions) => {\n  const coordFields = ([\n    ['x', 'y'],\n    ['left', 'top'],\n    ['right', 'bottom'],\n    ['width', 'height'],\n  ] as const).filter(([xField, yField]) => xField in grid || yField in grid)\n\n  const gridFunc: SnapFunction & {\n    grid: typeof grid\n    coordFields: typeof coordFields\n  } = (x, y) => {\n    const {\n      range,\n      limits = {\n        left: -Infinity,\n        right: Infinity,\n        top: -Infinity,\n        bottom: Infinity,\n      },\n      offset = { x: 0, y: 0 },\n    } = grid\n\n    const result: SnapTarget & {\n      grid: typeof grid\n    } = { range, grid, x: null as number, y: null as number }\n\n    for (const [xField, yField] of coordFields) {\n      const gridx = Math.round((x - offset.x) / (grid as any)[xField])\n      const gridy = Math.round((y - offset.y) / (grid as any)[yField])\n\n      result[xField] = Math.max(limits.left, Math.min(limits.right, gridx * (grid as any)[xField] + offset.x))\n      result[yField] = Math.max(limits.top, Math.min(limits.bottom, gridy * (grid as any)[yField] + offset.y))\n    }\n\n    return result\n  }\n\n  gridFunc.grid = grid\n  gridFunc.coordFields = coordFields\n\n  return gridFunc\n}\n","import type { Plugin } from '@interactjs/core/scope'\nimport extend from '@interactjs/utils/extend'\n\nimport * as allSnappers from './all'\n\ndeclare module '@interactjs/core/InteractStatic' {\n  export interface InteractStatic {\n    snappers: typeof allSnappers\n    createSnapGrid: typeof allSnappers.grid\n  }\n}\n\nconst snappersPlugin: Plugin = {\n  id: 'snappers',\n  install (scope) {\n    const { interactStatic: interact } = scope\n\n    interact.snappers = extend(interact.snappers || {}, allSnappers)\n    interact.createSnapGrid = interact.snappers.grid\n  },\n}\n\nexport default snappersPlugin\n","/**\n * @module modifiers/aspectRatio\n *\n * @description\n * This module forces elements to be resized with a specified dx/dy ratio.\n *\n * ```js\n * interact(target).resizable({\n *   modifiers: [\n *     interact.modifiers.snapSize({\n *       targets: [ interact.snappers.grid({ x: 20, y: 20 }) ],\n *     }),\n *     interact.aspectRatio({ ratio: 'preserve' }),\n *   ],\n * });\n * ```\n */\n\nimport type { Point, Rect, EdgeOptions } from '@interactjs/types/index'\nimport extend from '@interactjs/utils/extend'\nimport { addEdges } from '@interactjs/utils/rect'\n\nimport Modification from './Modification'\nimport type { Modifier, ModifierModule, ModifierState } from './base'\nimport { makeModifier } from './base'\n\nexport interface AspectRatioOptions {\n  ratio?: number | 'preserve'\n  equalDelta?: boolean\n  modifiers?: Modifier[]\n  enabled?: boolean\n}\n\nexport type AspectRatioState = ModifierState<\nAspectRatioOptions,\n{\n  startCoords: Point\n  startRect: Rect\n  linkedEdges: EdgeOptions\n  ratio: number\n  equalDelta: boolean\n  xIsPrimaryAxis: boolean\n  edgeSign: 1 | -1\n  subModification: Modification\n}\n>\n\nconst aspectRatio: ModifierModule<AspectRatioOptions, AspectRatioState> = {\n  start (arg) {\n    const { state, rect, edges: originalEdges, pageCoords: coords } = arg\n    let { ratio } = state.options\n    const { equalDelta, modifiers } = state.options\n\n    if (ratio === 'preserve') {\n      ratio = rect.width / rect.height\n    }\n\n    state.startCoords = extend({}, coords)\n    state.startRect = extend({}, rect)\n    state.ratio = ratio\n    state.equalDelta = equalDelta\n\n    const linkedEdges = (state.linkedEdges = {\n      top: originalEdges.top || (originalEdges.left && !originalEdges.bottom),\n      left: originalEdges.left || (originalEdges.top && !originalEdges.right),\n      bottom: originalEdges.bottom || (originalEdges.right && !originalEdges.top),\n      right: originalEdges.right || (originalEdges.bottom && !originalEdges.left),\n    })\n\n    state.xIsPrimaryAxis = !!(originalEdges.left || originalEdges.right)\n\n    if (state.equalDelta) {\n      state.edgeSign = ((linkedEdges.left ? 1 : -1) * (linkedEdges.top ? 1 : -1)) as 1 | -1\n    } else {\n      const negativeSecondaryEdge = state.xIsPrimaryAxis ? linkedEdges.top : linkedEdges.left\n      state.edgeSign = negativeSecondaryEdge ? -1 : 1\n    }\n\n    extend(arg.edges, linkedEdges)\n\n    if (!modifiers || !modifiers.length) return\n\n    const subModification = new Modification(arg.interaction)\n\n    subModification.copyFrom(arg.interaction.modification)\n    subModification.prepareStates(modifiers)\n\n    state.subModification = subModification\n    subModification.startAll({ ...arg })\n  },\n\n  set (arg) {\n    const { state, rect, coords } = arg\n    const initialCoords = extend({}, coords)\n    const aspectMethod = state.equalDelta ? setEqualDelta : setRatio\n\n    aspectMethod(state, state.xIsPrimaryAxis, coords, rect)\n\n    if (!state.subModification) {\n      return null\n    }\n\n    const correctedRect = extend({}, rect)\n\n    addEdges(state.linkedEdges, correctedRect, {\n      x: coords.x - initialCoords.x,\n      y: coords.y - initialCoords.y,\n    })\n\n    const result = state.subModification.setAll({\n      ...arg,\n      rect: correctedRect,\n      edges: state.linkedEdges,\n      pageCoords: coords,\n      prevCoords: coords,\n      prevRect: correctedRect,\n    })\n\n    const { delta } = result\n\n    if (result.changed) {\n      const xIsCriticalAxis = Math.abs(delta.x) > Math.abs(delta.y)\n\n      // do aspect modification again with critical edge axis as primary\n      aspectMethod(state, xIsCriticalAxis, result.coords, result.rect)\n      extend(coords, result.coords)\n    }\n\n    return result.eventProps\n  },\n\n  defaults: {\n    ratio: 'preserve',\n    equalDelta: false,\n    modifiers: [],\n    enabled: false,\n  },\n}\n\nfunction setEqualDelta ({ startCoords, edgeSign }: AspectRatioState, xIsPrimaryAxis: boolean, coords: Point) {\n  if (xIsPrimaryAxis) {\n    coords.y = startCoords.y + (coords.x - startCoords.x) * edgeSign\n  } else {\n    coords.x = startCoords.x + (coords.y - startCoords.y) * edgeSign\n  }\n}\n\nfunction setRatio (\n  { startRect, startCoords, ratio, edgeSign }: AspectRatioState,\n  xIsPrimaryAxis: boolean,\n  coords: Point,\n  rect: Rect,\n) {\n  if (xIsPrimaryAxis) {\n    const newHeight = rect.width / ratio\n\n    coords.y = startCoords.y + (newHeight - startRect.height) * edgeSign\n  } else {\n    const newWidth = rect.height * ratio\n\n    coords.x = startCoords.x + (newWidth - startRect.width) * edgeSign\n  }\n}\n\nexport default makeModifier(aspectRatio, 'aspectRatio')\nexport { aspectRatio }\n","import type { ModifierFunction } from '@interactjs/modifiers/base'\n\nconst noop = ((() => {}) as unknown) as ModifierFunction<any, any, 'noop'>\n\nnoop._defaults = {}\n\nexport default noop\n","import type Interaction from '@interactjs/core/Interaction'\nimport type { RectResolvable, Rect, Point } from '@interactjs/types/index'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nimport type { ModifierArg, ModifierModule, ModifierState } from '../base'\nimport { makeModifier } from '../base'\n\nexport interface RestrictOptions {\n  // where to drag over\n  restriction: RectResolvable<[number, number, Interaction]>\n  // what part of self is allowed to drag over\n  elementRect: Rect\n  offset: Rect\n  // restrict just before the end drag\n  endOnly: boolean\n  enabled?: boolean\n}\n\nexport type RestrictState = ModifierState<\nRestrictOptions,\n{\n  offset: Rect\n}\n>\n\nfunction start ({ rect, startOffset, state, interaction, pageCoords }: ModifierArg<RestrictState>) {\n  const { options } = state\n  const { elementRect } = options\n  const offset: Rect = extend(\n    {\n      left: 0,\n      top: 0,\n      right: 0,\n      bottom: 0,\n    },\n    options.offset || {},\n  )\n\n  if (rect && elementRect) {\n    const restriction = getRestrictionRect(options.restriction, interaction, pageCoords)\n\n    if (restriction) {\n      const widthDiff = restriction.right - restriction.left - rect.width\n      const heightDiff = restriction.bottom - restriction.top - rect.height\n\n      if (widthDiff < 0) {\n        offset.left += widthDiff\n        offset.right += widthDiff\n      }\n      if (heightDiff < 0) {\n        offset.top += heightDiff\n        offset.bottom += heightDiff\n      }\n    }\n\n    offset.left += startOffset.left - rect.width * elementRect.left\n    offset.top += startOffset.top - rect.height * elementRect.top\n\n    offset.right += startOffset.right - rect.width * (1 - elementRect.right)\n    offset.bottom += startOffset.bottom - rect.height * (1 - elementRect.bottom)\n  }\n\n  state.offset = offset\n}\n\nfunction set ({ coords, interaction, state }: ModifierArg<RestrictState>) {\n  const { options, offset } = state\n\n  const restriction = getRestrictionRect(options.restriction, interaction, coords)\n\n  if (!restriction) return\n\n  const rect = rectUtils.xywhToTlbr(restriction)\n\n  coords.x = Math.max(Math.min(rect.right - offset.right, coords.x), rect.left + offset.left)\n  coords.y = Math.max(Math.min(rect.bottom - offset.bottom, coords.y), rect.top + offset.top)\n}\n\nexport function getRestrictionRect (\n  value: RectResolvable<[number, number, Interaction]>,\n  interaction: Interaction,\n  coords?: Point,\n) {\n  if (is.func(value)) {\n    return rectUtils.resolveRectLike(value, interaction.interactable, interaction.element, [\n      coords.x,\n      coords.y,\n      interaction,\n    ])\n  } else {\n    return rectUtils.resolveRectLike(value, interaction.interactable, interaction.element)\n  }\n}\n\nconst defaults: RestrictOptions = {\n  restriction: null,\n  elementRect: null,\n  offset: null,\n  endOnly: false,\n  enabled: false,\n}\n\nconst restrict: ModifierModule<RestrictOptions, RestrictState> = {\n  start,\n  set,\n  defaults,\n}\n\nexport default makeModifier(restrict, 'restrict')\nexport { restrict }\n","// This module adds the options.resize.restrictEdges setting which sets min and\n// max for the top, left, bottom and right edges of the target being resized.\n//\n// interact(target).resize({\n//   edges: { top: true, left: true },\n//   restrictEdges: {\n//     inner: { top: 200, left: 200, right: 400, bottom: 400 },\n//     outer: { top:   0, left:   0, right: 600, bottom: 600 },\n//   },\n// })\n\nimport type { Point, Rect } from '@interactjs/types/index'\nimport extend from '@interactjs/utils/extend'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nimport type { ModifierArg, ModifierState } from '../base'\nimport { makeModifier } from '../base'\n\nimport type { RestrictOptions } from './pointer'\nimport { getRestrictionRect } from './pointer'\n\nexport interface RestrictEdgesOptions {\n  inner: RestrictOptions['restriction']\n  outer: RestrictOptions['restriction']\n  offset?: RestrictOptions['offset']\n  endOnly: boolean\n  enabled?: boolean\n}\n\nexport type RestrictEdgesState = ModifierState<\nRestrictEdgesOptions,\n{\n  inner: Rect\n  outer: Rect\n  offset: RestrictEdgesOptions['offset']\n}\n>\n\nconst noInner = { top: +Infinity, left: +Infinity, bottom: -Infinity, right: -Infinity }\nconst noOuter = { top: -Infinity, left: -Infinity, bottom: +Infinity, right: +Infinity }\n\nfunction start ({ interaction, startOffset, state }: ModifierArg<RestrictEdgesState>) {\n  const { options } = state\n  let offset: Point\n\n  if (options) {\n    const offsetRect = getRestrictionRect(options.offset, interaction, interaction.coords.start.page)\n\n    offset = rectUtils.rectToXY(offsetRect)\n  }\n\n  offset = offset || { x: 0, y: 0 }\n\n  state.offset = {\n    top: offset.y + startOffset.top,\n    left: offset.x + startOffset.left,\n    bottom: offset.y - startOffset.bottom,\n    right: offset.x - startOffset.right,\n  }\n}\n\nfunction set ({ coords, edges, interaction, state }: ModifierArg<RestrictEdgesState>) {\n  const { offset, options } = state\n\n  if (!edges) {\n    return\n  }\n\n  const page = extend({}, coords)\n  const inner = getRestrictionRect(options.inner, interaction, page) || ({} as Rect)\n  const outer = getRestrictionRect(options.outer, interaction, page) || ({} as Rect)\n\n  fixRect(inner, noInner)\n  fixRect(outer, noOuter)\n\n  if (edges.top) {\n    coords.y = Math.min(Math.max(outer.top + offset.top, page.y), inner.top + offset.top)\n  } else if (edges.bottom) {\n    coords.y = Math.max(Math.min(outer.bottom + offset.bottom, page.y), inner.bottom + offset.bottom)\n  }\n  if (edges.left) {\n    coords.x = Math.min(Math.max(outer.left + offset.left, page.x), inner.left + offset.left)\n  } else if (edges.right) {\n    coords.x = Math.max(Math.min(outer.right + offset.right, page.x), inner.right + offset.right)\n  }\n}\n\nfunction fixRect (rect: Rect, defaults: Rect) {\n  for (const edge of ['top', 'left', 'bottom', 'right']) {\n    if (!(edge in rect)) {\n      rect[edge] = defaults[edge]\n    }\n  }\n\n  return rect\n}\n\nconst defaults: RestrictEdgesOptions = {\n  inner: null,\n  outer: null,\n  offset: null,\n  endOnly: false,\n  enabled: false,\n}\n\nconst restrictEdges = {\n  noInner,\n  noOuter,\n  start,\n  set,\n  defaults,\n}\n\nexport default makeModifier(restrictEdges, 'restrictEdges')\nexport { restrictEdges }\n","import extend from '@interactjs/utils/extend'\n\nimport { makeModifier } from '../base'\n\nimport { restrict } from './pointer'\n\nconst defaults = extend(\n  {\n    get elementRect () {\n      return { top: 0, left: 0, bottom: 1, right: 1 }\n    },\n    set elementRect (_) {},\n  },\n  restrict.defaults,\n)\n\nconst restrictRect = {\n  start: restrict.start,\n  set: restrict.set,\n  defaults,\n}\n\nexport default makeModifier(restrictRect, 'restrictRect')\nexport { restrictRect }\n","import type { Point, Rect, Size } from '@interactjs/types/index'\nimport extend from '@interactjs/utils/extend'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nimport type { ModifierArg, ModifierState } from '../base'\nimport { makeModifier } from '../base'\n\nimport type { RestrictEdgesState } from './edges'\nimport { restrictEdges } from './edges'\nimport type { RestrictOptions } from './pointer'\nimport { getRestrictionRect } from './pointer'\n\nconst noMin = { width: -Infinity, height: -Infinity }\nconst noMax = { width: +Infinity, height: +Infinity }\n\nexport interface RestrictSizeOptions {\n  min?: Size | Point | RestrictOptions['restriction']\n  max?: Size | Point | RestrictOptions['restriction']\n  endOnly: boolean\n  enabled?: boolean\n}\n\nfunction start (arg: ModifierArg<RestrictEdgesState>) {\n  return restrictEdges.start(arg)\n}\n\nexport type RestrictSizeState = RestrictEdgesState &\nModifierState<\nRestrictSizeOptions & { inner: Rect, outer: Rect },\n{\n  min: Rect\n  max: Rect\n}\n>\n\nfunction set (arg: ModifierArg<RestrictSizeState>) {\n  const { interaction, state, rect, edges } = arg\n  const { options } = state\n\n  if (!edges) {\n    return\n  }\n\n  const minSize =\n    rectUtils.tlbrToXywh(getRestrictionRect(options.min as any, interaction, arg.coords)) || noMin\n  const maxSize =\n    rectUtils.tlbrToXywh(getRestrictionRect(options.max as any, interaction, arg.coords)) || noMax\n\n  state.options = {\n    endOnly: options.endOnly,\n    inner: extend({}, restrictEdges.noInner),\n    outer: extend({}, restrictEdges.noOuter),\n  }\n\n  if (edges.top) {\n    state.options.inner.top = rect.bottom - minSize.height\n    state.options.outer.top = rect.bottom - maxSize.height\n  } else if (edges.bottom) {\n    state.options.inner.bottom = rect.top + minSize.height\n    state.options.outer.bottom = rect.top + maxSize.height\n  }\n  if (edges.left) {\n    state.options.inner.left = rect.right - minSize.width\n    state.options.outer.left = rect.right - maxSize.width\n  } else if (edges.right) {\n    state.options.inner.right = rect.left + minSize.width\n    state.options.outer.right = rect.left + maxSize.width\n  }\n\n  restrictEdges.set(arg)\n\n  state.options = options\n}\n\nconst defaults: RestrictSizeOptions = {\n  min: null,\n  max: null,\n  endOnly: false,\n  enabled: false,\n}\n\nconst restrictSize = {\n  start,\n  set,\n  defaults,\n}\n\nexport default makeModifier(restrictSize, 'restrictSize')\nexport { restrictSize }\n","import type { Interaction, InteractionProxy } from '@interactjs/core/Interaction'\nimport type { ActionName } from '@interactjs/core/scope'\nimport type { Point, RectResolvable, Element } from '@interactjs/types/index'\nimport extend from '@interactjs/utils/extend'\nimport getOriginXY from '@interactjs/utils/getOriginXY'\nimport hypot from '@interactjs/utils/hypot'\nimport is from '@interactjs/utils/is'\nimport { resolveRectLike, rectToXY } from '@interactjs/utils/rect'\n\nimport type { ModifierArg, ModifierState } from '../base'\nimport { makeModifier } from '../base'\n\nexport interface Offset {\n  x: number\n  y: number\n  index: number\n  relativePoint?: Point | null\n}\n\nexport interface SnapPosition {\n  x?: number\n  y?: number\n  range?: number\n  offset?: Offset\n  [index: string]: any\n}\n\nexport type SnapFunction = (\n  x: number,\n  y: number,\n  interaction: InteractionProxy<ActionName>,\n  offset: Offset,\n  index: number,\n) => SnapPosition\nexport type SnapTarget = SnapPosition | SnapFunction\nexport interface SnapOptions {\n  targets: SnapTarget[] | null\n  // target range\n  range: number\n  // self points for snapping. [0,0] = top left, [1,1] = bottom right\n  relativePoints: Point[] | null\n  // startCoords = offset snapping from drag start page position\n  offset: Point | RectResolvable<[Interaction]> | 'startCoords' | null\n  offsetWithOrigin?: boolean\n  origin: RectResolvable<[Element]> | Point | null\n  endOnly?: boolean\n  enabled?: boolean\n}\n\nexport type SnapState = ModifierState<\nSnapOptions,\n{\n  offsets?: Offset[]\n  closest?: any\n  targetFields?: string[][]\n}\n>\n\nfunction start (arg: ModifierArg<SnapState>) {\n  const { interaction, interactable, element, rect, state, startOffset } = arg\n  const { options } = state\n  const origin = options.offsetWithOrigin ? getOrigin(arg) : { x: 0, y: 0 }\n\n  let snapOffset: Point\n\n  if (options.offset === 'startCoords') {\n    snapOffset = {\n      x: interaction.coords.start.page.x,\n      y: interaction.coords.start.page.y,\n    }\n  } else {\n    const offsetRect = resolveRectLike(options.offset as any, interactable, element, [interaction])\n\n    snapOffset = rectToXY(offsetRect) || { x: 0, y: 0 }\n    snapOffset.x += origin.x\n    snapOffset.y += origin.y\n  }\n\n  const { relativePoints } = options\n\n  state.offsets =\n    rect && relativePoints && relativePoints.length\n      ? relativePoints.map((relativePoint, index) => ({\n        index,\n        relativePoint,\n        x: startOffset.left - rect.width * relativePoint.x + snapOffset.x,\n        y: startOffset.top - rect.height * relativePoint.y + snapOffset.y,\n      }))\n      : [\n        {\n          index: 0,\n          relativePoint: null,\n          x: snapOffset.x,\n          y: snapOffset.y,\n        },\n      ]\n}\n\nfunction set (arg: ModifierArg<SnapState>) {\n  const { interaction, coords, state } = arg\n  const { options, offsets } = state\n\n  const origin = getOriginXY(interaction.interactable, interaction.element, interaction.prepared.name)\n  const page = extend({}, coords)\n  const targets = []\n\n  if (!options.offsetWithOrigin) {\n    page.x -= origin.x\n    page.y -= origin.y\n  }\n\n  for (const offset of offsets) {\n    const relativeX = page.x - offset.x\n    const relativeY = page.y - offset.y\n\n    for (let index = 0, len = options.targets.length; index < len; index++) {\n      const snapTarget = options.targets[index]\n      let target: SnapPosition\n\n      if (is.func(snapTarget)) {\n        target = snapTarget(relativeX, relativeY, interaction._proxy, offset, index)\n      } else {\n        target = snapTarget\n      }\n\n      if (!target) {\n        continue\n      }\n\n      targets.push({\n        x: (is.number(target.x) ? target.x : relativeX) + offset.x,\n        y: (is.number(target.y) ? target.y : relativeY) + offset.y,\n\n        range: is.number(target.range) ? target.range : options.range,\n        source: snapTarget,\n        index,\n        offset,\n      })\n    }\n  }\n\n  const closest = {\n    target: null,\n    inRange: false,\n    distance: 0,\n    range: 0,\n    delta: { x: 0, y: 0 },\n  }\n\n  for (const target of targets) {\n    const range = target.range\n    const dx = target.x - page.x\n    const dy = target.y - page.y\n    const distance = hypot(dx, dy)\n    let inRange = distance <= range\n\n    // Infinite targets count as being out of range\n    // compared to non infinite ones that are in range\n    if (range === Infinity && closest.inRange && closest.range !== Infinity) {\n      inRange = false\n    }\n\n    if (\n      !closest.target ||\n      (inRange\n        ? // is the closest target in range?\n        closest.inRange && range !== Infinity\n          ? // the pointer is relatively deeper in this target\n          distance / range < closest.distance / closest.range\n          : // this target has Infinite range and the closest doesn't\n          (range === Infinity && closest.range !== Infinity) ||\n            // OR this target is closer that the previous closest\n            distance < closest.distance\n        : // The other is not in range and the pointer is closer to this target\n        !closest.inRange && distance < closest.distance)\n    ) {\n      closest.target = target\n      closest.distance = distance\n      closest.range = range\n      closest.inRange = inRange\n      closest.delta.x = dx\n      closest.delta.y = dy\n    }\n  }\n\n  if (closest.inRange) {\n    coords.x = closest.target.x\n    coords.y = closest.target.y\n  }\n\n  state.closest = closest\n  return closest\n}\n\nfunction getOrigin (arg: Partial<ModifierArg<SnapState>>) {\n  const { element } = arg.interaction\n  const optionsOrigin = rectToXY(resolveRectLike(arg.state.options.origin as any, null, null, [element]))\n  const origin = optionsOrigin || getOriginXY(arg.interactable, element, arg.interaction.prepared.name)\n\n  return origin\n}\n\nconst defaults: SnapOptions = {\n  range: Infinity,\n  targets: null,\n  offset: null,\n  offsetWithOrigin: true,\n  origin: null,\n  relativePoints: null,\n  endOnly: false,\n  enabled: false,\n}\nconst snap = {\n  start,\n  set,\n  defaults,\n}\n\nexport default makeModifier(snap, 'snap')\nexport { snap }\n","// This module allows snapping of the size of targets during resize\n// interactions.\n\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\n\nimport type { ModifierArg } from '../base'\nimport { makeModifier } from '../base'\n\nimport type { SnapOptions, SnapState } from './pointer'\nimport { snap } from './pointer'\n\nexport type SnapSizeOptions = Pick<SnapOptions, 'targets' | 'offset' | 'endOnly' | 'range' | 'enabled'>\n\nfunction start (arg: ModifierArg<SnapState>) {\n  const { state, edges } = arg\n  const { options } = state\n\n  if (!edges) {\n    return null\n  }\n\n  arg.state = {\n    options: {\n      targets: null,\n      relativePoints: [\n        {\n          x: edges.left ? 0 : 1,\n          y: edges.top ? 0 : 1,\n        },\n      ],\n      offset: options.offset || 'self',\n      origin: { x: 0, y: 0 },\n      range: options.range,\n    },\n  }\n\n  state.targetFields = state.targetFields || [\n    ['width', 'height'],\n    ['x', 'y'],\n  ]\n\n  snap.start(arg)\n  state.offsets = arg.state.offsets\n\n  arg.state = state\n}\n\nfunction set (arg) {\n  const { interaction, state, coords } = arg\n  const { options, offsets } = state\n  const relative = {\n    x: coords.x - offsets[0].x,\n    y: coords.y - offsets[0].y,\n  }\n\n  state.options = extend({}, options)\n  state.options.targets = []\n\n  for (const snapTarget of options.targets || []) {\n    let target\n\n    if (is.func(snapTarget)) {\n      target = snapTarget(relative.x, relative.y, interaction)\n    } else {\n      target = snapTarget\n    }\n\n    if (!target) {\n      continue\n    }\n\n    for (const [xField, yField] of state.targetFields) {\n      if (xField in target || yField in target) {\n        target.x = target[xField]\n        target.y = target[yField]\n\n        break\n      }\n    }\n\n    state.options.targets.push(target)\n  }\n\n  const returnValue = snap.set(arg)\n\n  state.options = options\n\n  return returnValue\n}\n\nconst defaults: SnapSizeOptions = {\n  range: Infinity,\n  targets: null,\n  offset: null,\n  endOnly: false,\n  enabled: false,\n}\n\nconst snapSize = {\n  start,\n  set,\n  defaults,\n}\n\nexport default makeModifier(snapSize, 'snapSize')\nexport { snapSize }\n","/**\n * @module modifiers/snapEdges\n *\n * @description\n * WOW> This module allows snapping of the edges of targets during resize\n * interactions.\n *\n * ```js\n * interact(target).resizable({\n *   snapEdges: {\n *     targets: [interact.snappers.grid({ x: 100, y: 50 })],\n *   },\n * })\n *\n * interact(target).resizable({\n *   snapEdges: {\n *     targets: [\n *       interact.snappers.grid({\n *        top: 50,\n *        left: 50,\n *        bottom: 100,\n *        right: 100,\n *       }),\n *     ],\n *   },\n * })\n * ```\n */\n\nimport clone from '@interactjs/utils/clone'\nimport extend from '@interactjs/utils/extend'\n\nimport type { ModifierArg, ModifierModule } from '../base'\nimport { makeModifier } from '../base'\n\nimport type { SnapOptions, SnapState } from './pointer'\nimport { snapSize } from './size'\n\nexport type SnapEdgesOptions = Pick<SnapOptions, 'targets' | 'range' | 'offset' | 'endOnly' | 'enabled'>\n\nfunction start (arg: ModifierArg<SnapState>) {\n  const { edges } = arg\n\n  if (!edges) {\n    return null\n  }\n\n  arg.state.targetFields = arg.state.targetFields || [\n    [edges.left ? 'left' : 'right', edges.top ? 'top' : 'bottom'],\n  ]\n\n  return snapSize.start(arg)\n}\n\nconst snapEdges: ModifierModule<SnapEdgesOptions, SnapState, ReturnType<typeof snapSize.set>> = {\n  start,\n  set: snapSize.set,\n  defaults: extend(clone(snapSize.defaults), {\n    targets: null,\n    range: null,\n    offset: { x: 0, y: 0 },\n  } as const),\n}\n\nexport default makeModifier(snapEdges, 'snapEdges')\nexport { snapEdges }\n","/* eslint-disable node/no-extraneous-import, import/no-unresolved */\nimport aspectRatio from './aspectRatio'\nimport avoid from './avoid/avoid'\nimport restrictEdges from './restrict/edges'\nimport restrict from './restrict/pointer'\nimport restrictRect from './restrict/rect'\nimport restrictSize from './restrict/size'\nimport rubberband from './rubberband/rubberband'\nimport snapEdges from './snap/edges'\nimport snap from './snap/pointer'\nimport snapSize from './snap/size'\nimport spring from './spring/spring'\nimport transform from './transform/transform'\n\nexport default {\n  aspectRatio,\n  restrictEdges,\n  restrict,\n  restrictRect,\n  restrictSize,\n  snapEdges,\n  snap,\n  snapSize,\n\n  spring,\n  avoid,\n  transform,\n  rubberband,\n}\n","import type { Plugin } from '@interactjs/core/scope'\nimport snappers from '@interactjs/snappers/plugin'\n\nimport all from './all'\nimport base from './base'\n\ndeclare module '@interactjs/core/InteractStatic' {\n  export interface InteractStatic {\n    modifiers: typeof all\n  }\n}\n\nconst modifiers: Plugin = {\n  id: 'modifiers',\n  install (scope) {\n    const { interactStatic: interact } = scope\n\n    scope.usePlugin(base)\n    scope.usePlugin(snappers)\n\n    interact.modifiers = all\n\n    // for backwrads compatibility\n    for (const type in all) {\n      const { _defaults, _methods } = all[type as keyof typeof all]\n\n      ;(_defaults as any)._methods = _methods\n      ;(scope.defaults.perAction as any)[type] = _defaults\n    }\n  },\n}\n\nexport default modifiers\n","import { BaseEvent } from '@interactjs/core/BaseEvent'\nimport type Interaction from '@interactjs/core/Interaction'\nimport type { PointerEventType, PointerType, Point } from '@interactjs/types/index'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nexport default class PointerEvent<T extends string = any> extends BaseEvent<never> {\n  type: T\n  originalEvent: PointerEventType\n  pointerId: number\n  pointerType: string\n  double: boolean\n  pageX: number\n  pageY: number\n  clientX: number\n  clientY: number\n  dt: number\n  eventable: any;\n  [key: string]: any\n\n  /** */\n  constructor (\n    type: T,\n    pointer: PointerType | PointerEvent<any>,\n    event: PointerEventType,\n    eventTarget: Node,\n    interaction: Interaction<never>,\n    timeStamp: number,\n  ) {\n    super(interaction)\n    pointerUtils.pointerExtend(this, event)\n\n    if (event !== pointer) {\n      pointerUtils.pointerExtend(this, pointer)\n    }\n\n    this.timeStamp = timeStamp\n    this.originalEvent = event\n    this.type = type\n    this.pointerId = pointerUtils.getPointerId(pointer)\n    this.pointerType = pointerUtils.getPointerType(pointer)\n    this.target = eventTarget\n    this.currentTarget = null\n\n    if (type === 'tap') {\n      const pointerIndex = interaction.getPointerIndex(pointer)\n      this.dt = this.timeStamp - interaction.pointers[pointerIndex].downTime\n\n      const interval = this.timeStamp - interaction.tapTime\n\n      this.double = !!(\n        interaction.prevTap &&\n        interaction.prevTap.type !== 'doubletap' &&\n        interaction.prevTap.target === this.target &&\n        interval < 500\n      )\n    } else if (type === 'doubletap') {\n      this.dt = (pointer as PointerEvent<'tap'>).timeStamp - interaction.tapTime\n    }\n  }\n\n  _subtractOrigin ({ x: originX, y: originY }: Point) {\n    this.pageX -= originX\n    this.pageY -= originY\n    this.clientX -= originX\n    this.clientY -= originY\n\n    return this\n  }\n\n  _addOrigin ({ x: originX, y: originY }: Point) {\n    this.pageX += originX\n    this.pageY += originY\n    this.clientX += originX\n    this.clientY += originY\n\n    return this\n  }\n\n  /**\n   * Prevent the default behaviour of the original Event\n   */\n  preventDefault () {\n    this.originalEvent.preventDefault()\n  }\n}\n\nexport { PointerEvent }\n","import type { Eventable } from '@interactjs/core/Eventable'\nimport type { Interaction } from '@interactjs/core/Interaction'\nimport type { PerActionDefaults } from '@interactjs/core/options'\nimport type { Scope, SignalArgs, Plugin } from '@interactjs/core/scope'\nimport type { Point, PointerType, PointerEventType, Element } from '@interactjs/types'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport getOriginXY from '@interactjs/utils/getOriginXY'\n\nimport { PointerEvent } from './PointerEvent'\n\nexport type EventTargetList = Array<{\n  node: Node\n  eventable: Eventable\n  props: { [key: string]: any }\n}>\n\nexport interface PointerEventOptions extends PerActionDefaults {\n  enabled?: undefined // not used\n  holdDuration?: number\n  ignoreFrom?: any\n  allowFrom?: any\n  origin?: Point | string | Element\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    pointerEvents: typeof pointerEvents\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    prevTap?: PointerEvent<string>\n    tapTime?: number\n  }\n}\n\ndeclare module '@interactjs/core/PointerInfo' {\n  interface PointerInfo {\n    hold?: {\n      duration: number\n      timeout: any\n    }\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface ActionDefaults {\n    pointerEvents: Options\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'pointerEvents:new': { pointerEvent: PointerEvent<any> }\n    'pointerEvents:fired': {\n      interaction: Interaction<null>\n      pointer: PointerType | PointerEvent<any>\n      event: PointerEventType | PointerEvent<any>\n      eventTarget: Node\n      pointerEvent: PointerEvent<any>\n      targets?: EventTargetList\n      type: string\n    }\n    'pointerEvents:collect-targets': {\n      interaction: Interaction<any>\n      pointer: PointerType | PointerEvent<any>\n      event: PointerEventType | PointerEvent<any>\n      eventTarget: Node\n      targets?: EventTargetList\n      type: string\n      path: Node[]\n      node: null\n    }\n  }\n}\n\nconst defaults: PointerEventOptions = {\n  holdDuration: 600,\n  ignoreFrom: null,\n  allowFrom: null,\n  origin: { x: 0, y: 0 },\n}\n\nconst pointerEvents: Plugin = {\n  id: 'pointer-events/base',\n  before: ['inertia', 'modifiers', 'auto-start', 'actions'],\n  install,\n  listeners: {\n    'interactions:new': addInteractionProps,\n    'interactions:update-pointer': addHoldInfo,\n    'interactions:move': moveAndClearHold,\n    'interactions:down': (arg, scope) => {\n      downAndStartHold(arg, scope)\n      fire(arg, scope)\n    },\n    'interactions:up': (arg, scope) => {\n      clearHold(arg)\n      fire(arg, scope)\n      tapAfterUp(arg, scope)\n    },\n    'interactions:cancel': (arg, scope) => {\n      clearHold(arg)\n      fire(arg, scope)\n    },\n  },\n  PointerEvent,\n  fire,\n  collectEventTargets,\n  defaults,\n  types: {\n    down: true,\n    move: true,\n    up: true,\n    cancel: true,\n    tap: true,\n    doubletap: true,\n    hold: true,\n  } as { [type: string]: true },\n}\n\nfunction fire<T extends string> (\n  arg: {\n    pointer: PointerType | PointerEvent<any>\n    event: PointerEventType | PointerEvent<any>\n    eventTarget: Node\n    interaction: Interaction<never>\n    type: T\n    targets?: EventTargetList\n  },\n  scope: Scope,\n) {\n  const { interaction, pointer, event, eventTarget, type, targets = collectEventTargets(arg, scope) } = arg\n\n  const pointerEvent = new PointerEvent(type, pointer, event, eventTarget, interaction, scope.now())\n\n  scope.fire('pointerEvents:new', { pointerEvent })\n\n  const signalArg = {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    targets,\n    type,\n    pointerEvent,\n  }\n\n  for (let i = 0; i < targets.length; i++) {\n    const target = targets[i]\n\n    for (const prop in target.props || {}) {\n      ;(pointerEvent as any)[prop] = target.props[prop]\n    }\n\n    const origin = getOriginXY(target.eventable, target.node)\n\n    pointerEvent._subtractOrigin(origin)\n    pointerEvent.eventable = target.eventable\n    pointerEvent.currentTarget = target.node\n\n    target.eventable.fire(pointerEvent)\n\n    pointerEvent._addOrigin(origin)\n\n    if (\n      pointerEvent.immediatePropagationStopped ||\n      (pointerEvent.propagationStopped &&\n        i + 1 < targets.length &&\n        targets[i + 1].node !== pointerEvent.currentTarget)\n    ) {\n      break\n    }\n  }\n\n  scope.fire('pointerEvents:fired', signalArg)\n\n  if (type === 'tap') {\n    // if pointerEvent should make a double tap, create and fire a doubletap\n    // PointerEvent and use that as the prevTap\n    const prevTap = pointerEvent.double\n      ? fire(\n        {\n          interaction,\n          pointer,\n          event,\n          eventTarget,\n          type: 'doubletap',\n        },\n        scope,\n      )\n      : pointerEvent\n\n    interaction.prevTap = prevTap\n    interaction.tapTime = prevTap.timeStamp\n  }\n\n  return pointerEvent\n}\n\nfunction collectEventTargets<T extends string> (\n  {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    type,\n  }: {\n    interaction: Interaction<any>\n    pointer: PointerType | PointerEvent<any>\n    event: PointerEventType | PointerEvent<any>\n    eventTarget: Node\n    type: T\n  },\n  scope: Scope,\n) {\n  const pointerIndex = interaction.getPointerIndex(pointer)\n  const pointerInfo = interaction.pointers[pointerIndex]\n\n  // do not fire a tap event if the pointer was moved before being lifted\n  if (\n    type === 'tap' &&\n    (interaction.pointerWasMoved ||\n      // or if the pointerup target is different to the pointerdown target\n      !(pointerInfo && pointerInfo.downTarget === eventTarget))\n  ) {\n    return []\n  }\n\n  const path = domUtils.getPath(eventTarget as Element | Document)\n  const signalArg = {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    type,\n    path,\n    targets: [] as EventTargetList,\n    node: null,\n  }\n\n  for (const node of path) {\n    signalArg.node = node\n\n    scope.fire('pointerEvents:collect-targets', signalArg)\n  }\n\n  if (type === 'hold') {\n    signalArg.targets = signalArg.targets.filter(\n      (target) => target.eventable.options.holdDuration === interaction.pointers[pointerIndex]?.hold.duration,\n    )\n  }\n\n  return signalArg.targets\n}\n\nfunction addInteractionProps ({ interaction }) {\n  interaction.prevTap = null // the most recent tap event on this interaction\n  interaction.tapTime = 0 // time of the most recent tap event\n}\n\nfunction addHoldInfo ({ down, pointerInfo }: SignalArgs['interactions:update-pointer']) {\n  if (!down && pointerInfo.hold) {\n    return\n  }\n\n  pointerInfo.hold = { duration: Infinity, timeout: null }\n}\n\nfunction clearHold ({ interaction, pointerIndex }) {\n  const hold = interaction.pointers[pointerIndex].hold\n\n  if (hold && hold.timeout) {\n    clearTimeout(hold.timeout)\n    hold.timeout = null\n  }\n}\n\nfunction moveAndClearHold (arg: SignalArgs['interactions:move'], scope: Scope) {\n  const { interaction, pointer, event, eventTarget, duplicate } = arg\n\n  if (!duplicate && (!interaction.pointerIsDown || interaction.pointerWasMoved)) {\n    if (interaction.pointerIsDown) {\n      clearHold(arg)\n    }\n\n    fire(\n      {\n        interaction,\n        pointer,\n        event,\n        eventTarget: eventTarget as Element,\n        type: 'move',\n      },\n      scope,\n    )\n  }\n}\n\nfunction downAndStartHold (\n  { interaction, pointer, event, eventTarget, pointerIndex }: SignalArgs['interactions:down'],\n  scope: Scope,\n) {\n  const timer = interaction.pointers[pointerIndex].hold\n  const path = domUtils.getPath(eventTarget as Element | Document)\n  const signalArg = {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    type: 'hold',\n    targets: [] as EventTargetList,\n    path,\n    node: null,\n  }\n\n  for (const node of path) {\n    signalArg.node = node\n\n    scope.fire('pointerEvents:collect-targets', signalArg)\n  }\n\n  if (!signalArg.targets.length) return\n\n  let minDuration = Infinity\n\n  for (const target of signalArg.targets) {\n    const holdDuration = target.eventable.options.holdDuration\n\n    if (holdDuration < minDuration) {\n      minDuration = holdDuration\n    }\n  }\n\n  timer.duration = minDuration\n  timer.timeout = setTimeout(() => {\n    fire(\n      {\n        interaction,\n        eventTarget,\n        pointer,\n        event,\n        type: 'hold',\n      },\n      scope,\n    )\n  }, minDuration)\n}\n\nfunction tapAfterUp (\n  { interaction, pointer, event, eventTarget }: SignalArgs['interactions:up'],\n  scope: Scope,\n) {\n  if (!interaction.pointerWasMoved) {\n    fire({ interaction, eventTarget, pointer, event, type: 'tap' }, scope)\n  }\n}\n\nfunction install (scope: Scope) {\n  scope.pointerEvents = pointerEvents\n  scope.defaults.actions.pointerEvents = pointerEvents.defaults\n  extend(scope.actions.phaselessTypes, pointerEvents.types)\n}\n\nexport default pointerEvents\n","import type Interaction from '@interactjs/core/Interaction'\nimport type { ListenerMap, Scope, SignalArgs, Plugin } from '@interactjs/core/scope'\n\nimport type PointerEvent from './PointerEvent'\nimport basePlugin from './base'\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    holdIntervalHandle?: any\n  }\n}\n\ndeclare module '@interactjs/pointer-events/PointerEvent' {\n  interface PointerEvent<T extends string = any> {\n    count?: number\n  }\n}\n\ndeclare module '@interactjs/pointer-events/base' {\n  interface PointerEventOptions {\n    holdRepeatInterval?: number\n  }\n}\n\nfunction install (scope: Scope) {\n  scope.usePlugin(basePlugin)\n\n  const { pointerEvents } = scope\n\n  // don't repeat by default\n  pointerEvents.defaults.holdRepeatInterval = 0\n  pointerEvents.types.holdrepeat = scope.actions.phaselessTypes.holdrepeat = true\n}\n\nfunction onNew ({ pointerEvent }: { pointerEvent: PointerEvent<any> }) {\n  if (pointerEvent.type !== 'hold') return\n\n  pointerEvent.count = (pointerEvent.count || 0) + 1\n}\n\nfunction onFired (\n  { interaction, pointerEvent, eventTarget, targets }: SignalArgs['pointerEvents:fired'],\n  scope: Scope,\n) {\n  if (pointerEvent.type !== 'hold' || !targets.length) return\n\n  // get the repeat interval from the first eventable\n  const interval = targets[0].eventable.options.holdRepeatInterval\n\n  // don't repeat if the interval is 0 or less\n  if (interval <= 0) return\n\n  // set a timeout to fire the holdrepeat event\n  interaction.holdIntervalHandle = setTimeout(() => {\n    scope.pointerEvents.fire(\n      {\n        interaction,\n        eventTarget,\n        type: 'hold',\n        pointer: pointerEvent,\n        event: pointerEvent,\n      },\n      scope,\n    )\n  }, interval)\n}\n\nfunction endHoldRepeat ({ interaction }: { interaction: Interaction }) {\n  // set the interaction's holdStopTime property\n  // to stop further holdRepeat events\n  if (interaction.holdIntervalHandle) {\n    clearInterval(interaction.holdIntervalHandle)\n    interaction.holdIntervalHandle = null\n  }\n}\n\nconst holdRepeat: Plugin = {\n  id: 'pointer-events/holdRepeat',\n  install,\n  listeners: ['move', 'up', 'cancel', 'endall'].reduce(\n    (acc, enderTypes) => {\n      ;(acc as any)[`pointerEvents:${enderTypes}`] = endHoldRepeat\n      return acc\n    },\n    {\n      'pointerEvents:new': onNew,\n      'pointerEvents:fired': onFired,\n    } as ListenerMap,\n  ),\n}\n\nexport default holdRepeat\n","import type { Interactable } from '@interactjs/core/Interactable'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type { Element } from '@interactjs/types/index'\nimport extend from '@interactjs/utils/extend'\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    pointerEvents: typeof pointerEventsMethod\n    __backCompatOption: (optionName: string, newValue: any) => any\n  }\n}\n\nfunction install (scope: Scope) {\n  const { Interactable } = scope\n\n  Interactable.prototype.pointerEvents = pointerEventsMethod\n\n  const __backCompatOption = Interactable.prototype._backCompatOption\n\n  Interactable.prototype._backCompatOption = function (optionName, newValue) {\n    const ret = __backCompatOption.call(this, optionName, newValue)\n\n    if (ret === this) {\n      this.events.options[optionName] = newValue\n    }\n\n    return ret\n  }\n}\n\nfunction pointerEventsMethod (this: Interactable, options: any) {\n  extend(this.events.options, options)\n\n  return this\n}\n\nconst plugin: Plugin = {\n  id: 'pointer-events/interactableTargets',\n  install,\n  listeners: {\n    'pointerEvents:collect-targets': ({ targets, node, type, eventTarget }, scope) => {\n      scope.interactables.forEachMatch(node, (interactable: Interactable) => {\n        const eventable = interactable.events\n        const options = eventable.options\n\n        if (\n          eventable.types[type] &&\n          eventable.types[type].length &&\n          interactable.testIgnoreAllow(options, node, eventTarget)\n        ) {\n          targets.push({\n            node,\n            eventable,\n            props: { interactable },\n          })\n        }\n      })\n    },\n\n    'interactable:new': ({ interactable }) => {\n      interactable.events.getRect = function (element: Element) {\n        return interactable.getRect(element)\n      }\n    },\n\n    'interactable:set': ({ interactable, options }, scope) => {\n      extend(interactable.events.options, scope.pointerEvents.defaults)\n      extend(interactable.events.options, options.pointerEvents || {})\n    },\n  },\n}\n\nexport default plugin\n","import type { Plugin } from '@interactjs/core/scope'\n\nimport * as pointerEvents from './base'\nimport holdRepeat from './holdRepeat'\nimport interactableTargets from './interactableTargets'\n\nconst plugin: Plugin = {\n  id: 'pointer-events',\n  install (scope) {\n    scope.usePlugin(pointerEvents)\n    scope.usePlugin(holdRepeat)\n    scope.usePlugin(interactableTargets)\n  },\n}\n\nexport default plugin\n","import type { Interactable } from '@interactjs/core/Interactable'\nimport type { ActionProps, DoAnyPhaseArg, Interaction } from '@interactjs/core/Interaction'\nimport type { ActionName, Scope, Plugin } from '@interactjs/core/scope'\nimport type { Element } from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\nimport is from '@interactjs/utils/is'\nimport { copyAction } from '@interactjs/utils/misc'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\nimport { tlbrToXywh } from '@interactjs/utils/rect'\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactions:before-action-reflow': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-reflow': DoAnyPhaseArg\n    'interactions:after-action-reflow': DoAnyPhaseArg\n  }\n}\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    reflow: <T extends ActionName>(action: ActionProps<T>) => ReturnType<typeof doReflow>\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    _reflowPromise: Promise<void>\n    _reflowResolve: (...args: unknown[]) => void\n  }\n}\n\ndeclare module '@interactjs/core/InteractEvent' {\n  interface PhaseMap {\n    reflow?: true\n  }\n}\n\nexport function install (scope: Scope) {\n  const {\n    /** @lends Interactable */\n    Interactable,\n  } = scope\n\n  scope.actions.phases.reflow = true\n\n  /**\n   * ```js\n   * const interactable = interact(target)\n   * const drag = { name: drag, axis: 'x' }\n   * const resize = { name: resize, edges: { left: true, bottom: true }\n   *\n   * interactable.reflow(drag)\n   * interactable.reflow(resize)\n   * ```\n   *\n   * Start an action sequence to re-apply modifiers, check drops, etc.\n   *\n   * @param { Object } action The action to begin\n   * @param { string } action.name The name of the action\n   * @returns { Promise } A promise that resolves to the `Interactable` when actions on all targets have ended\n   */\n  Interactable.prototype.reflow = function (action: ActionProps) {\n    return doReflow(this, action, scope)\n  }\n}\n\nfunction doReflow<T extends ActionName> (\n  interactable: Interactable,\n  action: ActionProps<T>,\n  scope: Scope,\n): Promise<Interactable> {\n  const elements = (is.string(interactable.target)\n    ? arr.from(interactable._context.querySelectorAll(interactable.target))\n    : [interactable.target]) as Element[]\n\n  // tslint:disable-next-line variable-name\n  const Promise = (scope.window as any).Promise\n  const promises: Array<Promise<null>> | null = Promise ? [] : null\n\n  for (const element of elements) {\n    const rect = interactable.getRect(element as HTMLElement | SVGElement)\n\n    if (!rect) {\n      break\n    }\n\n    const runningInteraction = arr.find(scope.interactions.list, (interaction: Interaction) => {\n      return (\n        interaction.interacting() &&\n        interaction.interactable === interactable &&\n        interaction.element === element &&\n        interaction.prepared.name === action.name\n      )\n    })\n    let reflowPromise: Promise<null>\n\n    if (runningInteraction) {\n      runningInteraction.move()\n\n      if (promises) {\n        reflowPromise =\n          runningInteraction._reflowPromise ||\n          new Promise((resolve: any) => {\n            runningInteraction._reflowResolve = resolve\n          })\n      }\n    } else {\n      const xywh = tlbrToXywh(rect)\n      const coords = {\n        page: { x: xywh.x, y: xywh.y },\n        client: { x: xywh.x, y: xywh.y },\n        timeStamp: scope.now(),\n      }\n\n      const event = pointerUtils.coordsToEvent(coords)\n      reflowPromise = startReflow<T>(scope, interactable, element, action, event)\n    }\n\n    if (promises) {\n      promises.push(reflowPromise)\n    }\n  }\n\n  return promises && Promise.all(promises).then(() => interactable)\n}\n\nfunction startReflow<T extends ActionName> (\n  scope: Scope,\n  interactable: Interactable,\n  element: Element,\n  action: ActionProps<T>,\n  event: any,\n) {\n  const interaction = scope.interactions.new({ pointerType: 'reflow' })\n  const signalArg = {\n    interaction,\n    event,\n    pointer: event,\n    eventTarget: element,\n    phase: 'reflow',\n  } as const\n\n  interaction.interactable = interactable\n  interaction.element = element\n  interaction.prevEvent = event\n  interaction.updatePointer(event, event, element, true)\n  pointerUtils.setZeroCoords(interaction.coords.delta)\n\n  copyAction(interaction.prepared, action)\n  interaction._doPhase(signalArg)\n\n  const { Promise } = (scope.window as unknown) as { Promise: PromiseConstructor }\n  const reflowPromise = Promise\n    ? new Promise<undefined>((resolve) => {\n      interaction._reflowResolve = resolve\n    })\n    : undefined\n\n  interaction._reflowPromise = reflowPromise\n  interaction.start(action, interactable, element)\n\n  if (interaction._interacting) {\n    interaction.move(signalArg)\n    interaction.end(event)\n  } else {\n    interaction.stop()\n    interaction._reflowResolve()\n  }\n\n  interaction.removePointer(event, event)\n\n  return reflowPromise\n}\n\nconst reflow: Plugin = {\n  id: 'reflow',\n  install,\n  listeners: {\n    // remove completed reflow interactions\n    'interactions:stop': ({ interaction }, scope) => {\n      if (interaction.pointerType === 'reflow') {\n        if (interaction._reflowResolve) {\n          interaction._reflowResolve()\n        }\n\n        arr.remove(scope.interactions.list, interaction)\n      }\n    },\n  },\n}\n\nexport default reflow\n","import actions from '@interactjs/actions/plugin'\nimport autoScroll from '@interactjs/auto-scroll/plugin'\nimport autoStart from '@interactjs/auto-start/plugin'\nimport interactablePreventDefault from '@interactjs/core/interactablePreventDefault'\nimport devTools from '@interactjs/dev-tools/plugin'\nimport inertia from '@interactjs/inertia/plugin'\nimport interact from '@interactjs/interact'\nimport modifiers from '@interactjs/modifiers/plugin'\nimport offset from '@interactjs/offset/plugin'\nimport pointerEvents from '@interactjs/pointer-events/plugin'\nimport reflow from '@interactjs/reflow/plugin'\n\ninteract.use(interactablePreventDefault)\n\ninteract.use(offset)\n\n// pointerEvents\ninteract.use(pointerEvents)\n\n// inertia\ninteract.use(inertia)\n\n// snap, resize, etc.\ninteract.use(modifiers)\n\n// autoStart, hold\ninteract.use(autoStart)\n\n// drag and drop, resize, gesture\ninteract.use(actions)\n\n// autoScroll\ninteract.use(autoScroll)\n\n// reflow\ninteract.use(reflow)\n\n// eslint-disable-next-line no-undef\nif (process.env.NODE_ENV !== 'production') {\n  interact.use(devTools)\n}\n\nexport default interact\n\nif (typeof module === 'object' && !!module) {\n  try {\n    module.exports = interact\n  } catch {}\n}\n\n;(interact as any).default = interact\n","// eslint-disable-next-line import/no-extraneous-dependencies\nimport interact from '@interactjs/interactjs/index'\n\nexport default interact\n\nif (typeof module === 'object' && !!module) {\n  try {\n    module.exports = interact\n  } catch {}\n}\n\n;(interact as any).default = interact\n","\nreturn _$index_79;\n\n});\n","<template>\r\n  <NavBar_game />\r\n  <div id=\"game\">\r\n    <Swipeable\r\n        v-for=\"card in cards\"\r\n        :key=\"card.id\"\r\n        v-on:swipe=\"onSwipe\"\r\n        :style=\"{\r\n        position: 'absolute',\r\n        height: '400px',\r\n        width: '250px',\r\n        background: card.color,\r\n        borderRadius: '8px',\r\n      }\"\r\n    />\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport NavBar_game from \"@/components/NavBar_game\";\r\nimport { Swipeable } from \"vue-swipy\";\r\nfunction getRandomColor() {\r\n  var letters = \"0123456789ABCDEF\";\r\n  var color = \"#\";\r\n  for (var i = 0; i < 6; i++) {\r\n    color += letters[Math.floor(Math.random() * 16)];\r\n  }\r\n  return color;\r\n}\r\n\r\nexport default {\r\n  name: \"DramkaGame\",\r\n  components: { Swipeable, NavBar_game },\r\n  data() {\r\n    return { cards: [], src: require('/public/assets/characters/girl.svg')};\r\n  },\r\n  mounted() {\r\n    this.cards.push({ id: Math.random(), color: getRandomColor() });\r\n    this.cards.push({ id: Math.random(), color: getRandomColor() });\r\n    this.cards.push({ id: Math.random(), color: getRandomColor() });\r\n  },\r\n  methods: {\r\n    onSwipe(direction) {\r\n      console.log(direction);\r\n      setTimeout(() => {\r\n        this.cards.pop();\r\n        this.cards.unshift({ id: Math.random(), color: getRandomColor() });\r\n      }, 300);\r\n    },\r\n  },\r\n};\r\n</script>\r\n\r\n<style>\r\nbody {\r\n  margin: 0;\r\n}\r\n.card {\r\n  position: absolute;\r\n  height: 400px;\r\n  width: 300px;\r\n  border-radius: 8px;\r\n  /*background-color: antiquewhite;*/\r\n  /*background-image: url(\"/public/assets/characters/girl.svg\");*/\r\n}\r\n#game {\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  height: 100vh;\r\n  width: 100vw;\r\n}\r\n</style>","<template>\r\n  <header :class=\"{'scrolled-nav' : scrollPosition}\">\r\n    <nav>\r\n      <router-link class=\"link\" :to=\"{name: 'Home'}\"><img src=\"assets/logo.svg\"></router-link>\r\n      <ul class=\"navigation\">\r\n          <li><router-link class=\"glitchy\" data-glitch=\" \" :to=\"{name: 'Home',hash: '#team'}\"> </router-link></li>\r\n          <li><router-link class=\"glitchy\" data-glitch=\"\" :to=\"{name: 'Home'}\"></router-link></li>\r\n      </ul>\r\n    </nav>\r\n  </header>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  name: \"NavBar\",\r\n  data() {\r\n    return {\r\n      scrollPosition: null,\r\n        // hash: this.$route.hash,\r\n    };\r\n  },\r\n    // mounted() {\r\n    //     this.$nextTick(function () {\r\n    //         if (this.hash) {\r\n    //             const refName = this.hash.replace('#', '')\r\n    //             this.scrollToAnchorPoint(refName)\r\n    //         }\r\n    //     })\r\n    // },\r\n    // methods: {\r\n    //     scrollToAnchorPoint(refName) {\r\n    //         const el = this.$refs[refName]\r\n    //         el.scrollIntoView({ behavior: 'smooth' })\r\n    //     }\r\n    // }\r\n};\r\n</script>\r\n\r\n<style lang=\"scss\" scoped>\r\nheader{\r\n  background-color: transparent;\r\n  z-index: 99;\r\n  width: 100%;\r\n  position: fixed;\r\n  transition: 0.5s ease all;\r\n  color: white;\r\n  nav{\r\n    display: flex;\r\n    flex-direction: row;\r\n    padding: 12px 0;\r\n    transition: .5s ease all;\r\n    width: 90%;\r\n    margin: 0 auto;\r\n    ul, .link{\r\n      font-weight: 500;\r\n      color: #f1f1f1;\r\n      list-style: none;\r\n      text-decoration: none;\r\n    }\r\n    li{\r\n      text-transform: uppercase;\r\n      padding: 16px;\r\n      margin-left: 16px;\r\n    }\r\n    .glitchy{\r\n      font: {\r\n        size: 14px;\r\n        family: 'Raleway', sans-serif;\r\n      }\r\n      text-decoration: none;\r\n      text-transform: uppercase;\r\n      position: relative;\r\n      top: 50%;\r\n      transform: translate(-50%, -50%);\r\n      margin: 0;\r\n      color: #fff;\r\n      letter-spacing: 5px;\r\n      &:before, &:after {\r\n        display: block;\r\n        content: attr(data-glitch);\r\n        text-transform: uppercase;\r\n        position: absolute;\r\n        top: 0;\r\n        left: 0;\r\n        height: 100%;\r\n        width: 100%;\r\n        opacity: .8;\r\n      }\r\n      &:after {\r\n        color: #f0f;\r\n        z-index: -2;\r\n      }\r\n      &:before {\r\n        color: #0ff;\r\n        z-index: -1;\r\n      }\r\n      &:hover {\r\n        &:before {\r\n          animation: glitch .3s cubic-bezier(.25, .46, .45, .94) both 5\r\n        }\r\n        &:after {\r\n          animation: glitch .3s cubic-bezier(.25, .46, .45, .94) reverse both 5\r\n        }\r\n      }\r\n    }\r\n    }\r\n    img{\r\n      display: flex;\r\n      align-items: center;\r\n      width: 60px;\r\n    }\r\n    .navigation{\r\n      display: flex;\r\n      align-items: center;\r\n      flex: 1;\r\n      justify-content: flex-end;\r\n    }\r\n  }\r\n@keyframes glitch {\r\n  0% {\r\n    transform: translate(0)\r\n  }\r\n  20% {\r\n    transform: translate(-5px, 5px)\r\n  }\r\n  40% {\r\n    transform: translate(-5px, -5px)\r\n  }\r\n  60% {\r\n    transform: translate(5px, 5px)\r\n  }\r\n  80% {\r\n    transform: translate(5px, -5px)\r\n  }\r\n  to {\r\n    transform: translate(0)\r\n  }\r\n}\r\n\r\n@media (max-width: 500px) {\r\n  header nav .link{\r\n    font-size: 10px;\r\n  }\r\n  header nav li {\r\n    padding: 4px;\r\n    margin-left: 8px;\r\n  }\r\n}\r\n</style>","import { render } from \"./NavBar_game.vue?vue&type=template&id=67350884&scoped=true\"\nimport script from \"./NavBar_game.vue?vue&type=script&lang=js\"\nexport * from \"./NavBar_game.vue?vue&type=script&lang=js\"\n\nimport \"./NavBar_game.vue?vue&type=style&index=0&id=67350884&lang=scss&scoped=true\"\n\nimport exportComponent from \"C:\\\\Project\\\\dramka_project\\\\node_modules\\\\vue-loader\\\\dist\\\\exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render],['__scopeId',\"data-v-67350884\"]])\n\nexport default __exports__","<template>\n  <div\n    ref=\"interactElement\"\n    :style=\"{\n      transform: transformString,\n      transition: transitionString,\n      touchAction: 'none',\n    }\"\n  >\n    <slot />\n  </div>\n</template>\n\n<script>\nimport interact from \"interactjs\";\n\nconst INTERACT_ON_START = \"start\";\nconst INTERACT_ON_MOVE = \"move\";\nconst INTERACT_ON_END = \"end\";\n\nconst SWIPE_LEFT = \"swipe-left\";\nconst SWIPE_RIGHT = \"swipe-right\";\nconst SWIPE_TOP = \"swipe-top\";\nconst SWIPE_BOTTOM = \"swipe-bottom\";\nconst SWIPE_ANY = \"swipe\";\n\nexport default {\n  name: \"Swipeable\",\n  props: {\n    transition: {\n      type: String,\n      default: \"transform 0.5s cubic-bezier(0.2, 0.8, 0.4, 1.2)\",\n      required: false,\n    },\n    maxRotation: {\n      type: Number,\n      default: 15,\n      required: false,\n    },\n    outOfSightXOffset: {\n      type: Number,\n      default: 500,\n      required: false,\n    },\n    outOfSightYOffset: {\n      type: Number,\n      default: 500,\n      required: false,\n    },\n    thresholdX: {\n      type: Number,\n      default: 50,\n      required: false,\n    },\n    thresholdY: {\n      type: Number,\n      default: 70,\n      required: false,\n    },\n  },\n  data() {\n    return {\n      isDragging: true,\n      interactPosition: {\n        x: 0,\n        y: 0,\n        rotation: 0,\n      },\n    };\n  },\n  computed: {\n    transformString() {\n      const { x, y, rotation } = this.interactPosition;\n      return `translate3D(${x}px, ${y}px, 0) rotate(${rotation}deg)`;\n    },\n    transitionString() {\n      return !this.isDragging && this.$props.transition;\n    },\n  },\n  mounted() {\n    const element = this.$refs.interactElement;\n    interact(element).draggable({\n      onstart: () => {\n        this.$emit(INTERACT_ON_START);\n        this.isDragging = true;\n      },\n      onmove: (event) => {\n        this.$emit(INTERACT_ON_MOVE);\n        const { maxRotation, thresholdX } = this.$props;\n        const x = this.interactPosition.x + event.dx;\n        const y = this.interactPosition.y + event.dy;\n        let rotation = maxRotation * (x / thresholdX);\n        if (rotation > maxRotation) rotation = maxRotation;\n        else if (rotation < -maxRotation) rotation = -maxRotation;\n\n        this.setPosition({ x, y, rotation });\n      },\n      onend: () => {\n        this.$emit(INTERACT_ON_END);\n        const { x, y } = this.interactPosition;\n        const { thresholdX, thresholdY } = this.$props;\n        this.isDragging = false;\n\n        if (x > thresholdX) this.onThresholdReached(SWIPE_RIGHT);\n        else if (x < -thresholdX) this.onThresholdReached(SWIPE_LEFT);\n        else if (y < -thresholdY) this.onThresholdReached(SWIPE_TOP);\n        else if (y > thresholdY) this.onThresholdReached(SWIPE_BOTTOM);\n        else this.setPosition({ x: 0, y: 0, rotation: 0 });\n      },\n    });\n  },\n  beforeDestroy() {\n    this.unsetInteractElement();\n  },\n  methods: {\n    onThresholdReached(interaction) {\n      const { outOfSightXOffset, outOfSightYOffset, maxRotation } = this.$props;\n      this.unsetInteractElement();\n      switch (interaction) {\n        case SWIPE_RIGHT:\n          this.setPosition({\n            x: outOfSightXOffset,\n            rotation: maxRotation,\n          });\n          this.$emit(SWIPE_RIGHT);\n          break;\n        case SWIPE_LEFT:\n          this.setPosition({\n            x: -outOfSightXOffset,\n            rotation: -maxRotation,\n          });\n          this.$emit(SWIPE_LEFT);\n          break;\n        case SWIPE_TOP:\n          this.setPosition({\n            y: -outOfSightYOffset,\n          });\n          this.$emit(SWIPE_TOP);\n          break;\n        case SWIPE_BOTTOM:\n          this.setPosition({\n            y: outOfSightYOffset,\n          });\n          this.$emit(SWIPE_BOTTOM);\n          break;\n      }\n      this.$emit(SWIPE_ANY, interaction);\n    },\n    setPosition(position) {\n      const { x = 0, y = 0, rotation = 0 } = position;\n      this.interactPosition = { x, y, rotation };\n    },\n    unsetInteractElement() {\n      interact(this.$refs.interactElement).unset();\n    },\n  },\n};\n</script>\n","import { render } from \"./Swipeable.vue?vue&type=template&id=0e90e380\"\nimport script from \"./Swipeable.vue?vue&type=script&lang=js\"\nexport * from \"./Swipeable.vue?vue&type=script&lang=js\"\n\nimport exportComponent from \"C:\\\\Project\\\\dramka_project\\\\node_modules\\\\vue-loader\\\\dist\\\\exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","import { render } from \"./DramkaGame.vue?vue&type=template&id=2d987bd0\"\nimport script from \"./DramkaGame.vue?vue&type=script&lang=js\"\nexport * from \"./DramkaGame.vue?vue&type=script&lang=js\"\n\nimport \"./DramkaGame.vue?vue&type=style&index=0&id=2d987bd0&lang=css\"\n\nimport exportComponent from \"C:\\\\Project\\\\dramka_project\\\\node_modules\\\\vue-loader\\\\dist\\\\exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__"],"names":["t","Object","value","Window","e","ownerDocument","defaultView","r","window","n","o","document","createTextNode","wrap","s","a","l","u","docFrag","nodeType","object","func","number","bool","string","element","getWindow","test","Element","nodeName","plainObject","constructor","toString","array","length","splice","i","f","interaction","prepared","name","axis","coords","cur","page","y","start","client","velocity","x","d","iEvent","delta","p","id","install","actions","Interactable","defaults","prototype","draggable","map","drag","methodDict","listeners","interactable","buttons","options","enabled","pointerIsDown","pointerType","mouseButtons","action","lockAxis","startAxis","this","setPerAction","setOnEvents","beforeMove","move","getCursor","v","c","g","init","DocumentFragment","SVGElement","SVGSVGElement","SVGElementInstance","HTMLElement","Event","Touch","PointerEvent","MSPointerEvent","h","navigator","supportsTouch","DocumentTouch","supportsPointerEvent","pointerEnabled","isIOS","platform","isIOS7","appVersion","isIe9","userAgent","isOperaMobile","appName","prefixedMatchesSelector","pEventTypes","up","down","over","out","cancel","wheelEvent","w","b","P","parentNode","host","O","realWindow","replace","contains","_","S","E","ownerSVGElement","lastChild","previousSibling","parseInt","getComputedStyle","zIndex","correspondingUseElement","M","T","left","right","top","bottom","push","querySelector","unshift","scrollX","documentElement","scrollLeft","scrollY","scrollTop","getBoundingClientRect","getClientRects","width","height","D","getRect","closest","apply","getElementRect","k","origin","resolveRectLike","rectToXY","z","trim","split","search","reduce","Math","sqrt","X","prefixedPropREs","indexOf","webkit","moz","F","W","L","U","V","N","type","touches","changedTouches","q","pageX","pageY","clientX","clientY","screenX","screenY","timeStamp","B","max","pointerId","identifier","min","atan2","PI","composedPath","path","getActualElement","target","currentTarget","preventDefault","enumerable","get","configurable","writable","K","H","_interaction","key","propagationStopped","immediatePropagationStopped","G","$","defineProperty","_proxy","set","Z","J","Q","lt","prev","dropzone","dragEvent","relatedTarget","dropState","rejected","events","enter","stopImmediatePropagation","activeDrops","findIndex","fire","nt","tt","ct","slice","ft","interactables","list","drop","accept","matchesSelector","draggableElement","_context","querySelectorAll","rect","dt","dropCheck","indexOfDeepestElement","pt","leave","activate","deactivate","dragLeave","prevDropzone","dragEnter","dragmove","vt","ht","event","dynamicDrop","gt","interactStatic","usePlugin","keys","off","on","ondrop","ondropactivate","ondropdeactivate","ondragenter","ondragleave","ondropmove","overlap","checker","getPageXY","phaselessTypes","dragenter","dragleave","dropactivate","dropdeactivate","dropmove","getActiveDrops","getDrop","getDropEvents","fireDropEvents","yt","ut","bt","phase","pointers","pointer","deltaSource","distance","touchDistance","box","touchBBox","scale","ds","angle","touchAngle","da","gesture","startDistance","startAngle","prevEvent","isNaN","xt","before","gesturable","wt","mt","Pt","abs","matchesUpTo","Ot","resizeAxes","resize","square","axes","St","browser","cursors","xy","topleft","bottomright","topright","bottomleft","defaultMargin","resizable","preserveAspectRatio","edges","_rects","corrected","previous","deltaRect","invert","_latestPointer","eventTarget","margin","NaN","Et","_t","Tt","kt","It","Dt","At","request","requestAnimationFrame","cancelAnimationFrame","bind","Date","now","setTimeout","clearTimeout","jt","body","scrollWidth","scrollHeight","Rt","autoScroll","Ct","container","Ft","zt","speed","isScrolling","prevTime","scroll","stop","scrollBy","check","onInteractionMove","interacting","simulation","innerWidth","innerHeight","getElementClientRect","getStringOptionResult","autoscroll","perAction","console","warn","arguments","Yt","Wt","styleCursor","Lt","actionChecker","getAction","button","ignoreFrom","warnOnce","_backCompatOption","allowFrom","Bt","Nt","testIgnoreAllow","Ht","qt","$t","forEachMatch","manualStart","Gt","copyAction","Jt","maxPerElement","autoStart","maxInteractions","interactions","Kt","Zt","cursorElement","style","cursor","cursorChecker","_interacting","base","withinInteractionLimit","pointerWasMoved","validateAction","Vt","dx","dy","downPointer","downEvent","te","re","hold","delay","autoStartHoldTimer","duplicate","getHoldDuration","ne","ie","le","ue","checkAndPreventDefault","ce","supportsPassive","getDocOptions","passive","docEvents","listener","nodeContains","se","pe","ve","touchAction","boxSizing","noListeners","from","_e","we","result","Pe","modifiers","methods","_methods","filter","prepareStates","startOffset","Oe","startDelta","fillArg","pageCoords","preEnd","startAll","setAll","states","state","skipModifiers","shouldDo","addEdges","eventProps","rectDelta","changed","modifiedCoords","applyToInteraction","beforeEnd","endResult","index","modification","endOnly","setStart","xe","ye","Ee","enable","disable","_defaults","Se","setAndApply","restoreInteractionCoords","Fe","Me","Re","ctrlKey","altKey","shiftKey","metaKey","t0","downTime","x0","y0","clientX0","clientY0","duration","swipe","getSwipe","velocityY","velocityX","Ie","je","defineProperties","Ye","downTarget","Be","We","Le","_ProxyMethods","Ne","qe","scopeFire","Ve","newCoords","_scopeFire","updatePointer","pointerIndex","pointerInfo","_stopped","_doPhase","pointerMoveTolerance","getPointerIndex","setCoordVelocity","copyCoords","setZeroCoords","curEventTarget","end","removePointer","_ending","getPointerId","Xe","setCoords","_now","setCoordDeltas","pointerExtend","_updateLatestPointer","_createPreparedEvent","_fireEvent","Ue","He","Qe","offset","total","pending","Ke","Ze","Je","offsetBy","Interaction","Ge","rn","an","copyFrom","allowResume","v0","currentOffset","startCoords","modifierArg","minSpeed","endSpeed","startInertia","startSmoothEnd","targetOffset","active","resistance","log","lambda_v0","one_ve_v0","isModified","modifiedOffset","onNextFrame","inertiaTick","smoothEnd","smoothEndTick","timeout","exp","sn","smoothEndDuration","ln","modifierCount","nn","inertia","en","default","phases","inertiastart","resume","addEventModifiers","pn","vn","dn","global","types","merge","fn","cn","substr","new","globalEvents","getPointerAverage","pointerAverage","getTouchBBox","getTouchDistance","getTouchAngle","version","scope","use","isSet","context","add","remove","debug","addDocument","removeDocument","xn","bn","_actions","_win","trySelector","_doc","_scopeEvents","onstart","onmove","onend","oninertiastart","updatePerActionListeners","_rectChecker","testIgnore","testAllow","_onOff","delegatedEvents","selector","removeDelegate","mn","yn","On","addListeners","selectorMap","win","find","inContext","_n","wn","kn","Tn","originalEvent","stopPropagation","En","In","capture","addDelegate","m","delegateListener","delegateUseCapture","documents","targets","supportsOptions","addEventListener","removeEventListener","hasOwnProperty","Mn","getEventTargets","createElement","Sn","Rn","methodOrder","simulationResume","eventType","mouseOrPen","zn","hasPointer","idle","some","An","qn","$n","getPointerType","prevTouchTime","Gn","searchDetails","Hn","doc","pointerDown","pointerMove","pointerUp","documentBlur","Ln","destroy","onDocSignal","doOnInteractions","methodNames","Fn","sr","rr","floor","random","createInteractStatic","Qn","listenerMaps","isInitialized","lr","_plugins","pluginIsInstalled","ur","getDocIndex","onWindowUnload","Zn","fr","dr","cr","pr","globalThis","range","limits","grid","round","coordFields","gr","snappers","br","createSnapGrid","xr","Sr","Er","ratio","equalDelta","startRect","linkedEdges","xIsPrimaryAxis","edgeSign","subModification","Tr","Mr","prevCoords","prevRect","_r","makeModifier","Ir","kr","zr","Cr","elementRect","restriction","xywhToTlbr","Rr","Yr","Br","Wr","Lr","noInner","noOuter","getRestrictionRect","inner","outer","Xr","Nr","qr","Vr","Hr","Kr","Zr","tlbrToXywh","Gr","eo","offsetWithOrigin","relativePoints","offsets","relativePoint","source","inRange","to","io","targetFields","ro","lo","so","aspectRatio","restrictEdges","restrict","restrictRect","restrictSize","snapEdges","snap","snapSize","spring","avoid","transform","rubberband","po","ho","So","Po","Oo","tapTime","double","prevTap","bo","yo","To","pointerEvents","ko","Mo","getPath","node","eventable","holdDuration","collectEventTargets","tap","doubletap","jo","pointerEvent","props","_subtractOrigin","_addOrigin","Eo","Ao","holdIntervalHandle","clearInterval","holdRepeatInterval","holdrepeat","count","Do","Co","call","zo","Xo","Wo","reflow","Promise","_reflowPromise","_reflowResolve","coordsToEvent","all","then","Bo","exports","Vo","Uo","$o","qo","_createVNode","_component_NavBar_game","_createElementVNode","_createElementBlock","_Fragment","_renderList","$data","card","_createBlock","_component_Swipeable","onSwipe","$options","color","src","class","_component_router_link","_hoisted_1","hash","data","scrollPosition","__exports__","ref","_renderSlot","_ctx","INTERACT_ON_START","INTERACT_ON_MOVE","INTERACT_ON_END","SWIPE_LEFT","SWIPE_RIGHT","SWIPE_TOP","SWIPE_BOTTOM","SWIPE_ANY","transition","String","required","maxRotation","Number","outOfSightXOffset","outOfSightYOffset","thresholdX","thresholdY","isDragging","interactPosition","rotation","computed","transformString","transitionString","$props","mounted","$refs","interactElement","interact","$emit","setPosition","onThresholdReached","beforeDestroy","unsetInteractElement","position","unset","getRandomColor","letters","components","Swipeable","NavBar_game","cards","require","direction","pop","render"],"sourceRoot":""}